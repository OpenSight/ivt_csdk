PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\json_writer.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
;	COMDAT ??_C@_05CFGAKADK@?$CF?416g?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02PFNDMDBO@?$FL?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02DHOGEDBE@?5?$FN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MNJOIFPO@?$HL?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03MCPBMLDJ@?5?3?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02KCGCGHLG@?5?$HN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02MCILKGOH@?$HL?$HN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?uintToString@Json@@YAXIAAPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0fastDocument@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1fastDocument@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YfastDocument@Json@@QAEXD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YfastDocument@Json@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4fastDocument@Json@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@fastDocument@Json@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@fastDocument@Json@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@fastDocument@Json@@QAEXN@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@fastDocument@Json@@QAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@fastDocument@Json@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?appendQuoted@fastDocument@Json@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@fastDocument@Json@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AfastDocument@Json@@QAEDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@fastDocument@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getData@fastDocument@Json@@QAEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@fastDocument@Json@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?occupy@fastDocument@Json@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?write@FastWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0StyledWriter@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?write@StyledWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?writeIndent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?writeWithIndent@StyledWriter@Json@@AAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?indent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?unindent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT XFeÐFe
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT xFe¨
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT @@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT (Ie
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ÿÿ
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ÞûÿÿÜ¶a
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT èIe
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT hJe
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ÿÿ
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT HOe
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ˆQe
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ¸g¸;
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ø…d5<
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ?AV?$basic_istream@DU?$char_traits@D@std@@@std@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT std@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ¨
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT d@@@std@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT overflow_error@std@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?AVcodecvt_base@std@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT d
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ¨
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ¨
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT range_error@std@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT std@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT streambuf@GU?$char_traits@G@std@@@std@@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT “d
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC

PUBLIC	??_C@_05CFGAKADK@?$CF?416g?$AA@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_04MLLLIHIP@null?$AA@			; `string'
PUBLIC	??_C@_02PFNDMDBO@?$FL?5?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_02DHOGEDBE@?5?$FN?$AA@			; `string'
PUBLIC	??_C@_02MNJOIFPO@?$HL?5?$AA@			; `string'
PUBLIC	??_C@_03MCPBMLDJ@?5?3?5?$AA@			; `string'
PUBLIC	??_C@_02KCGCGHLG@?5?$HN?$AA@			; `string'
PUBLIC	??_C@_02MCILKGOH@?$HL?$HN?$AA@			; `string'
PUBLIC	??_C@_01HCONENDN@?$HL?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN?$AA@			; `string'
PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
;	COMDAT ??_C@_05CFGAKADK@?$CF?416g?$AA@
CONST	SEGMENT
??_C@_05CFGAKADK@?$CF?416g?$AA@ DB '%.16g', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null?$AA@
CONST	SEGMENT
??_C@_04MLLLIHIP@null?$AA@ DB 'null', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PFNDMDBO@?$FL?5?$AA@
CONST	SEGMENT
??_C@_02PFNDMDBO@?$FL?5?$AA@ DB '[ ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHOGEDBE@?5?$FN?$AA@
CONST	SEGMENT
??_C@_02DHOGEDBE@?5?$FN?$AA@ DB ' ]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MNJOIFPO@?$HL?5?$AA@
CONST	SEGMENT
??_C@_02MNJOIFPO@?$HL?5?$AA@ DB '{ ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCPBMLDJ@?5?3?5?$AA@
CONST	SEGMENT
??_C@_03MCPBMLDJ@?5?3?5?$AA@ DB ' : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KCGCGHLG@?5?$HN?$AA@
CONST	SEGMENT
??_C@_02KCGCGHLG@?5?$HN?$AA@ DB ' }', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCILKGOH@?$HL?$HN?$AA@
CONST	SEGMENT
??_C@_02MCILKGOH@?$HL?$HN?$AA@ DB '{}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL?$AA@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN?$AA@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
PUBLIC	?occupy@fastDocument@Json@@AAEXI@Z		; Json::fastDocument::occupy
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_writer.cpp
;	COMDAT ?occupy@fastDocument@Json@@AAEXI@Z
_TEXT	SEGMENT
?occupy@fastDocument@Json@@AAEXI@Z PROC NEAR		; Json::fastDocument::occupy, COMDAT
; _this$ = esi
; _n$ = ecx

; 152  : 	size_t len = n + npos + 1;

	mov	eax, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [eax+ecx+1]

; 153  : 	if(len > cap)

	cmp	eax, DWORD PTR [esi+8]
	jbe	SHORT $L11765

; 154  : 	{
; 155  : 		cap = (len | (grow_size - 1)) + 1;

	or	eax, 16383				; 00003fffH
	inc	eax
	push	edi

; 156  : 		char* p = new char[cap];

	push	eax
	mov	DWORD PTR [esi+8], eax
	call	??_U@YAPAXI@Z				; operator new[]

; 157  : 		if(data)

	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	test	ecx, ecx
	mov	edi, eax
	je	SHORT $L11769

; 158  : 		{
; 159  : 			strcpy(p, data);

	mov	edx, edi
	npad	7
$L17684:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L17684

; 160  : 			delete[]data;

	mov	edx, DWORD PTR [esi]
	push	edx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L11769:

; 161  : 		}
; 162  : 		data = p;

	mov	DWORD PTR [esi], edi
	pop	edi
$L11765:

; 163  : 	}
; 164  : }

	ret	0
?occupy@fastDocument@Json@@AAEXI@Z ENDP			; Json::fastDocument::occupy
_TEXT	ENDS
PUBLIC	?clear@fastDocument@Json@@QAEXXZ		; Json::fastDocument::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@fastDocument@Json@@QAEXXZ
_TEXT	SEGMENT
?clear@fastDocument@Json@@QAEXXZ PROC NEAR		; Json::fastDocument::clear, COMDAT
; _this$ = esi

; 143  : 	if(data)

	mov	eax, DWORD PTR [esi]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $L17693

; 144  : 	{
; 145  : 		delete []data;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L17693:

; 146  : 	}
; 147  : 	cap = npos = 0;

	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	pop	edi

; 148  : }

	ret	0
?clear@fastDocument@Json@@QAEXXZ ENDP			; Json::fastDocument::clear
_TEXT	ENDS
PUBLIC	?getData@fastDocument@Json@@QAEPBDXZ		; Json::fastDocument::getData
; Function compile flags: /Ogtpy
;	COMDAT ?getData@fastDocument@Json@@QAEPBDXZ
_TEXT	SEGMENT
?getData@fastDocument@Json@@QAEPBDXZ PROC NEAR		; Json::fastDocument::getData, COMDAT
; _this$ = eax

; 138  : 	return data;

	mov	eax, DWORD PTR [eax]

; 139  : }

	ret	0
?getData@fastDocument@Json@@QAEPBDXZ ENDP		; Json::fastDocument::getData
_TEXT	ENDS
PUBLIC	?empty@fastDocument@Json@@QBE_NXZ		; Json::fastDocument::empty
; Function compile flags: /Ogtpy
;	COMDAT ?empty@fastDocument@Json@@QBE_NXZ
_TEXT	SEGMENT
?empty@fastDocument@Json@@QBE_NXZ PROC NEAR		; Json::fastDocument::empty, COMDAT
; _this$ = ecx

; 133  : 	return (!data);

	mov	edx, DWORD PTR [ecx]
	xor	eax, eax
	test	edx, edx
	sete	al

; 134  : }

	ret	0
?empty@fastDocument@Json@@QBE_NXZ ENDP			; Json::fastDocument::empty
_TEXT	ENDS
PUBLIC	??AfastDocument@Json@@QAEDI@Z			; Json::fastDocument::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??AfastDocument@Json@@QAEDI@Z
_TEXT	SEGMENT
??AfastDocument@Json@@QAEDI@Z PROC NEAR			; Json::fastDocument::operator[], COMDAT
; _this$ = eax
; _off$ = edx

; 126  : 	assert(data && off < npos);
; 127  : 
; 128  : 	return data[off];

	mov	ecx, DWORD PTR [eax]
	mov	al, BYTE PTR [edx+ecx]

; 129  : }

	ret	0
??AfastDocument@Json@@QAEDI@Z ENDP			; Json::fastDocument::operator[]
_TEXT	ENDS
PUBLIC	?length@fastDocument@Json@@QBEIXZ		; Json::fastDocument::length
; Function compile flags: /Ogtpy
;	COMDAT ?length@fastDocument@Json@@QBEIXZ
_TEXT	SEGMENT
?length@fastDocument@Json@@QBEIXZ PROC NEAR		; Json::fastDocument::length, COMDAT
; _this$ = eax

; 121  : 	return npos;

	mov	eax, DWORD PTR [eax+4]

; 122  : }

	ret	0
?length@fastDocument@Json@@QBEIXZ ENDP			; Json::fastDocument::length
_TEXT	ENDS
PUBLIC	??YfastDocument@Json@@QAEXPBD@Z			; Json::fastDocument::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??YfastDocument@Json@@QAEXPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
??YfastDocument@Json@@QAEXPBD@Z PROC NEAR		; Json::fastDocument::operator+=, COMDAT
; _this$ = esi

; 42   : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _str$[esp+4]

; 43   : 	size_t len = strlen(str);

	mov	eax, ebp
	lea	edx, DWORD PTR [eax+1]
	npad	5
$L17725:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $L17725

; 44   : 	occupy(len);

	mov	ecx, DWORD PTR [esi+8]
	sub	eax, edx
	mov	ebx, eax
	mov	eax, DWORD PTR [esi+4]
	lea	eax, DWORD PTR [ebx+eax+1]
	cmp	eax, ecx
	jbe	SHORT $L17720
	or	eax, 16383				; 00003fffH
	inc	eax
	push	edi
	push	eax
	mov	DWORD PTR [esi+8], eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	test	ecx, ecx
	mov	edi, eax
	je	SHORT $L17722
	mov	edx, edi
$L17716:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L17716
	mov	ecx, DWORD PTR [esi]
	push	ecx
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L17722:
	mov	DWORD PTR [esi], edi
	pop	edi
$L17720:

; 45   : 	strcpy(data + npos, str);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, ebp
	add	eax, ecx
$L17709:
	mov	cl, BYTE PTR [edx]
	inc	edx
	mov	BYTE PTR [eax], cl
	inc	eax
	test	cl, cl
	jne	SHORT $L17709

; 46   : 	npos+= len;

	mov	eax, DWORD PTR [esi+4]
	add	eax, ebx
	pop	ebp
	mov	DWORD PTR [esi+4], eax
	pop	ebx

; 47   : }

	ret	4
??YfastDocument@Json@@QAEXPBD@Z ENDP			; Json::fastDocument::operator+=
_TEXT	ENDS
PUBLIC	??YfastDocument@Json@@QAEXD@Z			; Json::fastDocument::operator+=
; Function compile flags: /Ogtpy
;	COMDAT ??YfastDocument@Json@@QAEXD@Z
_TEXT	SEGMENT
_ch$ = 8						; size = 1
??YfastDocument@Json@@QAEXD@Z PROC NEAR			; Json::fastDocument::operator+=, COMDAT
; _this$ = esi

; 35   : 	occupy(1);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+8]
	add	eax, 2
	cmp	eax, ecx
	jbe	SHORT $L17739
	or	eax, 16383				; 00003fffH
	inc	eax
	push	edi
	push	eax
	mov	DWORD PTR [esi+8], eax
	call	??_U@YAPAXI@Z				; operator new[]
	mov	ecx, DWORD PTR [esi]
	add	esp, 4
	test	ecx, ecx
	mov	edi, eax
	je	SHORT $L17741
	mov	edx, edi
	npad	6
$L17735:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	BYTE PTR [edx], al
	inc	edx
	test	al, al
	jne	SHORT $L17735
	mov	eax, DWORD PTR [esi]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L17741:
	mov	DWORD PTR [esi], edi
	pop	edi
$L17739:

; 36   : 	data[npos] = ch;

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR [esi+4]
	mov	al, BYTE PTR _ch$[esp-4]
	mov	BYTE PTR [ecx+edx], al

; 37   : 	npos++;

	mov	eax, DWORD PTR [esi+4]

; 38   : 	data[npos] = '\0';

	mov	ecx, DWORD PTR [esi]
	inc	eax
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+ecx], 0

; 39   : }

	ret	4
??YfastDocument@Json@@QAEXD@Z ENDP			; Json::fastDocument::operator+=
_TEXT	ENDS
PUBLIC	??1fastDocument@Json@@QAE@XZ			; Json::fastDocument::~fastDocument
; Function compile flags: /Ogtpy
;	COMDAT ??1fastDocument@Json@@QAE@XZ
_TEXT	SEGMENT
??1fastDocument@Json@@QAE@XZ PROC NEAR			; Json::fastDocument::~fastDocument, COMDAT
; _this$ = esi

; 30   : 	clear();

	mov	eax, DWORD PTR [esi]
	push	edi
	xor	edi, edi
	cmp	eax, edi
	je	SHORT $L17752
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L17752:
	mov	DWORD PTR [esi+4], edi
	mov	DWORD PTR [esi+8], edi
	pop	edi

; 31   : }

	ret	0
??1fastDocument@Json@@QAE@XZ ENDP			; Json::fastDocument::~fastDocument
_TEXT	ENDS
PUBLIC	??0fastDocument@Json@@QAE@XZ			; Json::fastDocument::fastDocument
; Function compile flags: /Ogtpy
;	COMDAT ??0fastDocument@Json@@QAE@XZ
_TEXT	SEGMENT
??0fastDocument@Json@@QAE@XZ PROC NEAR			; Json::fastDocument::fastDocument, COMDAT
; _this$ = eax

; 25   : {

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx

; 26   : }

	ret	0
??0fastDocument@Json@@QAE@XZ ENDP			; Json::fastDocument::fastDocument
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?uintToString@Json@@YAXIAAPAD@Z
_TEXT	SEGMENT
?uintToString@Json@@YAXIAAPAD@Z PROC NEAR		; Json::uintToString, COMDAT
; _value$ = eax
; _current$ = ecx

; 15   :    *--current = 0;

	mov	edx, DWORD PTR [ecx]
	dec	edx
	push	esi
	mov	DWORD PTR [ecx], edx
	mov	BYTE PTR [edx], 0
	push	edi
	npad	6
$L11678:

; 16   :    do
; 17   :    {
; 18   :       *--current = (value % 10) + '0';

	mov	edx, DWORD PTR [ecx]
	dec	edx
	mov	DWORD PTR [ecx], edx
	mov	esi, edx
	xor	edx, edx
	mov	edi, 10					; 0000000aH
	div	edi
	add	dl, 48					; 00000030H

; 19   :       value /= 10;
; 20   :    }
; 21   :    while ( value != 0 );

	test	eax, eax
	mov	BYTE PTR [esi], dl
	jne	SHORT $L11678
	pop	edi
	pop	esi

; 22   : }

	ret	0
?uintToString@Json@@YAXIAAPAD@Z ENDP			; Json::uintToString
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty, COMDAT
; _this$ = ecx

; 526  : 		return (size() == 0);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L19808
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	al, cl

; 527  : 		}

	ret	0

; 526  : 		return (size() == 0);

$L19808:
	mov	ecx, DWORD PTR [ecx+8]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	mov	al, cl

; 527  : 		}

	ret	0
?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
_TEXT	ENDS
PUBLIC	?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::hasCommentForValue
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_writer.cpp
;	COMDAT ?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z PROC NEAR ; Json::StyledWriter::hasCommentForValue, COMDAT
; _value$ = eax

; 448  :    return value.hasComment( commentBefore )
; 449  :           ||  value.hasComment( commentAfterOnSameLine )
; 450  :           ||  value.hasComment( commentAfter );

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $L19833
	cmp	DWORD PTR [eax], 0
	jne	SHORT $L19813
	test	eax, eax
	je	SHORT $L19833
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $L19813
	test	eax, eax
	je	SHORT $L19833
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jne	SHORT $L19813
$L19833:
	xor	eax, eax

; 451  : }

	ret	0
$L19813:

; 448  :    return value.hasComment( commentBefore )
; 449  :           ||  value.hasComment( commentAfterOnSameLine )
; 450  :           ||  value.hasComment( commentAfter );

	mov	eax, 1

; 451  : }

	ret	0
?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledWriter::hasCommentForValue
_TEXT	ENDS
PUBLIC	?appendQuoted@fastDocument@Json@@QAEXPBD@Z	; Json::fastDocument::appendQuoted
; Function compile flags: /Ogtpy
;	COMDAT ?appendQuoted@fastDocument@Json@@QAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?appendQuoted@fastDocument@Json@@QAEXPBD@Z PROC NEAR	; Json::fastDocument::appendQuoted, COMDAT
; _this$ = eax

; 113  : {

	push	esi
	mov	esi, eax

; 114  : 	*this += "\"";

	push	OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 115  : 	*this += value;

	mov	eax, DWORD PTR _value$[esp]
	push	eax
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 116  : 	*this += "\"";

	push	OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	pop	esi

; 117  : }

	ret	4
?appendQuoted@fastDocument@Json@@QAEXPBD@Z ENDP		; Json::fastDocument::appendQuoted
_TEXT	ENDS
PUBLIC	?append@fastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@fastDocument@Json@@QAEXPBD@Z
_TEXT	SEGMENT
?append@fastDocument@Json@@QAEXPBD@Z PROC NEAR		; Json::fastDocument::append, COMDAT
; _this$ = esi
; _value$ = eax

; 109  : 	*this += value;

	push	eax
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 110  : }

	ret	0
?append@fastDocument@Json@@QAEXPBD@Z ENDP		; Json::fastDocument::append
_TEXT	ENDS
PUBLIC	?append@fastDocument@Json@@QAEX_N@Z		; Json::fastDocument::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@fastDocument@Json@@QAEX_N@Z
_TEXT	SEGMENT
?append@fastDocument@Json@@QAEX_N@Z PROC NEAR		; Json::fastDocument::append, COMDAT
; _this$ = esi
; _value$ = eax

; 104  : 	*this += (value ? "true" : "false");

	test	al, al
	mov	eax, OFFSET FLAT:??_C@_04LOAJBDKD@true?$AA@
	jne	SHORT $L19851
	mov	eax, OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
$L19851:
	push	eax
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 105  : }

	ret	0
?append@fastDocument@Json@@QAEX_N@Z ENDP		; Json::fastDocument::append
_TEXT	ENDS
PUBLIC	?append@fastDocument@Json@@QAEXN@Z		; Json::fastDocument::append
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogtpy
;	COMDAT ?append@fastDocument@Json@@QAEXN@Z
_TEXT	SEGMENT
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_value$ = 8						; size = 8
?append@fastDocument@Json@@QAEXN@Z PROC NEAR		; Json::fastDocument::append, COMDAT
; _this$ = esi

; 90   : {

	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie

; 91   : 	char buffer[32];
; 92   : #ifdef __STDC_SECURE_LIB__ // Use secure version with visual studio 2005 to avoid warning.
; 93   : 	sprintf_s(buffer, sizeof(buffer), "%.16g", value); 
; 94   : #else	
; 95   : 	sprintf(buffer, "%.16g", value); 

	fld	QWORD PTR _value$[esp+32]
	sub	esp, 8
	mov	DWORD PTR __$ArrayPad$[esp+44], eax
	fstp	QWORD PTR [esp]
	lea	eax, DWORD PTR _buffer$[esp+44]
	push	OFFSET FLAT:??_C@_05CFGAKADK@?$CF?416g?$AA@
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 96   : #endif
; 97   : 
; 98   : 	*this += buffer;

	lea	ecx, DWORD PTR _buffer$[esp+36]
	push	ecx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 99   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+36]
	call	@__security_check_cookie@4
	add	esp, 36					; 00000024H
	ret	8
?append@fastDocument@Json@@QAEXN@Z ENDP			; Json::fastDocument::append
_TEXT	ENDS
PUBLIC	?append@fastDocument@Json@@QAEXI@Z		; Json::fastDocument::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@fastDocument@Json@@QAEXI@Z
_TEXT	SEGMENT
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_value$ = 12						; size = 4
?append@fastDocument@Json@@QAEXI@Z PROC NEAR		; Json::fastDocument::append, COMDAT

; 80   : {

	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[esp+36], eax

; 81   : 	char buffer[32];
; 82   : 	char *current = buffer + sizeof(buffer);
; 83   : 	uintToString( value, current );

	mov	eax, DWORD PTR _value$[esp+32]
	lea	ecx, DWORD PTR _buffer$[esp+67]
	mov	BYTE PTR _buffer$[esp+67], 0
	push	esi
	npad	6
$L19866:
	xor	edx, edx
	mov	esi, 10					; 0000000aH
	div	esi
	dec	ecx
	add	dl, 48					; 00000030H
	test	eax, eax
	mov	BYTE PTR [ecx], dl
	jne	SHORT $L19866

; 84   : 	assert( current >= buffer );
; 85   : 
; 86   : 	*this += current;

	mov	esi, DWORD PTR _this$[esp+36]
	push	ecx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 87   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+40]
	pop	esi
	call	@__security_check_cookie@4
	add	esp, 36					; 00000024H
	ret	8
?append@fastDocument@Json@@QAEXI@Z ENDP			; Json::fastDocument::append
_TEXT	ENDS
PUBLIC	?append@fastDocument@Json@@QAEXH@Z		; Json::fastDocument::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@fastDocument@Json@@QAEXH@Z
_TEXT	SEGMENT
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_value$ = 12						; size = 4
?append@fastDocument@Json@@QAEXH@Z PROC NEAR		; Json::fastDocument::append, COMDAT

; 64   : {

	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[esp+36], eax
	mov	eax, DWORD PTR _value$[esp+32]

; 65   : 	char buffer[32];
; 66   : 	char *current = buffer + sizeof(buffer);
; 67   : 	bool isNegative = value < 0;

	test	eax, eax
	push	ebx
	setl	bl

; 68   : 
; 69   : 	if ( isNegative )

	test	bl, bl
	push	esi
	je	SHORT $L11712

; 70   : 		value = -value;

	neg	eax
$L11712:

; 71   : 	uintToString( Value::UInt(value), current );

	lea	ecx, DWORD PTR _buffer$[esp+75]
	mov	BYTE PTR _buffer$[esp+75], 0
$L19878:
	xor	edx, edx
	mov	esi, 10					; 0000000aH
	div	esi
	dec	ecx
	add	dl, 48					; 00000030H
	test	eax, eax
	mov	BYTE PTR [ecx], dl
	jne	SHORT $L19878

; 72   : 	if ( isNegative )

	test	bl, bl
	je	SHORT $L11713

; 73   : 		*--current = '-';

	dec	ecx
	mov	BYTE PTR [ecx], 45			; 0000002dH
$L11713:

; 74   : 	assert( current >= buffer );
; 75   : 
; 76   : 	*this += current;

	mov	esi, DWORD PTR _this$[esp+40]
	push	ecx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 77   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+44]
	pop	esi
	pop	ebx
	call	@__security_check_cookie@4
	add	esp, 36					; 00000024H
	ret	8
?append@fastDocument@Json@@QAEXH@Z ENDP			; Json::fastDocument::append
_TEXT	ENDS
PUBLIC	??4fastDocument@Json@@QAEXPBD@Z			; Json::fastDocument::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4fastDocument@Json@@QAEXPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
??4fastDocument@Json@@QAEXPBD@Z PROC NEAR		; Json::fastDocument::operator=, COMDAT
; _this$ = eax

; 58   : {

	push	esi
	mov	esi, eax

; 59   : 	clear();

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L19893
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L19893:

; 60   : 	*this += str;

	mov	eax, DWORD PTR _str$[esp]
	push	eax
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	pop	esi

; 61   : }

	ret	4
??4fastDocument@Json@@QAEXPBD@Z ENDP			; Json::fastDocument::operator=
PUBLIC	??0StyledWriter@Json@@QAE@XZ			; Json::StyledWriter::StyledWriter
; Function compile flags: /Ogtpy
;	COMDAT ??0StyledWriter@Json@@QAE@XZ
_TEXT	SEGMENT
??0StyledWriter@Json@@QAE@XZ PROC NEAR			; Json::StyledWriter::StyledWriter, COMDAT
; _this$ = eax

; 250  : {

	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+36], 15			; 0000000fH
	mov	DWORD PTR [eax+32], ecx
	mov	BYTE PTR [eax+16], cl
	mov	DWORD PTR [eax+40], 74			; 0000004aH
	mov	DWORD PTR [eax+44], 3

; 251  : }

	ret	0
??0StyledWriter@Json@@QAE@XZ ENDP			; Json::StyledWriter::StyledWriter
_TEXT	ENDS
PUBLIC	??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::fastDocument::operator+=
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T23387	DD	0ffffffffH
	DD	FLAT:$L23292
$T23384	DD	019930520H
	DD	01H
	DD	FLAT:$T23387
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_str$ = 8						; size = 28
??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; Json::fastDocument::operator+=, COMDAT
; _this$ = esi

; 50   : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	mov	DWORD PTR __$EHRec$[esp+20], 0

; 51   : 	if(!str.empty())

	mov	eax, DWORD PTR _str$[esp+28]
	test	eax, eax
	je	SHORT $L11700

; 52   : 	{
; 53   : 		*this += str.c_str();

	cmp	DWORD PTR _str$[esp+32], 16		; 00000010H
	mov	eax, DWORD PTR _str$[esp+12]
	jae	SHORT $L23309
	lea	eax, DWORD PTR _str$[esp+12]
$L23309:
	push	eax
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
$L11700:

; 54   : 	}
; 55   : }

	cmp	DWORD PTR _str$[esp+32], 16		; 00000010H
	jb	SHORT $L23373
	mov	eax, DWORD PTR _str$[esp+12]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L23373:
	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 12					; 0000000cH
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L23292:
	lea	ecx, DWORD PTR _str$[ebp-4]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	eax, OFFSET FLAT:$T23384
	jmp	___CxxFrameHandler
text$x	ENDS
??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::fastDocument::operator+=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 1125 : 		if (_Newsize <= _Mysize)

	mov	edx, DWORD PTR [ecx+20]
	cmp	eax, edx
	ja	SHORT $L12847

; 1126 : 			erase(_Newsize);

	push	-1
	push	eax
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1129 : 		}

	ret	4
$L12847:
	push	esi

; 1127 : 		else
; 1128 : 			append(_Newsize - _Mysize, _Ch);

	mov	esi, DWORD PTR __Ch$[esp]
	push	esi
	sub	eax, edx
	mov	esi, ecx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1129 : 		}

	ret	4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = esi

; 626  : 		{	// assign _Count * _Ch

	push	ebp
	mov	ebp, DWORD PTR __Count$[esp]

; 627  : 		if (_Count == npos)

	cmp	ebp, -1
	jne	SHORT $L12843

; 628  : 			_String_base::_Xlen();	// result too long

	mov	ecx, esi
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen

; 629  : 
; 630  : 		if (_Grow(_Count))

	jmp	SHORT $L26210
$L12843:
	cmp	ebp, -2					; fffffffeH
	jbe	SHORT $L26172
$L26210:
	mov	ecx, esi
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L26172:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebp
	jae	SHORT $L26173
	mov	eax, DWORD PTR [esi+20]
	push	eax
	push	ebp
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	ebp, ebp
$L26212:
	jbe	SHORT $L26211

; 631  : 			{	// make room and assign new stuff
; 632  : 			_Traits::assign(_Myptr(), _Count, _Ch);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	push	ebx
	push	edi
	jb	SHORT $L26182
	mov	edi, DWORD PTR [esi+4]
	jmp	SHORT $L26183

; 629  : 
; 630  : 		if (_Grow(_Count))

$L26173:
	test	ebp, ebp
	jne	SHORT $L26212
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], ebp
	jb	SHORT $L26165
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], 0

; 634  : 			}
; 635  : 		return (*this);

	mov	eax, esi
	pop	ebp

; 636  : 		}

	ret	8

; 629  : 
; 630  : 		if (_Grow(_Count))

$L26165:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], 0

; 634  : 			}
; 635  : 		return (*this);

	mov	eax, esi
	pop	ebp

; 636  : 		}

	ret	8

; 631  : 			{	// make room and assign new stuff
; 632  : 			_Traits::assign(_Myptr(), _Count, _Ch);

$L26182:
	lea	edi, DWORD PTR [esi+4]
$L26183:
	movsx	eax, BYTE PTR __Ch$[esp+8]
	mov	bl, al
	mov	bh, bl
	mov	ecx, ebp
	mov	edx, ecx
	shr	ecx, 2
	mov	eax, ebx
	shl	eax, 16					; 00000010H
	mov	ax, bx
	rep stosd
	mov	ecx, edx
	and	ecx, 3
	rep stosb

; 633  : 			_Eos(_Count);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	pop	edi
	mov	DWORD PTR [esi+20], ebp
	pop	ebx
	jb	SHORT $L26205
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+ebp], 0

; 634  : 			}
; 635  : 		return (*this);

	mov	eax, esi
	pop	ebp

; 636  : 		}

	ret	8

; 633  : 			_Eos(_Count);

$L26205:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+ebp], 0
$L26211:

; 634  : 			}
; 635  : 		return (*this);

	mov	eax, esi
	pop	ebp

; 636  : 		}

	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx
; __Newsize$ = eax

; 1120 : 		resize(_Newsize, _Elem());

	mov	edx, DWORD PTR [ecx+20]
	cmp	eax, edx
	ja	SHORT $L26218
	push	-1
	push	eax
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1121 : 		}

	ret	0

; 1120 : 		resize(_Newsize, _Elem());

$L26218:
	push	esi
	push	0
	sub	eax, edx
	mov	esi, ecx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1121 : 		}

	ret	0
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = eax
; __Count$ = ecx

; 374  : 		{	// construct from _Count * _Ch

	push	esi
	mov	esi, eax

; 375  : 		_Tidy();

	xor	eax, eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+4], al

; 376  : 		assign(_Count, _Ch);

	mov	eax, DWORD PTR __Ch$[esp]
	push	eax
	push	ecx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 377  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T26626	DD	0ffffffffH
	DD	FLAT:$L26291
$T26619	DD	019930520H
	DD	01H
	DD	FLAT:$T26626
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
_TEXT	SEGMENT
_c$12391 = -48						; size = 1
$T26293 = -48						; size = 4
_normalized$ = -44					; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z PROC NEAR ; Json::StyledWriter::normalizeEOL, COMDAT
; _text$ = ecx

; 456  : {

	push	-1
	push	__ehhandler$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	push	ebx
	push	ebp

; 457  :    std::string normalized;
; 458  :    normalized.reserve( text.length() );

	xor	ebx, ebx
	push	esi
	mov	DWORD PTR __$ArrayPad$[esp+60], eax
	push	edi
	mov	esi, ecx
	mov	DWORD PTR $T26293[esp+64], ebx
	mov	DWORD PTR _normalized$[esp+88], 15	; 0000000fH
	mov	DWORD PTR _normalized$[esp+84], ebx
	mov	BYTE PTR _normalized$[esp+68], bl
	mov	DWORD PTR __$EHRec$[esp+72], ebx
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 15					; 0000000fH
	je	SHORT $L26622
	push	1
	push	eax
	lea	ecx, DWORD PTR _normalized$[esp+72]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $L26622
	cmp	DWORD PTR _normalized$[esp+88], 16	; 00000010H
	mov	eax, DWORD PTR _normalized$[esp+68]
	mov	DWORD PTR _normalized$[esp+84], ebx
	jae	SHORT $L26424
	lea	eax, DWORD PTR _normalized$[esp+68]
$L26424:
	mov	BYTE PTR [eax], bl
$L26622:

; 459  :    const char *begin = text.c_str();

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L26440
	mov	edi, DWORD PTR [esi+4]
	jmp	SHORT $L26441
$L26440:
	lea	edi, DWORD PTR [esi+4]
$L26441:

; 460  :    const char *end = begin + text.length();

	mov	ebp, DWORD PTR [esi+20]
	add	ebp, edi

; 461  :    const char *current = begin;
; 462  :    while ( current != end )

	cmp	edi, ebp
	je	SHORT $L12390
$L12389:

; 463  :    {
; 464  :       char c = *current++;

	mov	al, BYTE PTR [edi]
	inc	edi

; 465  :       if ( c == '\r' ) // mac or dos EOL

	cmp	al, 13					; 0000000dH
	mov	BYTE PTR _c$12391[esp+64], al
	jne	SHORT $L12392

; 466  :       {
; 467  :          if ( *current == '\n' ) // convert dos EOL

	cmp	BYTE PTR [edi], 10			; 0000000aH
	jne	SHORT $L12393

; 468  :             ++current;

	inc	edi
$L12393:

; 469  :          normalized += '\n';

	push	10					; 0000000aH

; 470  :       }
; 471  :       else // handle unix EOL & other char

	jmp	SHORT $L26625
$L12392:

; 472  :          normalized += c;

	mov	eax, DWORD PTR _c$12391[esp+64]
	push	eax
$L26625:
	lea	esi, DWORD PTR _normalized$[esp+68]
	mov	eax, 1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	cmp	edi, ebp
	jne	SHORT $L12389
$L12390:

; 473  :    }
; 474  :    return normalized;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+60]
	push	-1
	push	ebx
	lea	ecx, DWORD PTR _normalized$[esp+72]
	push	ecx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR _normalized$[esp+88], 16	; 00000010H
	jb	SHORT $L26621
	mov	edx, DWORD PTR _normalized$[esp+68]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L26621:

; 475  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+64]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+52]
	pop	ebx
	call	@__security_check_cookie@4
	add	esp, 48					; 00000030H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L26291:
	lea	ecx, DWORD PTR _normalized$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z:
	mov	eax, OFFSET FLAT:$T26619
	jmp	___CxxFrameHandler
text$x	ENDS
?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ENDP ; Json::StyledWriter::normalizeEOL
PUBLIC	?unindent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::unindent
; Function compile flags: /Ogtpy
;	COMDAT ?unindent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?unindent@StyledWriter@Json@@AAEXXZ PROC NEAR		; Json::StyledWriter::unindent, COMDAT
; _this$ = ecx

; 415  :    assert( int(indentString_.size()) >= indentSize_ );
; 416  :    indentString_.resize( indentString_.size() - indentSize_ );

	mov	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [ecx+32]
	add	ecx, 12					; 0000000cH
	sub	eax, edx
	mov	edx, DWORD PTR [ecx+20]
	cmp	eax, edx
	ja	SHORT $L26645
	push	-1
	push	eax
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 417  : }

	ret	0

; 415  :    assert( int(indentString_.size()) >= indentSize_ );
; 416  :    indentString_.resize( indentString_.size() - indentSize_ );

$L26645:
	push	esi
	push	0
	sub	eax, edx
	mov	esi, ecx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 417  : }

	ret	0
?unindent@StyledWriter@Json@@AAEXXZ ENDP		; Json::StyledWriter::unindent
_TEXT	ENDS
PUBLIC	?writeIndent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::writeIndent
; Function compile flags: /Ogtpy
;	COMDAT ?writeIndent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
$T26653 = -4						; size = 4
?writeIndent@StyledWriter@Json@@AAEXXZ PROC NEAR	; Json::StyledWriter::writeIndent, COMDAT
; _this$ = eax

; 384  : {

	push	ecx
	push	esi
	mov	esi, eax

; 385  :    if ( !document_.empty() )

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L12254

; 386  :    {
; 387  :       char last = document_[document_.length()-1];

	mov	ecx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [ecx+eax-1]

; 388  :       if ( last == ' ' )     // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $L12250

; 389  :          return;
; 390  :       if ( last != '\n' )    // Comments may add new-line

	cmp	al, 10					; 0000000aH
	je	SHORT $L12254

; 391  :          document_ += '\n';

	push	10					; 0000000aH
	call	??YfastDocument@Json@@QAEXD@Z		; Json::fastDocument::operator+=
$L12254:

; 392  :    }
; 393  :    document_ += indentString_;

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T26653[esp+36], esp
	push	-1
	push	0
	lea	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], 0
	push	edx
	mov	BYTE PTR [ecx+4], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	call	??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::fastDocument::operator+=
$L12250:

; 394  : }

	pop	esi
	pop	ecx
	ret	0
?writeIndent@StyledWriter@Json@@AAEXXZ ENDP		; Json::StyledWriter::writeIndent
PUBLIC	?indent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::indent
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T29337	DD	0ffffffffH
	DD	FLAT:$L29157
$T29335	DD	019930520H
	DD	01H
	DD	FLAT:$T29337
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?indent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
$T29156 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?indent@StyledWriter@Json@@AAEXXZ PROC NEAR		; Json::StyledWriter::indent, COMDAT
; _this$ = edi

; 407  : {

	push	-1
	push	__ehhandler$?indent@StyledWriter@Json@@AAEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 28					; 0000001cH

; 408  :    indentString_ += std::string( indentSize_, ' ' );

	mov	eax, DWORD PTR [edi+44]
	push	ebx
	push	esi
	push	32					; 00000020H
	xor	ebx, ebx
	push	eax
	lea	esi, DWORD PTR $T29156[esp+56]
	mov	DWORD PTR $T29156[esp+80], 15		; 0000000fH
	mov	DWORD PTR $T29156[esp+76], ebx
	mov	BYTE PTR $T29156[esp+60], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	DWORD PTR __$EHRec$[esp+56], ebx
	push	ebx
	lea	ebx, DWORD PTR [edi+12]
	or	eax, -1
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	cmp	DWORD PTR $T29156[esp+72], 16		; 00000010H
	pop	esi
	pop	ebx
	jb	SHORT $L29324
	mov	eax, DWORD PTR $T29156[esp+44]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L29324:

; 409  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 40					; 00000028H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L29157:
	lea	ecx, DWORD PTR $T29156[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?indent@StyledWriter@Json@@AAEXXZ:
	mov	eax, OFFSET FLAT:$T29335
	jmp	___CxxFrameHandler
text$x	ENDS
?indent@StyledWriter@Json@@AAEXXZ ENDP			; Json::StyledWriter::indent
PUBLIC	?writeWithIndent@StyledWriter@Json@@AAEXPBD@Z	; Json::StyledWriter::writeWithIndent
; Function compile flags: /Ogtpy
;	COMDAT ?writeWithIndent@StyledWriter@Json@@AAEXPBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?writeWithIndent@StyledWriter@Json@@AAEXPBD@Z PROC NEAR	; Json::StyledWriter::writeWithIndent, COMDAT
; _this$ = eax

; 399  : {

	push	esi
	mov	esi, eax

; 400  :    writeIndent();

	call	?writeIndent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::writeIndent

; 401  :    document_ += value;

	mov	eax, DWORD PTR _value$[esp]
	push	eax
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	pop	esi

; 402  : }

	ret	4
?writeWithIndent@StyledWriter@Json@@AAEXPBD@Z ENDP	; Json::StyledWriter::writeWithIndent
PUBLIC	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T42129	DD	0ffffffffH
	DD	FLAT:$L41886
	DD	00H
	DD	FLAT:$L41887
	DD	0ffffffffH
	DD	FLAT:$L41889
$T42125	DD	019930520H
	DD	03H
	DD	FLAT:$T42129
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T41883 = -96						; size = 28
$T41885 = -68						; size = 28
$T41882 = -40						; size = 28
__$EHRec$ = -12						; size = 12
$T41884 = 8						; size = 4
$T41881 = 8						; size = 4
_this$ = 8						; size = 4
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z PROC NEAR ; Json::StyledWriter::writeCommentAfterValueOnSameLine, COMDAT
; _root$ = edi

; 432  : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp

; 433  :    if ( root.hasComment( commentAfterOnSameLine ) )

	mov	eax, DWORD PTR [edi+12]
	sub	esp, 84					; 00000054H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+100]
	xor	ebx, ebx
	cmp	eax, ebx
	push	esi
	je	$L42040
	cmp	DWORD PTR [eax+4], ebx
	je	$L42040

; 434  :       document_ += " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	mov	ecx, 1
	lea	esi, DWORD PTR $T41882[esp+108]
	mov	eax, edi
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	lea	ecx, DWORD PTR $T41883[esp+108]
	push	ecx
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+120], ebx
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	sub	esp, 24					; 00000018H
	mov	esi, esp
	mov	DWORD PTR $T41881[esp+132], esp
	push	eax
	mov	ecx, OFFSET FLAT:??_C@_01CLKCMJKC@?5?$AA@
	mov	BYTE PTR __$EHRec$[esp+148], 1
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 4
	mov	esi, ebp
	call	??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::fastDocument::operator+=
	mov	eax, DWORD PTR $T41883[esp+132]
	mov	esi, 16					; 00000010H
	cmp	eax, esi
	jb	SHORT $L41961
	mov	edx, DWORD PTR $T41883[esp+112]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L41961:
	mov	DWORD PTR __$EHRec$[esp+116], -1
	cmp	DWORD PTR $T41882[esp+132], esi
	mov	DWORD PTR $T41883[esp+132], 15		; 0000000fH
	mov	DWORD PTR $T41883[esp+128], ebx
	mov	BYTE PTR $T41883[esp+112], bl
	jb	SHORT $L42040
	mov	eax, DWORD PTR $T41882[esp+112]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L42040:

; 435  : 
; 436  :    if ( root.hasComment( commentAfter ) )

	mov	eax, DWORD PTR [edi+12]
	cmp	eax, ebx
	je	$L12372
	cmp	DWORD PTR [eax+8], ebx
	je	SHORT $L12372

; 437  :    {
; 438  :       document_ += "\n";

	push	OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	mov	esi, ebp
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 439  :       document_ += normalizeEOL( root.getComment( commentAfter ) );

	mov	ecx, 2
	lea	esi, DWORD PTR $T41885[esp+108]
	mov	eax, edi
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T41884[esp+132], esp
	push	ecx
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+148], 2
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	add	esp, 4
	mov	esi, ebp
	call	??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::fastDocument::operator+=
	mov	DWORD PTR __$EHRec$[esp+116], -1
	cmp	DWORD PTR $T41885[esp+132], 16		; 00000010H
	jb	SHORT $L42108
	mov	edx, DWORD PTR $T41885[esp+112]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L42108:

; 440  :       document_ += "\n";

	push	OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	mov	esi, ebp
	mov	DWORD PTR $T41885[esp+136], 15		; 0000000fH
	mov	DWORD PTR $T41885[esp+132], ebx
	mov	BYTE PTR $T41885[esp+116], bl
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
$L12372:

; 441  :    }
; 442  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+108]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	add	esp, 96					; 00000060H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L41886:
	lea	ecx, DWORD PTR $T41882[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L41887:
	lea	ecx, DWORD PTR $T41883[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L41889:
	lea	ecx, DWORD PTR $T41885[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	eax, OFFSET FLAT:$T42125
	jmp	___CxxFrameHandler
text$x	ENDS
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentAfterValueOnSameLine
PUBLIC	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T42223	DD	0ffffffffH
	DD	FLAT:$L42137
$T42220	DD	019930520H
	DD	01H
	DD	FLAT:$T42223
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T42136 = -40						; size = 28
__$EHRec$ = -12						; size = 12
$T42135 = 8						; size = 4
_root$ = 8						; size = 4
?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC NEAR ; Json::StyledWriter::writeCommentBeforeValue, COMDAT
; _this$ = edi

; 422  : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	push	eax
	mov	eax, DWORD PTR _root$[esp+8]
	mov	DWORD PTR fs:__except_list, esp

; 423  :    if ( !root.hasComment( commentBefore ) )

	mov	ecx, DWORD PTR [eax+12]
	sub	esp, 28					; 0000001cH
	test	ecx, ecx
	push	esi
	je	SHORT $L12350
	cmp	DWORD PTR [ecx], 0
	je	SHORT $L12350

; 424  :       return;
; 425  :    document_ += normalizeEOL( root.getComment( commentBefore ) );

	xor	ecx, ecx
	lea	esi, DWORD PTR $T42136[esp+44]
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T42135[esp+68], esp
	push	ecx
	mov	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+84], 0
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	add	esp, 4
	mov	esi, edi
	call	??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::fastDocument::operator+=
	mov	DWORD PTR __$EHRec$[esp+52], -1
	cmp	DWORD PTR $T42136[esp+68], 16		; 00000010H
	jb	SHORT $L42203
	mov	edx, DWORD PTR $T42136[esp+48]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L42203:

; 426  :    document_ += "\n";

	push	OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	mov	esi, edi
	mov	DWORD PTR $T42136[esp+72], 15		; 0000000fH
	mov	DWORD PTR $T42136[esp+68], 0
	mov	BYTE PTR $T42136[esp+52], 0
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
$L12350:

; 427  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 40					; 00000028H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L42137:
	lea	ecx, DWORD PTR $T42136[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	eax, OFFSET FLAT:$T42220
	jmp	___CxxFrameHandler
text$x	ENDS
?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentBeforeValue
PUBLIC	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
PUBLIC	?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeArrayValue
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T49443	DD	0ffffffffH
	DD	FLAT:$L48941
$T49437	DD	019930520H
	DD	01H
	DD	FLAT:$T49443
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T49113 = -32						; size = 4
_members$12208 = -28					; size = 16
__$EHRec$ = -12						; size = 12
$T49394 = 8						; size = 4
_value$ = 8						; size = 4
?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC NEAR ; Json::StyledWriter::writeValue, COMDAT
; _this$ = ecx

; 277  : {

	push	-1
	mov	eax, DWORD PTR fs:__except_list
	push	__ehhandler$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 20					; 00000014H
	push	ebx

; 278  :    switch ( value.type() )

	mov	ebx, DWORD PTR _value$[esp+32]
	movsx	eax, BYTE PTR [ebx+8]
	cmp	eax, 7
	push	ebp
	push	esi
	push	edi
	mov	esi, ecx
	ja	$L12196
	jmp	DWORD PTR $L49442[eax*4]
$L12199:

; 279  :    {
; 280  :    case nullValue:
; 281  :       document_ += "null";

	push	OFFSET FLAT:??_C@_04MLLLIHIP@null?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 332  :       break;
; 333  :    }
; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	4
$L12200:

; 282  :       break;
; 283  :    case intValue:
; 284  :       document_.append( value.asInt() );

	mov	eax, ebx
	call	?asInt@Value@Json@@QBEHXZ		; Json::Value::asInt
	push	eax
	push	esi
	call	?append@fastDocument@Json@@QAEXH@Z	; Json::fastDocument::append

; 332  :       break;
; 333  :    }
; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	4
$L12201:

; 285  :       break;
; 286  :    case uintValue:
; 287  :       document_.append( value.asUInt() );

	mov	eax, ebx
	call	?asUInt@Value@Json@@QBEIXZ		; Json::Value::asUInt
	push	eax
	push	esi
	call	?append@fastDocument@Json@@QAEXI@Z	; Json::fastDocument::append

; 332  :       break;
; 333  :    }
; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	4
$L12202:

; 288  :       break;
; 289  :    case realValue:
; 290  :       document_.append( value.asDouble() );

	mov	eax, ebx
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?append@fastDocument@Json@@QAEXN@Z	; Json::fastDocument::append

; 332  :       break;
; 333  :    }
; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	4
$L12203:

; 291  :       break;
; 292  :    case stringValue:
; 293  :       document_.appendQuoted( value.asCString() );

	mov	eax, DWORD PTR [ebx]
	push	eax
	mov	eax, esi
	call	?appendQuoted@fastDocument@Json@@QAEXPBD@Z ; Json::fastDocument::appendQuoted

; 332  :       break;
; 333  :    }
; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	4
$L12204:

; 294  :       break;
; 295  :    case booleanValue:
; 296  :       document_.append( value.asBool() );

	mov	eax, ebx
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	test	al, al
	mov	eax, OFFSET FLAT:??_C@_04LOAJBDKD@true?$AA@
	jne	SHORT $L48955
	mov	eax, OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
$L48955:
	push	eax
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 332  :       break;
; 333  :    }
; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	4
$L12205:

; 297  :       break;
; 298  :    case arrayValue:
; 299  :       writeArrayValue( value);

	push	ebx
	mov	ecx, esi
	call	?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeArrayValue

; 332  :       break;
; 333  :    }
; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 32					; 00000020H
	ret	4
$L12206:

; 300  :       break;
; 301  :    case objectValue:
; 302  :       {
; 303  :          Value::Members members( value.getMemberNames() );

	lea	ecx, DWORD PTR _members$12208[esp+48]
	push	ecx
	mov	ecx, ebx
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
	xor	edi, edi

; 304  :          if ( members.empty() )

	lea	ecx, DWORD PTR _members$12208[esp+48]
	mov	DWORD PTR __$EHRec$[esp+56], edi
	call	?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
	test	al, al
	je	SHORT $L12209

; 305  :             document_ += "{}";

	push	OFFSET FLAT:??_C@_02MCILKGOH@?$HL?$HN?$AA@

; 306  :          else

	jmp	$L49441
$L12209:

; 307  :          {
; 308  :             writeWithIndent( "{" );

	mov	eax, DWORD PTR [esi]
	cmp	eax, edi
	je	SHORT $L49153
	mov	edx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [edx+eax-1]
	cmp	al, 32					; 00000020H
	je	SHORT $L49149
	cmp	al, 10					; 0000000aH
	je	SHORT $L49153
	push	10					; 0000000aH
	call	??YfastDocument@Json@@QAEXD@Z		; Json::fastDocument::operator+=
$L49153:
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T49113[esp+76], esp
	push	-1
	push	edi
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], edi
	push	eax
	mov	BYTE PTR [ecx+4], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	call	??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::fastDocument::operator+=
$L49149:
	push	OFFSET FLAT:??_C@_01HCONENDN@?$HL?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 309  :             indent();

	mov	edi, esi
	call	?indent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::indent
	mov	ebp, DWORD PTR _members$12208[esp+52]
	add	ebp, 4
$L12216:

; 310  :             Value::Members::iterator it = members.begin();
; 311  :             while ( true )
; 312  :             {
; 313  :                const std::string &name = *it;
; 314  :                const Value &childValue = value[name];

	cmp	DWORD PTR [ebp+20], 16			; 00000010H
	jb	SHORT $L49197
	mov	eax, DWORD PTR [ebp]
	jmp	SHORT $L49198
$L49197:
	mov	eax, ebp
$L49198:
	push	eax
	push	ebx
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
	mov	ebx, eax

; 315  :                writeCommentBeforeValue( childValue );

	push	ebx
	mov	edi, esi
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 316  : 			   writeIndent();

	mov	eax, esi
	call	?writeIndent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::writeIndent

; 317  : 			   document_.appendQuoted( name.c_str() );

	cmp	DWORD PTR [ebp+20], 16			; 00000010H
	jb	SHORT $L49212
	mov	edi, DWORD PTR [ebp]
	jmp	SHORT $L49213
$L49212:
	mov	edi, ebp
$L49213:
	push	OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	push	edi
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	push	OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 318  :                document_ += " : ";

	push	OFFSET FLAT:??_C@_03MCPBMLDJ@?5?3?5?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 319  :                writeValue( childValue );

	push	ebx
	mov	ecx, esi
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 320  :                if ( ++it == members.end() )

	mov	eax, DWORD PTR _members$12208[esp+56]
	add	ebp, 28					; 0000001cH
	lea	ecx, DWORD PTR [ebp-4]
	cmp	ecx, eax
	je	SHORT $L49439

; 323  :                   break;
; 324  :                }
; 325  :                document_ += ",";

	push	OFFSET FLAT:??_C@_01IHBHIGKO@?0?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 326  :                writeCommentAfterValueOnSameLine( childValue );

	push	esi
	mov	edi, ebx
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 327  :             }

	mov	ebx, DWORD PTR _value$[esp+44]
	jmp	$L12216
$L49439:

; 321  :                {
; 322  :                   writeCommentAfterValueOnSameLine( childValue );

	push	esi
	mov	edi, ebx
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 328  :             unindent();

	mov	ecx, esi
	call	?unindent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::unindent

; 329  :             writeWithIndent( "}" );

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $L49434
	mov	edx, DWORD PTR [esi+4]
	mov	al, BYTE PTR [edx+eax-1]
	cmp	al, 32					; 00000020H
	je	SHORT $L49430
	cmp	al, 10					; 0000000aH
	je	SHORT $L49434
	push	10					; 0000000aH
	call	??YfastDocument@Json@@QAEXD@Z		; Json::fastDocument::operator+=
$L49434:
	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T49394[esp+72], esp
	push	-1
	push	0
	lea	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], 0
	push	eax
	mov	BYTE PTR [ecx+4], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	call	??YfastDocument@Json@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::fastDocument::operator+=
$L49430:
	push	OFFSET FLAT:??_C@_01CELHOKLL@?$HN?$AA@
$L49441:
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 330  :          }
; 331  :       }

	lea	esi, DWORD PTR _members$12208[esp+48]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$L12196:

; 332  :       break;
; 333  :    }
; 334  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	add	esp, 32					; 00000020H
	ret	4
	npad	2
$L49442:
	DD	$L12199
	DD	$L12200
	DD	$L12201
	DD	$L12202
	DD	$L12203
	DD	$L12204
	DD	$L12205
	DD	$L12206
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L48941:
	lea	esi, DWORD PTR _members$12208[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	eax, OFFSET FLAT:$T49437
	jmp	___CxxFrameHandler
text$x	ENDS
?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP	; Json::StyledWriter::writeValue
PUBLIC	?write@StyledWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::StyledWriter::write
; Function compile flags: /Ogtpy
;	COMDAT ?write@StyledWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
$T49450 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
?write@StyledWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z PROC NEAR ; Json::StyledWriter::write, COMDAT
; _this$ = eax

; 256  : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, eax

; 257  :    document_ = "";

	mov	eax, DWORD PTR [esi]
	xor	ebx, ebx
	cmp	eax, ebx
	mov	DWORD PTR $T49450[esp+8], ebx
	je	SHORT $L49463
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L49463:
	push	edi
	push	OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 258  :    addChildValues_ = false;
; 259  :    indentString_ = "";

	push	ebx
	push	OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR [esi+12]
	mov	BYTE PTR [esi+48], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 260  :    writeCommentBeforeValue( root );

	mov	eax, DWORD PTR _root$[esp+12]
	push	eax
	mov	edi, esi
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 261  :    writeValue( root );

	mov	edi, DWORD PTR _root$[esp+12]
	push	edi
	mov	ecx, esi
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 262  :    writeCommentAfterValueOnSameLine( root );

	push	esi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 263  :    document_ += "\n";

	push	OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 264  :    if(document_.getData())

	mov	esi, DWORD PTR [esi]
	cmp	esi, ebx

; 265  :    {
; 266  : 	   return std::string(document_.getData());

	mov	DWORD PTR [ebp+20], ebx
	mov	DWORD PTR [ebp+24], 15			; 0000000fH
	pop	edi
	mov	BYTE PTR [ebp+4], bl
	je	SHORT $L12187
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$L49686:
	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, bl
	jne	SHORT $L49686
	sub	eax, edx
	push	eax
	push	esi
	mov	ecx, ebp
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L12187:
	pop	esi

; 267  :    }
; 268  :    else
; 269  :    {
; 270  : 	   return std::string();

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 271  :    }
; 272  : }

	ret	8
?write@StyledWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ENDP ; Json::StyledWriter::write
_TEXT	ENDS
PUBLIC	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z	; Json::FastWriter::writeValue
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T49896	DD	0ffffffffH
	DD	FLAT:$L49692
$T49885	DD	019930520H
	DD	01H
	DD	FLAT:$T49896
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_writer.cpp
xdata$x	ENDS
;	COMDAT ?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_members$12050 = -28					; size = 16
__$EHRec$ = -12						; size = 12
__Cat$49880 = 8						; size = 1
_value$ = 8						; size = 4
?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z PROC NEAR ; Json::FastWriter::writeValue, COMDAT
; _this$ = ecx

; 188  : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	ebp

; 189  :    switch ( value.type() )

	mov	ebp, DWORD PTR _value$[esp+28]
	movsx	eax, BYTE PTR [ebp+8]
	cmp	eax, 7
	push	esi
	mov	esi, ecx
	ja	$L49882
	push	ebx
	push	edi
	jmp	DWORD PTR $L49895[eax*4]
$L11790:

; 190  :    {
; 191  :    case nullValue:
; 192  :       document_ += "null";

	push	OFFSET FLAT:??_C@_04MLLLIHIP@null?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 239  :       break;
; 240  :    }
; 241  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
$L11792:

; 193  :       break;
; 194  :    case intValue:
; 195  :       document_.append(value.asInt() );

	mov	eax, ebp
	call	?asInt@Value@Json@@QBEHXZ		; Json::Value::asInt
	push	eax
	push	esi
	call	?append@fastDocument@Json@@QAEXH@Z	; Json::fastDocument::append
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 239  :       break;
; 240  :    }
; 241  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
$L11793:

; 196  :       break;
; 197  :    case uintValue:
; 198  :       document_.append(value.asUInt() );

	mov	eax, ebp
	call	?asUInt@Value@Json@@QBEIXZ		; Json::Value::asUInt
	push	eax
	push	esi
	call	?append@fastDocument@Json@@QAEXI@Z	; Json::fastDocument::append
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 239  :       break;
; 240  :    }
; 241  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
$L11794:

; 199  :       break;
; 200  :    case realValue:
; 201  :       document_.append(value.asDouble() );

	mov	eax, ebp
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	fstp	QWORD PTR [esp]
	call	?append@fastDocument@Json@@QAEXN@Z	; Json::fastDocument::append
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 239  :       break;
; 240  :    }
; 241  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
$L11795:

; 202  :       break;
; 203  :    case stringValue:
; 204  : 	   document_.appendQuoted( value.asCString() );

	mov	eax, DWORD PTR [ebp]
	push	eax
	mov	eax, esi
	call	?appendQuoted@fastDocument@Json@@QAEXPBD@Z ; Json::fastDocument::appendQuoted
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 239  :       break;
; 240  :    }
; 241  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
$L11796:

; 205  :       break;
; 206  :    case booleanValue:
; 207  :       document_.append(value.asBool() );

	mov	eax, ebp
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	test	al, al
	mov	eax, OFFSET FLAT:??_C@_04LOAJBDKD@true?$AA@
	jne	SHORT $L49706
	mov	eax, OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
$L49706:
	push	eax
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 239  :       break;
; 240  :    }
; 241  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
$L11797:

; 208  :       break;
; 209  :    case arrayValue:
; 210  :       {
; 211  :          document_ += "[ ";

	push	OFFSET FLAT:??_C@_02PFNDMDBO@?$FL?5?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 212  :          int size = value.size();

	mov	ecx, ebp
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	ebx, eax

; 213  :          for ( int index =0; index < size; ++index )

	xor	edi, edi
	test	ebx, ebx
	jle	SHORT $L11803
	npad	5
$L49890:

; 214  :          {
; 215  :             if ( index > 0 )

	test	edi, edi
	jle	SHORT $L11804

; 216  :                document_ += ", ";

	push	OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
$L11804:

; 217  :             writeValue( value[index] );

	push	edi
	push	ebp
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, esi
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue
	inc	edi
	cmp	edi, ebx
	jl	SHORT $L49890
$L11803:

; 218  :          }
; 219  :          document_ += " ]";

	push	OFFSET FLAT:??_C@_02DHOGEDBE@?5?$FN?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	pop	edi
	pop	ebx
	pop	esi
	pop	ebp

; 239  :       break;
; 240  :    }
; 241  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
$L11807:

; 220  :       }
; 221  :       break;
; 222  :    case objectValue:
; 223  :       {
; 224  :          Value::Members members( value.getMemberNames() );

	lea	ecx, DWORD PTR _members$12050[esp+44]
	push	ecx
	mov	ecx, ebp
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames

; 225  :          document_ += "{ ";

	push	OFFSET FLAT:??_C@_02MNJOIFPO@?$HL?5?$AA@
	mov	DWORD PTR __$EHRec$[esp+56], 0
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 226  :          for ( Value::Members::iterator it = members.begin(); 
; 227  :                it != members.end(); 
; 228  :                ++it )

	mov	edi, DWORD PTR _members$12050[esp+48]
	cmp	edi, DWORD PTR _members$12050[esp+52]
	je	SHORT $L12173

; 220  :       }
; 221  :       break;
; 222  :    case objectValue:
; 223  :       {
; 224  :          Value::Members members( value.getMemberNames() );

	lea	ebx, DWORD PTR [edi+4]
	npad	4

; 226  :          for ( Value::Members::iterator it = members.begin(); 
; 227  :                it != members.end(); 
; 228  :                ++it )

$L49726:

; 229  :          {
; 230  :             const std::string &name = *it;
; 231  :             if ( it != members.begin() )

	lea	edx, DWORD PTR [ebx-4]
	cmp	edx, edi
	je	SHORT $L12176

; 232  :                document_ += ", ";

	push	OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
$L12176:

; 233  : 			document_.appendQuoted( name.c_str() );

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $L49795
	mov	edi, DWORD PTR [ebx]
	jmp	SHORT $L49796
$L49795:
	mov	edi, ebx
$L49796:
	push	OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	push	edi
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	push	OFFSET FLAT:??_C@_01BJJEKLCA@?$CC?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 234  :             document_ += " : ";

	push	OFFSET FLAT:??_C@_03MCPBMLDJ@?5?3?5?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 235  :             writeValue( value[name] );

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $L49822
	mov	eax, DWORD PTR [ebx]
	jmp	SHORT $L49823
$L49822:
	mov	eax, ebx
$L49823:
	push	eax
	push	ebp
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, esi
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue
	mov	ecx, DWORD PTR _members$12050[esp+52]
	mov	edi, DWORD PTR _members$12050[esp+48]
	add	ebx, 28					; 0000001cH
	lea	eax, DWORD PTR [ebx-4]
	cmp	eax, ecx
	jne	SHORT $L49726
$L12173:

; 236  :          }
; 237  :          document_ += " }";

	push	OFFSET FLAT:??_C@_02KCGCGHLG@?5?$HN?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 238  :       }

	test	edi, edi
	je	SHORT $L49893
	mov	ecx, DWORD PTR __Cat$49880[esp+40]
	mov	esi, DWORD PTR _members$12050[esp+48]
	mov	edi, DWORD PTR _members$12050[esp+52]
	push	ecx
	mov	eax, esi
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 8
$L49893:
	pop	edi
	pop	ebx
$L49882:

; 239  :       break;
; 240  :    }
; 241  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+36]
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	4
	npad	2
$L49895:
	DD	$L11790
	DD	$L11792
	DD	$L11793
	DD	$L11794
	DD	$L11795
	DD	$L11796
	DD	$L11797
	DD	$L11807
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L49692:
	lea	esi, DWORD PTR _members$12050[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__ehhandler$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z:
	mov	eax, OFFSET FLAT:$T49885
	jmp	___CxxFrameHandler
text$x	ENDS
?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ENDP	; Json::FastWriter::writeValue
PUBLIC	?write@FastWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::FastWriter::write
; Function compile flags: /Ogtpy
;	COMDAT ?write@FastWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
$T49903 = -4						; size = 4
_root$ = 8						; size = 4
?write@FastWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z PROC NEAR ; Json::FastWriter::write, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = edi

; 171  : {

	push	ecx
	push	ebx
	push	esi
	mov	esi, eax

; 172  :    document_ = "";

	mov	eax, DWORD PTR [esi]
	xor	ebx, ebx
	cmp	eax, ebx
	mov	DWORD PTR $T49903[esp+12], ebx
	je	SHORT $L49915
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L49915:
	push	OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 173  :    writeValue( root );

	mov	eax, DWORD PTR _root$[esp+8]
	push	eax
	mov	ecx, esi
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue

; 174  :    document_ += "\n";

	push	OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 175  :    if(document_.getData())

	mov	esi, DWORD PTR [esi]
	cmp	esi, ebx

; 176  :    {
; 177  : 	   return std::string(document_.getData());

	mov	DWORD PTR [edi+20], ebx
	mov	DWORD PTR [edi+24], 15			; 0000000fH
	mov	BYTE PTR [edi+4], bl
	je	SHORT $L11778
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$L50124:
	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, bl
	jne	SHORT $L50124
	sub	eax, edx
	push	eax
	push	esi
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L11778:
	pop	esi

; 178  :    }
; 179  :    else
; 180  :    {
; 181  : 	   return std::string();

	mov	eax, edi
	pop	ebx

; 182  :    }
; 183  : }

	pop	ecx
	ret	4
?write@FastWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ENDP ; Json::FastWriter::write
; Function compile flags: /Ogtpy
;	COMDAT ?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_index$12235 = -8					; size = 4
_size$ = -4						; size = 4
_value$ = 8						; size = 4
?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC NEAR ; Json::StyledWriter::writeArrayValue, COMDAT
; _this$ = ecx

; 339  : {

	sub	esp, 8
	push	ebx
	push	ebp
	push	esi

; 340  :    int size = value.size();

	mov	esi, DWORD PTR _value$[esp+16]
	mov	ebx, ecx
	mov	ecx, esi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	ebp, eax

; 341  :    if ( size == 0 )

	test	ebp, ebp
	mov	DWORD PTR _size$[esp+20], ebp
	jne	SHORT $L12229

; 342  :       document_.append( "[]" );

	push	OFFSET FLAT:??_C@_02GPECMEKF@?$FL?$FN?$AA@
	mov	esi, ebx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	pop	esi
	pop	ebp
	pop	ebx

; 378  :       }
; 379  :    }
; 380  : }

	add	esp, 8
	ret	4
$L12229:
	push	edi

; 343  :    else
; 344  :    {
; 345  :       bool isArrayMultiLine = (value.size() >= 6);

	mov	ecx, esi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	cmp	eax, 6

; 346  :       if ( isArrayMultiLine )

	jb	$L12233

; 347  :       {
; 348  :          writeWithIndent( "[" );

	mov	eax, ebx
	call	?writeIndent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::writeIndent
	push	OFFSET FLAT:??_C@_01OHGJGJJP@?$FL?$AA@
	mov	esi, ebx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 349  :          indent();

	mov	edi, ebx
	call	?indent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::indent

; 350  :          int index =0;
; 351  :          while ( true )
; 352  :          {
; 353  :             const Value &childValue = value[index];

	mov	eax, DWORD PTR _value$[esp+20]
	push	0
	push	eax
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	ebp, eax

; 354  :             writeCommentBeforeValue( childValue );

	push	ebp
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 355  :             writeIndent();

	mov	eax, ebx
	call	?writeIndent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::writeIndent

; 356  :             writeValue( childValue );

	push	ebp
	mov	ecx, ebx
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 357  :             if ( ++index == size )

	mov	ecx, DWORD PTR _size$[esp+24]
	mov	eax, 1
	cmp	ecx, eax
	mov	DWORD PTR _index$12235[esp+24], eax
	je	SHORT $L50479
$L12237:

; 360  :                break;
; 361  :             }
; 362  :             document_ += ",";

	push	OFFSET FLAT:??_C@_01IHBHIGKO@?0?$AA@
	mov	esi, ebx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 363  :             writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	mov	edi, ebp
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
	mov	esi, DWORD PTR _index$12235[esp+24]
	mov	ecx, DWORD PTR _value$[esp+20]
	push	esi
	push	ecx
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	ebp, eax
	push	ebp
	mov	edi, ebx
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
	mov	eax, ebx
	call	?writeIndent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::writeIndent
	push	ebp
	mov	ecx, ebx
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
	mov	eax, DWORD PTR _size$[esp+24]
	inc	esi
	cmp	esi, eax
	mov	DWORD PTR _index$12235[esp+24], esi
	jne	SHORT $L12237
$L50479:

; 358  :             {
; 359  :                writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	mov	edi, ebp
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 364  :          }
; 365  :          unindent();

	mov	eax, DWORD PTR [ebx+32]
	mov	edi, DWORD PTR [ebx+44]
	mov	edx, DWORD PTR [ebx+32]
	lea	ecx, DWORD PTR [ebx+12]
	sub	eax, edi
	cmp	eax, edx
	ja	SHORT $L50472
	push	-1
	push	eax
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 366  :          writeWithIndent( "]" );

	mov	eax, ebx
	call	?writeIndent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::writeIndent
	push	OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN?$AA@

; 376  :          }
; 377  :          document_ += " ]";

	mov	esi, ebx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 378  :       }
; 379  :    }
; 380  : }

	add	esp, 8
	ret	4

; 364  :          }
; 365  :          unindent();

$L50472:
	push	0
	sub	eax, edx
	mov	esi, ecx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 366  :          writeWithIndent( "]" );

	mov	eax, ebx
	call	?writeIndent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::writeIndent
	push	OFFSET FLAT:??_C@_01LBDDMOBJ@?$FN?$AA@

; 376  :          }
; 377  :          document_ += " ]";

	mov	esi, ebx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 378  :       }
; 379  :    }
; 380  : }

	add	esp, 8
	ret	4
$L12233:

; 367  :       }
; 368  :       else // output on a single line
; 369  :       {
; 370  :          document_ += "[ ";

	push	OFFSET FLAT:??_C@_02PFNDMDBO@?$FL?5?$AA@
	mov	esi, ebx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=

; 371  :          for ( int index =0; index < size; ++index )

	xor	edi, edi
	test	ebp, ebp
	jle	SHORT $L12246
$L50482:

; 372  :          {
; 373  :             if ( index > 0 )

	test	edi, edi
	jle	SHORT $L12247

; 374  :                document_ += ", ";

	push	OFFSET FLAT:??_C@_02KEGNLNML@?0?5?$AA@
	mov	esi, ebx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
$L12247:

; 375  : 			writeValue( value[index] );

	mov	edx, DWORD PTR _value$[esp+20]
	push	edi
	push	edx
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, ebx
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
	inc	edi
	cmp	edi, ebp
	jl	SHORT $L50482
$L12246:

; 376  :          }
; 377  :          document_ += " ]";

	push	OFFSET FLAT:??_C@_02DHOGEDBE@?5?$FN?$AA@
	mov	esi, ebx
	call	??YfastDocument@Json@@QAEXPBD@Z		; Json::fastDocument::operator+=
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 378  :       }
; 379  :    }
; 380  : }

	add	esp, 8
	ret	4
?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeArrayValue
END
