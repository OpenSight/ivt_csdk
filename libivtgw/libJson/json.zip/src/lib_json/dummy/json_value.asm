PUBLIC	??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::out_of_range::out_of_range
PUBLIC	??1out_of_range@std@@UAE@XZ			; std::out_of_range::~out_of_range
PUBLIC	??_Gout_of_range@std@@UAEPAXI@Z			; std::out_of_range::`scalar deleting destructor'
PUBLIC	??0StaticString@Json@@QAE@PBD@Z			; Json::StaticString::StaticString
PUBLIC	??BStaticString@Json@@QBEPBDXZ			; Json::StaticString::operator char const *
PUBLIC	?c_str@StaticString@Json@@QBEPBDXZ		; Json::StaticString::c_str
PUBLIC	??1PathArgument@Json@@QAE@XZ			; Json::PathArgument::~PathArgument
PUBLIC	??_GValueAllocator@Json@@UAEPAXI@Z		; Json::ValueAllocator::`scalar deleting destructor'
PUBLIC	??1DefaultValueAllocator@Json@@UAE@XZ		; Json::DefaultValueAllocator::~DefaultValueAllocator
PUBLIC	?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z ; Json::DefaultValueAllocator::makeMemberName
PUBLIC	?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z ; Json::DefaultValueAllocator::releaseMemberName
PUBLIC	?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z ; Json::DefaultValueAllocator::duplicateStringValue
PUBLIC	?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z ; Json::DefaultValueAllocator::releaseStringValue
PUBLIC	??_GDefaultValueAllocator@Json@@UAEPAXI@Z	; Json::DefaultValueAllocator::`scalar deleting destructor'
PUBLIC	??0DefaultValueAllocator@Json@@QAE@XZ		; Json::DefaultValueAllocator::DefaultValueAllocator
PUBLIC	??0ValueAllocator@Json@@QAE@XZ			; Json::ValueAllocator::ValueAllocator
PUBLIC	??0DummyValueAllocatorInitializer@Json@@QAE@XZ	; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer
PUBLIC	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::`scalar deleting destructor'
PUBLIC	??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ ; std::pair<Json::Value::CZString const ,Json::Value>::~pair<Json::Value::CZString const ,Json::Value>
PUBLIC	??1StyledWriter@Json@@QAE@XZ			; Json::StyledWriter::~StyledWriter
PUBLIC	??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
PUBLIC	?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
PUBLIC	?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back
PUBLIC	??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
PUBLIC	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
PUBLIC	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
PUBLIC	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
PUBLIC	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
PUBLIC	?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
PUBLIC	?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
PUBLIC	?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
PUBLIC	??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
PUBLIC	??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator->
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
PUBLIC	??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator--
PUBLIC	??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
PUBLIC	??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++
PUBLIC	??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator--
PUBLIC	??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
PUBLIC	??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
PUBLIC	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	??Dconst_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::operator*
PUBLIC	??8const_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::operator==
PUBLIC	??Dconst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator*
PUBLIC	??Econst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV012@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator++
PUBLIC	??9const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator!=
PUBLIC	?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity
PUBLIC	?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
PUBLIC	?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
PUBLIC	?insert@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::insert
PUBLIC	?_Buy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE_NI@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Buy
PUBLIC	?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy
PUBLIC	?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ufill
PUBLIC	??0?$_Vector_val@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE@V?$allocator@PBVPathArgument@Json@@@1@@Z ; std::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
PUBLIC	?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
PUBLIC	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
PUBLIC	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
PUBLIC	?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::insert
PUBLIC	?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy
PUBLIC	?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy
PUBLIC	?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ufill
PUBLIC	??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ	; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
PUBLIC	?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
PUBLIC	?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
PUBLIC	?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
PUBLIC	?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Myval
PUBLIC	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	?get_allocator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::get_allocator
PUBLIC	?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp
PUBLIC	?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
PUBLIC	?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase
PUBLIC	?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Init
PUBLIC	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
PUBLIC	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
PUBLIC	?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
PUBLIC	?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy
PUBLIC	??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
PUBLIC	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ; std::less<Json::Value::CZString>::operator()
PUBLIC	??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator
PUBLIC	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec
PUBLIC	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc
PUBLIC	?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
PUBLIC	?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
PUBLIC	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
PUBLIC	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
PUBLIC	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
PUBLIC	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AVconst_iterator@12@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
PUBLIC	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
PUBLIC	?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
PUBLIC	?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
PUBLIC	?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
PUBLIC	?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
PUBLIC	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
PUBLIC	?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
PUBLIC	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
PUBLIC	??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
PUBLIC	?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
PUBLIC	??0const_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::const_iterator
PUBLIC	??0const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::const_iterator
PUBLIC	??8const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator==
PUBLIC	?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
PUBLIC	?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
PUBLIC	?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy
PUBLIC	?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n
PUBLIC	?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen
PUBLIC	??0?$allocator@PBVPathArgument@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
PUBLIC	?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::deallocate
PUBLIC	?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument const *>::allocate
PUBLIC	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
PUBLIC	?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
PUBLIC	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy
PUBLIC	?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Insert_n
PUBLIC	?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
PUBLIC	??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
PUBLIC	?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::deallocate
PUBLIC	?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::allocate
PUBLIC	?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
PUBLIC	?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
PUBLIC	?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
PUBLIC	?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
PUBLIC	?upper_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::upper_bound
PUBLIC	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate
PUBLIC	?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Max
PUBLIC	?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Min
PUBLIC	?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
PUBLIC	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
PUBLIC	??0?$_Tree_ptr@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate
PUBLIC	?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::destroy
PUBLIC	?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy
PUBLIC	??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
PUBLIC	??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator
PUBLIC	?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
PUBLIC	?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
PUBLIC	??0iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::iterator
PUBLIC	??Hiterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV012@H@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::operator+
PUBLIC	??Giterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::operator-
PUBLIC	??0iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::iterator
PUBLIC	??Hiterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV012@H@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::operator+
PUBLIC	??Giterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::operator-
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>
PUBLIC	??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
PUBLIC	??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator
PUBLIC	??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
PUBLIC	??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+
PUBLIC	??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator-
PUBLIC	??0PathArgument@Json@@QAE@ABV01@@Z		; Json::PathArgument::PathArgument
PUBLIC	??0out_of_range@std@@QAE@ABV01@@Z		; std::out_of_range::out_of_range
PUBLIC	?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument const *>::max_size
PUBLIC	?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument>::max_size
PUBLIC	?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound
PUBLIC	??0?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	?max_size@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QBEIXZ ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::max_size
PUBLIC	?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocate
PUBLIC	?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::construct
PUBLIC	??Gconst_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV012@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::operator-
PUBLIC	??Gconst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV012@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator-
PUBLIC	??Yiterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV012@H@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::operator+=
PUBLIC	??Yiterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV012@H@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::operator+=
PUBLIC	??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator-
PUBLIC	??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+=
PUBLIC	??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::_Node
PUBLIC	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
PUBLIC	??0?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@QAE@U?$less@VCZString@Value@Json@@@1@@Z ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>
PUBLIC	??$distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAHViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::distance<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
PUBLIC	??$swap@PBD@std@@YAXAAPBD0@Z			; std::swap<char const *>
PUBLIC	??$swap@H@std@@YAXAAH0@Z			; std::swap<int>
PUBLIC	??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z ; std::swap<Json::Value::ValueHolder>
PUBLIC	??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
PUBLIC	??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAI@Z ; std::_Distance<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
PUBLIC	??$_Ucopy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@Vconst_iterator@01@0PAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator>
PUBLIC	??$_Ucopy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@Viterator@01@0PAV21@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator>
PUBLIC	??$_Uninitialized_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@@Z ; std::_Uninitialized_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	??$_Uninitialized_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@@Z ; std::_Uninitialized_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@@Z ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	??$_Ucopy@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ucopy<Json::PathArgument const * *>
PUBLIC	??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z ; std::fill<Json::PathArgument const * *,Json::PathArgument const *>
PUBLIC	??$copy_backward@PAPBVPathArgument@Json@@PAPBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00@Z ; std::copy_backward<Json::PathArgument const * *,Json::PathArgument const * *>
PUBLIC	??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z ; std::_Allocate<Json::PathArgument const *>
PUBLIC	??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<Json::PathArgument *>
PUBLIC	??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z ; std::fill<Json::PathArgument *,Json::PathArgument>
PUBLIC	??$copy_backward@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00@Z ; std::copy_backward<Json::PathArgument *,Json::PathArgument *>
PUBLIC	??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ; std::_Allocate<Json::PathArgument>
PUBLIC	??$swap@D@std@@YAXAAD0@Z			; std::swap<char>
PUBLIC	??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *><std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>
PUBLIC	??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>
PUBLIC	??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node><std::pair<Json::Value::CZString const ,Json::Value> >
PUBLIC	??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@IPAU120@@Z ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>
PUBLIC	??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>
PUBLIC	??4PathArgument@Json@@QAEAAV01@ABV01@@Z		; Json::PathArgument::operator=
PUBLIC	??_G_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAXI@Z ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::`scalar deleting destructor'
PUBLIC	??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::~_Node
PUBLIC	?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
PUBLIC	?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
PUBLIC	?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
PUBLIC	??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
PUBLIC	??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@H@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAHUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,int>
PUBLIC	??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z ; std::lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
PUBLIC	??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z ; std::equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
PUBLIC	??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
PUBLIC	??$_Uninitialized_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninitialized_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Ptr_cat@$$CBVPathArgument@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument const >
PUBLIC	??$_Uninit_fill_n@PBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument const *,unsigned int,Json::PathArgument const *>
PUBLIC	??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
PUBLIC	??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
PUBLIC	??$_Uninitialized_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@@Z ; std::_Uninitialized_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
PUBLIC	??$_Copy_backward_opt@PAPBVPathArgument@Json@@PAPBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *>
PUBLIC	??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??$_Uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@@Z ; std::_Uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
PUBLIC	??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *>
PUBLIC	??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ; std::allocator<Json::PathArgument>::construct
PUBLIC	?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy
PUBLIC	?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
PUBLIC	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
PUBLIC	??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator<<Json::Value::CZString const ,Json::Value>
PUBLIC	??$mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z ; std::mismatch<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
PUBLIC	??$_Ptr_cat@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Ptr_cat<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Uninit_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Ptr_cat@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Ptr_cat<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
PUBLIC	??$_Uninit_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@@Z ; std::fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
PUBLIC	??$_Uninit_copy@PBVPathArgument@Json@@PBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument const *,Json::PathArgument const *>
PUBLIC	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
PUBLIC	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
PUBLIC	??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z ; std::_Construct<Json::PathArgument,Json::PathArgument>
PUBLIC	??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z ; std::_Destroy<Json::PathArgument>
PUBLIC	??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??_GPathArgument@Json@@QAEPAXI@Z		; Json::PathArgument::`scalar deleting destructor'
PUBLIC	??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator*
PUBLIC	??Econst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator++
PUBLIC	??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator!=
PUBLIC	??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*
PUBLIC	??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++
PUBLIC	??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
PUBLIC	??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator==
PUBLIC	??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator==<Json::Value::CZString const ,Json::Value>
EXTRN	__purecall:NEAR
EXTRN	??_V@YAXPAX@Z:NEAR				; operator delete[]
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:NEAR			; `eh vector constructor iterator'
EXTRN	_atexit:NEAR
EXTRN	??_EValueAllocator@Json@@UAEPAXI@Z:NEAR		; Json::ValueAllocator::`vector deleting destructor'
EXTRN	??_EDefaultValueAllocator@Json@@UAEPAXI@Z:NEAR	; Json::DefaultValueAllocator::`vector deleting destructor'
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
EXTRN	_strchr:NEAR
EXTRN	_malloc:NEAR
EXTRN	_free:NEAR
EXTRN	??_U@YAPAXI@Z:NEAR				; operator new[]
EXTRN	??_Eout_of_range@std@@UAEPAXI@Z:NEAR		; std::out_of_range::`vector deleting destructor'
; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\json_value.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02GLFAOOJA@?$FL?4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0StaticString@Json@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??BStaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@StaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1PathArgument@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E1
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT _$E2
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??1ValueAllocator@Json@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GValueAllocator@Json@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1DefaultValueAllocator@Json@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GDefaultValueAllocator@Json@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E5
text$yd	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yd	ENDS
;	COMDAT ??0DefaultValueAllocator@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ValueAllocator@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E6
text$yc	SEGMENT PARA USE32 PUBLIC 'CODE'
text$yc	ENDS
;	COMDAT ??0DummyValueAllocatorInitializer@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ValueIteratorBase@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?increment@ValueIteratorBase@Json@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?decrement@ValueIteratorBase@Json@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@ValueIteratorBase@Json@@IAEXABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?index@ValueIteratorBase@Json@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?memberName@ValueIteratorBase@Json@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ValueConstIterator@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ValueIterator@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ValueIterator@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4ValueIterator@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CommentInfo@Value@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CommentInfo@Value@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setComment@CommentInfo@Value@Json@@QAEXPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CZString@Value@Json@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0CZString@Value@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CZString@Value@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?swap@CZString@Value@Json@@AAEXAAV123@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4CZString@Value@Json@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??MCZString@Value@Json@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8CZString@Value@Json@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?index@CZString@Value@Json@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@CZString@Value@Json@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isStaticString@CZString@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Value@Json@@QAE@W4ValueType@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Value@Json@@QAE@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Value@Json@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Value@Json@@QAE@N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Value@Json@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Value@Json@@QAE@ABVStaticString@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Value@Json@@QAE@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Value@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_ECommentInfo@Value@Json@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1Value@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4Value@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?swap@Value@Json@@QAEXAAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?type@Value@Json@@QBE?AW4ValueType@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?compare@Value@Json@@QAEHABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??MValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??NValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??PValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??OValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8Value@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9Value@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?asCString@Value@Json@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?asInt@Value@Json@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?asUInt@Value@Json@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?asDouble@Value@Json@@QBENXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?asBool@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@Value@Json@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@Value@Json@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resize@Value@Json@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AValue@Json@@QAEAAV01@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AValue@Json@@QBEABV01@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AValue@Json@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get@Value@Json@@QBE?AV12@IABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isValidIndex@Value@Json@@QBE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AValue@Json@@QBEABV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@Value@Json@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get@Value@Json@@QBE?AV12@PBDABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isMember@Value@Json@@QBE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isBool@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isInt@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isUInt@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isIntegral@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isDouble@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isNumeric@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isString@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isArray@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isObject@Value@Json@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1StyledWriter@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@Value@Json@@QBE?AVValueConstIterator@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@Value@Json@@QAE?AVValueIterator@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@Value@Json@@QAE?AVValueIterator@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PathArgument@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PathArgument@Json@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PathArgument@Json@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAVconst_iterator@54@W4Kind@PathArgument@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?make@Path@Json@@QBEAAVValue@2@AAV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABQBVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE@V?$allocator@PBVPathArgument@Json@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PBVPathArgument@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0PathArgument@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@QAE@U?$less@VCZString@Value@Json@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAHViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$swap@PBD@std@@YAXAAPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$swap@H@std@@YAXAAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@Vconst_iterator@01@0PAV21@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@Viterator@01@0PAV21@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPBVPathArgument@Json@@PAPBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4PathArgument@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@H@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAHUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@$$CBVPathArgument@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPBVPathArgument@Json@@PAPBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBVPathArgument@Json@@PBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GPathArgument@Json@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT rgy
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT F
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4ValueAllocator@Json@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT g
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@ValueAllocator@Json@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT g(g
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVValueAllocator@Json@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT (g
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@DefaultValueAllocator@Json@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3ValueAllocator@Json@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ;
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT (g
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R2ValueAllocator@Json@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT *<
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT 
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_7DefaultValueAllocator@Json@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7ValueAllocator@Json@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVDefaultValueAllocator@Json@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4DefaultValueAllocator@Json@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT  
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ,
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT B
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT B-
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2DefaultValueAllocator@Json@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT B-
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT t
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3DefaultValueAllocator@Json@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT '
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT L-
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT -
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC

PUBLIC	?maxInt@Value@Json@@2HB				; Json::Value::maxInt
PUBLIC	?minInt@Value@Json@@2HB				; Json::Value::minInt
PUBLIC	?maxUInt@Value@Json@@2IB			; Json::Value::maxUInt
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_C@_02GLFAOOJA@?$FL?4?$AA@			; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ ; `string'
PUBLIC	??_R4out_of_range@std@@6B@			; std::out_of_range::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVout_of_range@std@@@8			; std::out_of_range `RTTI Type Descriptor'
PUBLIC	__TI3?AVout_of_range@std@@
PUBLIC	??_R1A@?0A@A@out_of_range@std@@8		; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4ValueAllocator@Json@@6B@			; Json::ValueAllocator::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@A@ValueAllocator@Json@@8		; Json::ValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R0?AVValueAllocator@Json@@@8			; Json::ValueAllocator `RTTI Type Descriptor'
PUBLIC	??_R2out_of_range@std@@8			; std::out_of_range::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@DefaultValueAllocator@Json@@8	; Json::DefaultValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R3ValueAllocator@Json@@8			; Json::ValueAllocator::`RTTI Class Hierarchy Descriptor'
PUBLIC	__CTA3?AVout_of_range@std@@
PUBLIC	??_R2ValueAllocator@Json@@8			; Json::ValueAllocator::`RTTI Base Class Array'
PUBLIC	??_7DefaultValueAllocator@Json@@6B@		; Json::DefaultValueAllocator::`vftable'
PUBLIC	??_7ValueAllocator@Json@@6B@			; Json::ValueAllocator::`vftable'
PUBLIC	__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
PUBLIC	??_R3out_of_range@std@@8			; std::out_of_range::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVDefaultValueAllocator@Json@@@8		; Json::DefaultValueAllocator `RTTI Type Descriptor'
PUBLIC	??_R4DefaultValueAllocator@Json@@6B@		; Json::DefaultValueAllocator::`RTTI Complete Object Locator'
PUBLIC	??_R2DefaultValueAllocator@Json@@8		; Json::DefaultValueAllocator::`RTTI Base Class Array'
PUBLIC	??_R3DefaultValueAllocator@Json@@8		; Json::DefaultValueAllocator::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7out_of_range@std@@6B@			; std::out_of_range::`vftable'
;	COMDAT ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A
_BSS	SEGMENT
?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A DD 01H DUP (?) ; `Json::valueAllocator'::`2'::defaultAllocator
_BSS	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
?minInt@Value@Json@@2HB DD 080000000H			; Json::Value::minInt
?maxInt@Value@Json@@2HB DD 07fffffffH			; Json::Value::maxInt
?maxUInt@Value@Json@@2IB DD 0ffffffffH			; Json::Value::maxUInt
;	COMDAT ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
_DATA	SEGMENT
?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A DD FLAT:?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A ; `Json::valueAllocator'::`2'::valueAllocator
_DATA	ENDS
;	COMDAT ??_C@_02GLFAOOJA@?$FL?4?$AA@
CONST	SEGMENT
??_C@_02GLFAOOJA@?$FL?4?$AA@ DB '[.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
CONST	SEGMENT
??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@ DB 'invalid '
	DB	'map/set<T> iterator', 00H			; `string'
CONST	ENDS
;	COMDAT ??_R0?AVout_of_range@std@@@8
_DATA	SEGMENT
??_R0?AVout_of_range@std@@@8 DD FLAT:??_7type_info@@6B@	; std::out_of_range `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVout_of_range@std@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0out_of_range@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVout_of_range@std@@
xdata$x	SEGMENT
__CTA3?AVout_of_range@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVout_of_range@std@@@8??0out_of_range@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVout_of_range@std@@
xdata$x	SEGMENT
__TI3?AVout_of_range@std@@ DD 00H
	DD	FLAT:??1out_of_range@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVout_of_range@std@@
xdata$x	ENDS
;	COMDAT ??_R0?AVValueAllocator@Json@@@8
_DATA	SEGMENT
??_R0?AVValueAllocator@Json@@@8 DD FLAT:??_7type_info@@6B@ ; Json::ValueAllocator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVValueAllocator@Json@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@ValueAllocator@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@A@ValueAllocator@Json@@8 DD FLAT:??_R0?AVValueAllocator@Json@@@8 ; Json::ValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R2ValueAllocator@Json@@8
rdata$r	SEGMENT
??_R2ValueAllocator@Json@@8 DD FLAT:??_R1A@?0A@A@ValueAllocator@Json@@8 ; Json::ValueAllocator::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3ValueAllocator@Json@@8
rdata$r	SEGMENT
??_R3ValueAllocator@Json@@8 DD 00H			; Json::ValueAllocator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4ValueAllocator@Json@@6B@
rdata$r	SEGMENT
??_R4ValueAllocator@Json@@6B@ DD 00H			; Json::ValueAllocator::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVValueAllocator@Json@@@8
	DD	FLAT:??_R3ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_7ValueAllocator@Json@@6B@
CONST	SEGMENT
??_7ValueAllocator@Json@@6B@ DD FLAT:??_R4ValueAllocator@Json@@6B@ ; Json::ValueAllocator::`vftable'
	DD	FLAT:??_EValueAllocator@Json@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT ??_R0?AVDefaultValueAllocator@Json@@@8
_DATA	SEGMENT
??_R0?AVDefaultValueAllocator@Json@@@8 DD FLAT:??_7type_info@@6B@ ; Json::DefaultValueAllocator `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDefaultValueAllocator@Json@@', 00H
_DATA	ENDS
;	COMDAT ??_R1A@?0A@A@DefaultValueAllocator@Json@@8
rdata$r	SEGMENT
??_R1A@?0A@A@DefaultValueAllocator@Json@@8 DD FLAT:??_R0?AVDefaultValueAllocator@Json@@@8 ; Json::DefaultValueAllocator::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R2DefaultValueAllocator@Json@@8
rdata$r	SEGMENT
??_R2DefaultValueAllocator@Json@@8 DD FLAT:??_R1A@?0A@A@DefaultValueAllocator@Json@@8 ; Json::DefaultValueAllocator::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@ValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R3DefaultValueAllocator@Json@@8
rdata$r	SEGMENT
??_R3DefaultValueAllocator@Json@@8 DD 00H		; Json::DefaultValueAllocator::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2DefaultValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_R4DefaultValueAllocator@Json@@6B@
rdata$r	SEGMENT
??_R4DefaultValueAllocator@Json@@6B@ DD 00H		; Json::DefaultValueAllocator::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVDefaultValueAllocator@Json@@@8
	DD	FLAT:??_R3DefaultValueAllocator@Json@@8
rdata$r	ENDS
;	COMDAT ??_7DefaultValueAllocator@Json@@6B@
CONST	SEGMENT
??_7DefaultValueAllocator@Json@@6B@ DD FLAT:??_R4DefaultValueAllocator@Json@@6B@ ; Json::DefaultValueAllocator::`vftable'
	DD	FLAT:??_EDefaultValueAllocator@Json@@UAEPAXI@Z
	DD	FLAT:?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z
	DD	FLAT:?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z
	DD	FLAT:?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z
	DD	FLAT:?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@A@out_of_range@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@out_of_range@std@@8 DD FLAT:??_R0?AVout_of_range@std@@@8 ; std::out_of_range::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R2out_of_range@std@@8
rdata$r	SEGMENT
??_R2out_of_range@std@@8 DD FLAT:??_R1A@?0A@A@out_of_range@std@@8 ; std::out_of_range::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R3out_of_range@std@@8
rdata$r	SEGMENT
??_R3out_of_range@std@@8 DD 00H				; std::out_of_range::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_R4out_of_range@std@@6B@
rdata$r	SEGMENT
??_R4out_of_range@std@@6B@ DD 00H			; std::out_of_range::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVout_of_range@std@@@8
	DD	FLAT:??_R3out_of_range@std@@8
rdata$r	ENDS
;	COMDAT ??_7out_of_range@std@@6B@
CONST	SEGMENT
??_7out_of_range@std@@6B@ DD FLAT:??_R4out_of_range@std@@6B@ ; std::out_of_range::`vftable'
	DD	FLAT:??_Eout_of_range@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	inc	eax

; 156  : 			}

	ret	0
??8const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator==
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 35   : 		}

	ret	4
??0?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++, COMDAT
; _this$ = eax

; 230  : 			++this->_Myptr;

	add	DWORD PTR [eax], 28			; 0000001cH

; 231  : 			return (*this);
; 232  : 			}

	ret	0
??Eiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 160  : 			return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [edx]
	xor	eax, eax
	cmp	ecx, esi
	setne	al
	pop	esi

; 161  : 			}

	ret	0
??9const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV012@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator++, COMDAT
; _this$ = eax

; 92   : 			++_Myptr;

	add	DWORD PTR [eax], 28			; 0000001cH

; 93   : 			return (*this);
; 94   : 			}

	ret	0
??Econst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator*, COMDAT
; _this$ = eax

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

	mov	eax, DWORD PTR [eax]

; 83   : 			}

	ret	0
??Dconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PBVPathArgument@Json@@PBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_copy@PBVPathArgument@Json@@PBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<Json::PathArgument const *,Json::PathArgument const *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 106  : 	size_t _Count = (size_t)(_Last - _First);

	sub	eax, ecx
	push	esi
	sar	eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Dest$[esp]
	push	esi
	push	ecx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi

; 109  : 	}

	ret	0
??$_Uninit_copy@PBVPathArgument@Json@@PBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::PathArgument const *,Json::PathArgument const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@@Z
_TEXT	SEGMENT
??$fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@@Z PROC NEAR ; std::fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

	test	ecx, ecx
	jbe	SHORT $L16160
	push	esi
$L16158:

; 1161 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	dec	ecx
	jne	SHORT $L16158
	pop	esi
$L16160:

; 1162 : 	}

	ret	0
??$fill_n@PAPBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@@Z ENDP ; std::fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::_Ptr_cat<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

	push	ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Ptr_cat<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::_Ptr_cat<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

	push	ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAVconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Ptr_cat<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAPBVPathArgument@Json@@PAPBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Copy_backward_opt@PAPBVPathArgument@Json@@PAPBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 1059 : 	ptrdiff_t _Off = _Last - _First;	// NB: non-overlapping move

	sub	eax, edx
	sar	eax, 2

; 1060 : 	return ((_OutIt)memmove(&*_Dest - _Off, &*_First,
; 1061 : 		_Off * sizeof (*_First)));

	shl	eax, 2
	push	eax
	push	edx
	sub	ecx, eax
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1062 : 	}

	ret	0
??$_Copy_backward_opt@PAPBVPathArgument@Json@@PAPBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Json::PathArgument const * *,Json::PathArgument const * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT

; 234  : 	}

	ret	0
??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC NEAR ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

	push	ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::_Ptr_cat<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z PROC NEAR ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

	push	ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ENDP ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Uninit_fill_n@PBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<Json::PathArgument const *,unsigned int,Json::PathArgument const *>, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 237  : 	fill_n(_First, _Count, _Val);

	test	ecx, ecx
	jbe	SHORT $L17815
	push	esi
$L17813:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	dec	ecx
	jne	SHORT $L17813
	pop	esi
$L17815:

; 238  : 	}

	ret	0
??$_Uninit_fill_n@PBVPathArgument@Json@@IPBV12@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Json::PathArgument const *,unsigned int,Json::PathArgument const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@$$CBVPathArgument@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@$$CBVPathArgument@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z PROC NEAR ; std::_Ptr_cat<Json::PathArgument const >, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

	push	ecx

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 221  : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@$$CBVPathArgument@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPBVPathArgument@Json@@0@Z ENDP ; std::_Ptr_cat<Json::PathArgument const >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z PROC NEAR ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>, COMDAT
; ___$ReturnUdt$ = eax

; 202  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 203  : 	return (_Cat);
; 204  : 	}

	ret	0
??$_Iter_cat@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YA?AUbidirectional_iterator_tag@0@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ENDP ; std::_Iter_cat<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAXI@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	ecx, esi
	call	??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp-4], 1
	je	SHORT $L17829
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L17829:
	mov	eax, esi
	ret	4
??_G_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAXI@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@IPAU120@@Z
_TEXT	SEGMENT
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@IPAU120@@Z PROC NEAR ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	ret	0
??$_Allocate@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@IPAU120@@Z ENDP ; std::_Allocate<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node><std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

	ret	0
??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node><std::pair<Json::Value::CZString const ,Json::Value> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

	ret	0
??$_Destroy@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z
_TEXT	SEGMENT
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z PROC NEAR ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>, COMDAT
; __Ptr$ = ecx

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

	jmp	??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
??$_Destroy@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@@Z ENDP ; std::_Destroy<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *><std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

	ret	0
??$?0U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAE@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *><std::pair<Json::Value::CZString const ,Json::Value> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@D@std@@YAXAAD0@Z
_TEXT	SEGMENT
??$swap@D@std@@YAXAAD0@Z PROC NEAR			; std::swap<char>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 15   : 	_Ty _Tmp = _Left;

	mov	dl, BYTE PTR [ecx]
	push	ebx

; 16   : 	_Left = _Right, _Right = _Tmp;

	mov	bl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], bl
	mov	BYTE PTR [eax], dl
	pop	ebx

; 17   : 	}

	ret	0
??$swap@D@std@@YAXAAD0@Z ENDP				; std::swap<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z
_TEXT	SEGMENT
??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z PROC NEAR ; std::_Allocate<Json::PathArgument>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	ret	0
??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ENDP ; std::_Allocate<Json::PathArgument>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z
_TEXT	SEGMENT
??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z PROC NEAR ; std::_Allocate<Json::PathArgument const *>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	ret	0
??$_Allocate@PBVPathArgument@Json@@@std@@YAPAPBVPathArgument@Json@@IPAPBV12@@Z ENDP ; std::_Allocate<Json::PathArgument const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAPBVPathArgument@Json@@PAPBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00@Z
_TEXT	SEGMENT
??$copy_backward@PAPBVPathArgument@Json@@PAPBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00@Z PROC NEAR ; std::copy_backward<Json::PathArgument const * *,Json::PathArgument const * *>, COMDAT
; __First$ = edx
; __Last$ = eax
; __Dest$ = ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

	sub	eax, edx
	sar	eax, 2
	shl	eax, 2
	push	eax
	push	edx
	sub	ecx, eax
	push	ecx
	call	_memmove
	add	esp, 12					; 0000000cH

; 1070 : 	}

	ret	0
??$copy_backward@PAPBVPathArgument@Json@@PAPBV12@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00@Z ENDP ; std::copy_backward<Json::PathArgument const * *,Json::PathArgument const * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z
_TEXT	SEGMENT
??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z PROC NEAR ; std::fill<Json::PathArgument const * *,Json::PathArgument const *>, COMDAT
; __First$ = eax
; __Last$ = ecx
; __Val$ = edx

; 1135 : 	for (; _First != _Last; ++_First)

	cmp	eax, ecx
	je	SHORT $L15655
	push	esi
$L15653:

; 1136 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	cmp	eax, ecx
	jne	SHORT $L15653
	pop	esi
$L15655:

; 1137 : 	}

	ret	0
??$fill@PAPBVPathArgument@Json@@PBV12@@std@@YAXPAPBVPathArgument@Json@@0ABQBV12@@Z ENDP ; std::fill<Json::PathArgument const * *,Json::PathArgument const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@@Z PROC NEAR ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

	ret	0
??$_Destroy_range@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@0AAV?$allocator@PBVPathArgument@Json@@@0@@Z ENDP ; std::_Destroy_range<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z
_TEXT	SEGMENT
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z PROC NEAR ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	imul	eax, 28					; 0000001cH
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	ret	0
??$_Allocate@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IPAV10@@Z ENDP ; std::_Allocate<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@@Z
_TEXT	SEGMENT
??$_Uninitialized_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

	test	ecx, ecx
	jbe	SHORT $L17911
	push	esi
$L17909:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	dec	ecx
	jne	SHORT $L17909
	pop	esi
$L17911:

; 258  : 	}

	ret	0
??$_Uninitialized_fill_n@PAPBVPathArgument@Json@@IPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAXPAPBVPathArgument@Json@@IABQBV12@AAV?$allocator@PBVPathArgument@Json@@@0@@Z ENDP ; std::_Uninitialized_fill_n<Json::PathArgument const * *,unsigned int,Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z
_TEXT	SEGMENT
??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z PROC NEAR ; std::swap<Json::Value::ValueHolder>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 15   : 	_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	push	edi

; 16   : 	_Left = _Right, _Right = _Tmp;

	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edi
	pop	edi
	mov	DWORD PTR [eax+4], esi
	mov	DWORD PTR [eax], edx
	pop	esi

; 17   : 	}

	ret	0
??$swap@TValueHolder@Value@Json@@@std@@YAXAATValueHolder@Value@Json@@0@Z ENDP ; std::swap<Json::Value::ValueHolder>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$swap@H@std@@YAXAAH0@Z
_TEXT	SEGMENT
??$swap@H@std@@YAXAAH0@Z PROC NEAR			; std::swap<int>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 15   : 	_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 16   : 	_Left = _Right, _Right = _Tmp;

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
	pop	esi

; 17   : 	}

	ret	0
??$swap@H@std@@YAXAAH0@Z ENDP				; std::swap<int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$swap@PBD@std@@YAXAAPBD0@Z
_TEXT	SEGMENT
??$swap@PBD@std@@YAXAAPBD0@Z PROC NEAR			; std::swap<char const *>, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 15   : 	_Ty _Tmp = _Left;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 16   : 	_Left = _Right, _Right = _Tmp;

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx
	pop	esi

; 17   : 	}

	ret	0
??$swap@PBD@std@@YAXAAPBD0@Z ENDP			; std::swap<char const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@QAE@U?$less@VCZString@Value@Json@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 1
??0?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@QAE@U?$less@VCZString@Value@Json@@@1@@Z PROC NEAR ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>, COMDAT
; _this$ = eax

; 39   : 		}

	ret	4
??0?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@QAE@U?$less@VCZString@Value@Json@@@1@@Z ENDP ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+=, COMDAT
; _this$ = eax
; __Off$ = ecx

; 256  : 			this->_Myptr += _Off;

	mov	edx, DWORD PTR [eax]
	imul	ecx, 28					; 0000001cH
	add	edx, ecx
	mov	DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

	ret	0
??Yiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV012@H@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = edx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR [edx]
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 144  : 			}

	ret	0
??Gconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABV012@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
??Yiterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::operator+=, COMDAT
; _this$ = eax
; __Off$ = ecx

; 256  : 			this->_Myptr += _Off;

	mov	edx, DWORD PTR [eax]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	shl	ecx, 2
	add	edx, ecx
	mov	DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

	ret	0
??Yiterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Yiterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
??Yiterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::operator+=, COMDAT
; _this$ = eax
; __Off$ = ecx

; 256  : 			this->_Myptr += _Off;

	lea	edx, DWORD PTR [ecx*4]
	add	DWORD PTR [eax], edx

; 257  : 			return (*this);
; 258  : 			}

	ret	0
??Yiterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
??Gconst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = edx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

	mov	ecx, DWORD PTR [eax]
	sub	ecx, DWORD PTR [edx]
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 144  : 			}

	ret	0
??Gconst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
??Gconst_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = ecx

; 141  : 
; 142  : 
; 143  : 			return (_Myptr - _Right._Myptr);

	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 144  : 			}

	ret	0
??Gconst_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABV012@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::operator-
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 138  : 		}

	ret	0
?allocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 178956970				; 0aaaaaaaH

; 159  : 		}

	ret	0
?max_size@?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = eax

; 55   : 		}

	ret	4
??0?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ PROC NEAR ; std::allocator<Json::PathArgument>::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 119304647				; 071c71c7H

; 159  : 		}

	ret	0
?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::PathArgument>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ PROC NEAR ; std::allocator<Json::PathArgument const *>::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 159  : 		}

	ret	0
?max_size@?$allocator@PBVPathArgument@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::PathArgument const *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 280  : 			}

	ret	0
??Giterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax
; __Off$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

	imul	ecx, 28					; 0000001cH
	add	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 264  : 			}

	ret	0
??Hiterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AV012@H@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Ptr$ = ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

	mov	DWORD PTR [eax], ecx

; 76   : 			}

	ret	0
??0const_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax+4], edx

; 35   : 		}

	ret	4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@0@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z
_TEXT	SEGMENT
__Val2$ = 8						; size = 4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z PROC NEAR ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>, COMDAT
; _this$ = eax
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Val2$[esp-4]
	mov	DWORD PTR [eax], edx
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax+4], dl

; 35   : 		}

	ret	4
??0?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@std@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@1@AB_N@Z ENDP ; std::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>::pair<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,bool>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
??Giterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	mov	ecx, eax
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 280  : 			}

	ret	0
??Giterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
??Hiterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::operator+, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax
; __Off$ = ecx

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

	mov	edx, DWORD PTR [edx]
	lea	ecx, DWORD PTR [ecx+ecx*8]
	lea	ecx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax], ecx

; 264  : 			}

	ret	0
??Hiterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Giterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
??Giterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = ecx

; 279  : 			return ((const_iterator)*this - _Right);

	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 280  : 			}

	ret	0
??Giterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Hiterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Hiterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::operator+, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 262  : 			iterator _Tmp = *this;
; 263  : 			return (_Tmp += _Off);

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Off$[esp-4]
	lea	edx, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [eax], edx

; 264  : 			}

	ret	4
??Hiterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::operator+
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 153391689				; 09249249H

; 159  : 		}

	ret	0
?max_size@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBEIXZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 200  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [eax], ecx

; 201  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

	ret	0
?destroy@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::destroy, COMDAT
; __Ptr$ = ecx

; 152  : 		_Destroy(_Ptr);

	jmp	??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
?destroy@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate, COMDAT
; __Ptr$ = eax

; 132  : 		operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 133  : 		}

	ret	0
?deallocate@?$allocator@U_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@I@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_ptr@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_ptr@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC NEAR ; std::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = eax

; 77   : 		}

	ret	4
??0?$_Tree_ptr@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_ptr<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size, COMDAT

; 453  : 		return (this->_Alval.max_size());

	mov	eax, 178956970				; 0aaaaaaaH

; 454  : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent, COMDAT
; __Pnode$ = eax

; 152  : 		return ((_Nodepref)(*_Pnode)._Parent);

	add	eax, 4

; 153  : 		}

	ret	0
?_Parent@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Parent
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left, COMDAT
; __Pnode$ = eax

; 147  : 		return ((_Nodepref)(*_Pnode)._Left);
; 148  : 		}

	ret	0
?_Left@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Left
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color, COMDAT
; __Pnode$ = eax

; 132  : 		return ((_Charref)(*_Pnode)._Color);

	add	eax, 40					; 00000028H

; 133  : 		}

	ret	0
?_Color@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Color
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z PROC NEAR ; std::allocator<Json::PathArgument>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 138  : 		}

	ret	0
?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z PROC NEAR ; std::allocator<Json::PathArgument>::deallocate, COMDAT
; __Ptr$ = eax

; 132  : 		operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 133  : 		}

	ret	0
?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	ret	0
??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size, COMDAT

; 521  : 		return (this->_Alval.max_size());

	mov	eax, 119304647				; 071c71c7H

; 522  : 		}

	ret	0
?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z PROC NEAR ; std::allocator<Json::PathArgument const *>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 138  : 		}

	ret	0
?allocate@?$allocator@PBVPathArgument@Json@@@std@@QAEPAPBVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument const *>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z PROC NEAR ; std::allocator<Json::PathArgument const *>::deallocate, COMDAT
; __Ptr$ = eax

; 132  : 		operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 133  : 		}

	ret	0
?deallocate@?$allocator@PBVPathArgument@Json@@@std@@QAEXPAPBVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument const *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PBVPathArgument@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@PBVPathArgument@Json@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	ret	0
??0?$allocator@PBVPathArgument@Json@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy, COMDAT

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);
; 788  : 		}

	ret	0
?_Destroy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXPAPBVPathArgument@Json@@0@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size, COMDAT

; 521  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 522  : 		}

	ret	0
?max_size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	inc	eax

; 156  : 			}

	ret	0
??8const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@@Z
_TEXT	SEGMENT
??0const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Ptr$ = ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

	mov	DWORD PTR [eax], ecx

; 76   : 			}

	ret	0
??0const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@@Z
_TEXT	SEGMENT
??0const_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Ptr$ = ecx

; 74   : 			{	// construct with pointer _Ptr
; 75   : 			_Myptr = _Ptr;

	mov	DWORD PTR [eax], ecx

; 76   : 			}

	ret	0
??0const_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

	imul	eax, 28					; 0000001cH
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 138  : 		}

	ret	0
?allocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate, COMDAT
; __Ptr$ = eax

; 132  : 		operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 133  : 		}

	ret	0
?deallocate@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	ret	0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	ret	0
??0?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC NEAR ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = eax

; 22   : 		}

	ret	4
??0?$_Vector_val@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Vector_val<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size, COMDAT

; 521  : 		return (this->_Alval.max_size());

	mov	eax, 153391689				; 09249249H

; 522  : 		}

	ret	0
?max_size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L18193

; 517  : 		}

	ret	0
$L18193:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	ecx, DWORD PTR [ecx+8]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 517  : 		}

	ret	0
?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 478  : 		return (const_iterator(_Mylast));

	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 479  : 		}

	ret	0
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 468  : 		return (const_iterator(_Myfirst));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 469  : 		}

	ret	0
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L18212

; 459  : 		}

	ret	0
$L18212:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 459  : 		}

	ret	0
?capacity@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ
_TEXT	SEGMENT
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode, COMDAT
; _this$ = eax

; 284  : 			return (_Ptr);

	mov	eax, DWORD PTR [eax]

; 285  : 			}

	ret	0
?_Mynode@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@3@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Mynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 193  : 			{	// construct with null node pointer

	mov	DWORD PTR [eax], 0

; 194  : 			}

	ret	0
??0const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator, COMDAT
; _this$ = eax
; __Pnode$ = ecx

; 312  : 			{	// construct with node pointer _Pnode

	mov	DWORD PTR [eax], ecx

; 313  : 			}

	ret	0
??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ PROC NEAR ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	ret	0
??0?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >::allocator<std::pair<Json::Value::CZString const ,Json::Value> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT
?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z PROC NEAR ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn, COMDAT
; __Val$ = eax

; 64   : 		return (_Val.first);
; 65   : 		}

	ret	0
?_Kfn@?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@SAABVCZString@Value@Json@@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ENDP ; std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0>::_Kfn
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC NEAR ; std::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = eax

; 96   : 		}

	ret	4
??0?$_Tree_val@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE@ABU?$less@VCZString@Value@Json@@@1@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree_val<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root, COMDAT
; _this$ = eax

; 1059 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [eax+4]
	add	eax, 4

; 1060 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1005 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [eax+4]

; 1006 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ
_TEXT	SEGMENT
?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp, COMDAT
; ___$ReturnUdt$ = eax

; 468  : 		return (this->comp);
; 469  : 		}

	ret	0
?key_comp@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AU?$less@VCZString@Value@Json@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::key_comp
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?get_allocator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@XZ
_TEXT	SEGMENT
?get_allocator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::get_allocator, COMDAT
; ___$ReturnUdt$ = eax

; 463  : 		return (this->_Alval);
; 464  : 		}

	ret	0
?get_allocator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::get_allocator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Myval, COMDAT
; __Pnode$ = eax

; 162  : 		return ((_Vref)(*_Pnode)._Myval);

	add	eax, 16					; 00000010H

; 163  : 		}

	ret	0
?_Myval@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Myval
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right, COMDAT
; __Pnode$ = eax

; 157  : 		return ((_Nodepref)(*_Pnode)._Right);

	add	eax, 8

; 158  : 		}

	ret	0
?_Right@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Right
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key, COMDAT
; __Pnode$ = eax

; 142  : 		return (_Mybase::_Kfn(_Myval(_Pnode)));

	add	eax, 16					; 00000010H

; 143  : 		}

	ret	0
?_Key@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAABVCZString@Value@Json@@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Key
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil, COMDAT
; __Pnode$ = eax

; 137  : 		return ((_Charref)(*_Pnode)._Isnil);

	add	eax, 41					; 00000029H

; 138  : 		}

	ret	0
?_Isnil@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAAADPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Isnil
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ PROC NEAR ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	ret	0
??0?$allocator@VPathArgument@Json@@@std@@QAE@XZ ENDP	; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z PROC NEAR ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = eax

; 22   : 		}

	ret	4
??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ENDP ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size, COMDAT
; _this$ = ecx

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L18330

; 517  : 		}

	ret	0
$L18330:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	ecx, DWORD PTR [ecx+8]
	sub	ecx, eax
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 517  : 		}

	ret	0
?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity, COMDAT
; _this$ = ecx

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	jne	SHORT $L18335

; 459  : 		}

	ret	0
$L18335:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ecx+12]
	sub	ecx, eax
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 459  : 		}

	ret	0
?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ PROC NEAR ; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	ret	0
??0?$allocator@PBVPathArgument@Json@@@std@@QAE@XZ ENDP	; std::allocator<Json::PathArgument const *>::allocator<Json::PathArgument const *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE@V?$allocator@PBVPathArgument@Json@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Vector_val@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE@V?$allocator@PBVPathArgument@Json@@@1@@Z PROC NEAR ; std::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = eax

; 22   : 		}

	ret	4
??0?$_Vector_val@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE@V?$allocator@PBVPathArgument@Json@@@1@@Z ENDP ; std::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Vector_val<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z
_TEXT	SEGMENT
?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	test	esi, esi
	mov	eax, edi
	jbe	SHORT $L18386
	mov	ecx, esi
	push	ebx
	npad	7
$L18380:
	mov	ebx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ebx
	add	eax, 4
	dec	ecx
	jne	SHORT $L18380
	pop	ebx
$L18386:

; 879  : 		return (_Ptr + _Count);

	lea	eax, DWORD PTR [edi+esi*4]

; 880  : 		}

	ret	0
?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy, COMDAT
; _this$ = esi

; 792  : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $L18391

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);
; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L18391:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0

; 798  : 		}

	ret	0
?_Tidy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size, COMDAT
; _this$ = eax

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $L18398
	xor	eax, eax

; 517  : 		}

	ret	0
$L18398:

; 516  : 		return (_Myfirst == 0 ? 0 : _Mylast - _Myfirst);

	mov	eax, DWORD PTR [eax+8]
	sub	eax, ecx
	sar	eax, 2

; 517  : 		}

	ret	0
?size@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity, COMDAT
; _this$ = eax

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	jne	SHORT $L18403
	xor	eax, eax

; 459  : 		}

	ret	0
$L18403:

; 458  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR [eax+12]
	sub	eax, ecx
	sar	eax, 2

; 459  : 		}

	ret	0
?capacity@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::capacity
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 160  : 			return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [edx]
	xor	eax, eax
	cmp	ecx, esi
	setne	al
	pop	esi

; 161  : 			}

	ret	0
??9const_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator++, COMDAT
; _this$ = eax

; 92   : 			++_Myptr;

	add	DWORD PTR [eax], 36			; 00000024H

; 93   : 			return (*this);
; 94   : 			}

	ret	0
??Econst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV012@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

	mov	eax, DWORD PTR [eax]

; 83   : 			}

	ret	0
??Dconst_iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEABVPathArgument@Json@@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::const_iterator::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 153  : 
; 154  : 
; 155  : 			return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	inc	eax

; 156  : 			}

	ret	0
??8const_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 80   : 
; 81   : 
; 82   : 			return (*_Myptr);

	mov	eax, DWORD PTR [eax]

; 83   : 			}

	ret	0
??Dconst_iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBEABQBVPathArgument@Json@@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::const_iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==, COMDAT
; _this$ = eax
; __Right$ = ecx

; 241  : 			return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	inc	eax

; 242  : 			}

	ret	0
??8const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*, COMDAT
; _this$ = eax

; 205  : 			return (_Myval(_Ptr));

	mov	eax, DWORD PTR [eax]
	add	eax, 16					; 00000010H

; 206  : 			}

	ret	0
??Dconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEABU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ
_TEXT	SEGMENT
??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*, COMDAT
; _this$ = eax

; 317  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [eax]
	add	eax, 16					; 00000010H

; 318  : 			}

	ret	0
??Diterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEAAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator, COMDAT
; _this$ = eax

; 304  : 		iterator()

	mov	DWORD PTR [eax], 0

; 305  : 			{	// construct with null node pointer
; 306  : 			}

	ret	0
??0iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size, COMDAT
; _this$ = eax

; 448  : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+8]

; 449  : 		}

	ret	0
?size@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 418  : 		return (_TREE_ITERATOR(_Myhead));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 419  : 		}

	ret	0
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 408  : 		return (_TREE_ITERATOR(_Lmost()));

	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 409  : 		}

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 478  : 		return (const_iterator(_Mylast));

	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 479  : 		}

	ret	0
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 468  : 		return (const_iterator(_Myfirst));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 469  : 		}

	ret	0
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 478  : 		return (const_iterator(_Mylast));

	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 479  : 		}

	ret	0
?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 468  : 		return (const_iterator(_Myfirst));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 469  : 		}

	ret	0
?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = esi

; 388  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $L18524
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L18524:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0

; 389  : 		}

	ret	0
??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::Path::invalidPath
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
;	COMDAT ?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC NEAR ; Json::Path::invalidPath, COMDAT

; 1544 :    // Error: invalid path.
; 1545 : }

	ret	0
?invalidPath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; Json::Path::invalidPath
_TEXT	ENDS
PUBLIC	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
; Function compile flags: /Ogtpy
;	COMDAT ?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z
_TEXT	SEGMENT
?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z PROC NEAR ; Json::Value::hasComment, COMDAT
; _this$ = eax
; _placement$ = ecx

; 1264 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $L18533
	cmp	DWORD PTR [eax+ecx*4], 0
	je	SHORT $L18533
	mov	eax, 1

; 1265 : }

	ret	0
$L18533:

; 1264 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	xor	eax, eax

; 1265 : }

	ret	0
?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ENDP ; Json::Value::hasComment
_TEXT	ENDS
PUBLIC	?isObject@Value@Json@@QBE_NXZ			; Json::Value::isObject
; Function compile flags: /Ogtpy
;	COMDAT ?isObject@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?isObject@Value@Json@@QBE_NXZ PROC NEAR			; Json::Value::isObject, COMDAT
; _this$ = eax

; 1239 :    return type_ == nullValue  ||  type_ == objectValue;

	mov	al, BYTE PTR [eax+8]
	test	al, al
	je	SHORT $L18538
	cmp	al, 7
	je	SHORT $L18538
	xor	eax, eax

; 1240 : }

	ret	0
$L18538:

; 1239 :    return type_ == nullValue  ||  type_ == objectValue;

	mov	eax, 1

; 1240 : }

	ret	0
?isObject@Value@Json@@QBE_NXZ ENDP			; Json::Value::isObject
_TEXT	ENDS
PUBLIC	?isArray@Value@Json@@QBE_NXZ			; Json::Value::isArray
; Function compile flags: /Ogtpy
;	COMDAT ?isArray@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?isArray@Value@Json@@QBE_NXZ PROC NEAR			; Json::Value::isArray, COMDAT
; _this$ = eax

; 1232 :    return type_ == nullValue  ||  type_ == arrayValue;

	mov	al, BYTE PTR [eax+8]
	test	al, al
	je	SHORT $L18543
	cmp	al, 6
	je	SHORT $L18543
	xor	eax, eax

; 1233 : }

	ret	0
$L18543:

; 1232 :    return type_ == nullValue  ||  type_ == arrayValue;

	mov	eax, 1

; 1233 : }

	ret	0
?isArray@Value@Json@@QBE_NXZ ENDP			; Json::Value::isArray
_TEXT	ENDS
PUBLIC	?isString@Value@Json@@QBE_NXZ			; Json::Value::isString
; Function compile flags: /Ogtpy
;	COMDAT ?isString@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?isString@Value@Json@@QBE_NXZ PROC NEAR			; Json::Value::isString, COMDAT
; _this$ = ecx

; 1225 :    return type_ == stringValue;

	mov	dl, BYTE PTR [ecx+8]
	xor	eax, eax
	cmp	dl, 4
	sete	al

; 1226 : }

	ret	0
?isString@Value@Json@@QBE_NXZ ENDP			; Json::Value::isString
_TEXT	ENDS
PUBLIC	?isDouble@Value@Json@@QBE_NXZ			; Json::Value::isDouble
; Function compile flags: /Ogtpy
;	COMDAT ?isDouble@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?isDouble@Value@Json@@QBE_NXZ PROC NEAR			; Json::Value::isDouble, COMDAT
; _this$ = ecx

; 1211 :    return type_ == realValue;

	mov	dl, BYTE PTR [ecx+8]
	xor	eax, eax
	cmp	dl, 3
	sete	al

; 1212 : }

	ret	0
?isDouble@Value@Json@@QBE_NXZ ENDP			; Json::Value::isDouble
_TEXT	ENDS
PUBLIC	?isIntegral@Value@Json@@QBE_NXZ			; Json::Value::isIntegral
; Function compile flags: /Ogtpy
;	COMDAT ?isIntegral@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?isIntegral@Value@Json@@QBE_NXZ PROC NEAR		; Json::Value::isIntegral, COMDAT
; _this$ = eax

; 1202 :    return type_ == intValue  
; 1203 :           ||  type_ == uintValue  
; 1204 :           ||  type_ == booleanValue;

	mov	al, BYTE PTR [eax+8]
	cmp	al, 1
	je	SHORT $L18554
	cmp	al, 2
	je	SHORT $L18554
	cmp	al, 5
	je	SHORT $L18554
	xor	eax, eax

; 1205 : }

	ret	0
$L18554:

; 1202 :    return type_ == intValue  
; 1203 :           ||  type_ == uintValue  
; 1204 :           ||  type_ == booleanValue;

	mov	eax, 1

; 1205 : }

	ret	0
?isIntegral@Value@Json@@QBE_NXZ ENDP			; Json::Value::isIntegral
_TEXT	ENDS
PUBLIC	?isUInt@Value@Json@@QBE_NXZ			; Json::Value::isUInt
; Function compile flags: /Ogtpy
;	COMDAT ?isUInt@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?isUInt@Value@Json@@QBE_NXZ PROC NEAR			; Json::Value::isUInt, COMDAT
; _this$ = ecx

; 1195 :    return type_ == uintValue;

	mov	dl, BYTE PTR [ecx+8]
	xor	eax, eax
	cmp	dl, 2
	sete	al

; 1196 : }

	ret	0
?isUInt@Value@Json@@QBE_NXZ ENDP			; Json::Value::isUInt
_TEXT	ENDS
PUBLIC	?isInt@Value@Json@@QBE_NXZ			; Json::Value::isInt
; Function compile flags: /Ogtpy
;	COMDAT ?isInt@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?isInt@Value@Json@@QBE_NXZ PROC NEAR			; Json::Value::isInt, COMDAT
; _this$ = ecx

; 1188 :    return type_ == intValue;

	mov	dl, BYTE PTR [ecx+8]
	xor	eax, eax
	cmp	dl, 1
	sete	al

; 1189 : }

	ret	0
?isInt@Value@Json@@QBE_NXZ ENDP				; Json::Value::isInt
_TEXT	ENDS
PUBLIC	?isBool@Value@Json@@QBE_NXZ			; Json::Value::isBool
; Function compile flags: /Ogtpy
;	COMDAT ?isBool@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?isBool@Value@Json@@QBE_NXZ PROC NEAR			; Json::Value::isBool, COMDAT
; _this$ = ecx

; 1181 :    return type_ == booleanValue;

	mov	dl, BYTE PTR [ecx+8]
	xor	eax, eax
	cmp	dl, 5
	sete	al

; 1182 : }

	ret	0
?isBool@Value@Json@@QBE_NXZ ENDP			; Json::Value::isBool
_TEXT	ENDS
PUBLIC	?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z ; Json::Value::isConvertibleTo
PUBLIC	__real@0000000000000000
PUBLIC	__real@c1e0000000000000
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@41efffffffe00000
EXTRN	__fltused:NEAR
;	COMDAT __real@0000000000000000
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@c1e0000000000000
CONST	SEGMENT
__real@c1e0000000000000 DQ 0c1e0000000000000r	; -2.14748e+009
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+009
CONST	ENDS
;	COMDAT __real@41efffffffe00000
CONST	SEGMENT
__real@41efffffffe00000 DQ 041efffffffe00000r	; 4.29497e+009
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
CONST	ENDS
;	COMDAT ?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z
_TEXT	SEGMENT
?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z PROC NEAR ; Json::Value::isConvertibleTo, COMDAT
; _this$ = ecx
; _other$ = eax

; 797  :    switch ( type_ )

	movsx	edx, BYTE PTR [ecx+8]
	cmp	edx, 7
	ja	$L12288
	jmp	DWORD PTR $L18631[edx*4]
$L12280:

; 798  :    {
; 799  :    case nullValue:
; 800  :       return true;

	mov	al, 1

; 842  : }

	ret	0
$L12281:

; 801  :    case intValue:
; 802  :       return ( other == nullValue  &&  value_.int_ == 0 )
; 803  :              || other == intValue
; 804  :              || ( other == uintValue  && value_.int_ >= 0 )
; 805  :              || other == realValue
; 806  :              || other == stringValue
; 807  :              || other == booleanValue;

	test	eax, eax
	jne	SHORT $L18568
	mov	eax, DWORD PTR [ecx]
	jmp	$L18630
$L18568:
	cmp	eax, 1
	je	SHORT $L18592
	cmp	eax, 2
	jne	$L18579
	cmp	DWORD PTR [ecx], 0
	jl	$L18591
$L18592:

; 835  :    case objectValue:
; 836  :       return other == objectValue
; 837  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	mov	eax, 1

; 842  : }

	ret	0
$L12282:

; 808  :    case uintValue:
; 809  :       return ( other == nullValue  &&  value_.uint_ == 0 )
; 810  :              || ( other == intValue  && value_.uint_ <= maxInt )
; 811  :              || other == uintValue
; 812  :              || other == realValue
; 813  :              || other == stringValue
; 814  :              || other == booleanValue;

	test	eax, eax
	jne	SHORT $L18572
	mov	eax, DWORD PTR [ecx]
	jmp	$L18630
$L18572:
	cmp	eax, 1
	jne	$L18573
	cmp	DWORD PTR [ecx], 2147483647		; 7fffffffH
	jbe	SHORT $L18592

; 835  :    case objectValue:
; 836  :       return other == objectValue
; 837  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	xor	eax, eax

; 842  : }

	ret	0
$L12283:

; 815  :    case realValue:
; 816  :       return ( other == nullValue  &&  value_.real_ == 0.0 )
; 817  :              || ( other == intValue  &&  value_.real_ >= minInt  &&  value_.real_ <= maxInt )
; 818  :              || ( other == uintValue  &&  value_.real_ >= 0  &&  value_.real_ <= maxUInt )
; 819  :              || other == realValue
; 820  :              || other == stringValue
; 821  :              || other == booleanValue;

	test	eax, eax
	jne	SHORT $L18576
	fld	QWORD PTR __real@0000000000000000
	fld	QWORD PTR [ecx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jnp	SHORT $L18592

; 835  :    case objectValue:
; 836  :       return other == objectValue
; 837  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	xor	eax, eax

; 842  : }

	ret	0
$L18576:

; 815  :    case realValue:
; 816  :       return ( other == nullValue  &&  value_.real_ == 0.0 )
; 817  :              || ( other == intValue  &&  value_.real_ >= minInt  &&  value_.real_ <= maxInt )
; 818  :              || ( other == uintValue  &&  value_.real_ >= 0  &&  value_.real_ <= maxUInt )
; 819  :              || other == realValue
; 820  :              || other == stringValue
; 821  :              || other == booleanValue;

	cmp	eax, 1
	jne	SHORT $L18577
	fld	QWORD PTR [ecx]
	fcomp	QWORD PTR __real@c1e0000000000000
	fnstsw	ax
	test	ah, 1
	jne	$L18591
	fld	QWORD PTR [ecx]
	fcomp	QWORD PTR __real@41dfffffffc00000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	SHORT $L18592

; 835  :    case objectValue:
; 836  :       return other == objectValue
; 837  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	xor	eax, eax

; 842  : }

	ret	0
$L18577:

; 815  :    case realValue:
; 816  :       return ( other == nullValue  &&  value_.real_ == 0.0 )
; 817  :              || ( other == intValue  &&  value_.real_ >= minInt  &&  value_.real_ <= maxInt )
; 818  :              || ( other == uintValue  &&  value_.real_ >= 0  &&  value_.real_ <= maxUInt )
; 819  :              || other == realValue
; 820  :              || other == stringValue
; 821  :              || other == booleanValue;

	cmp	eax, 2
	jne	SHORT $L18579
	fld	QWORD PTR [ecx]
	fcomp	QWORD PTR __real@0000000000000000
	fnstsw	ax
	test	ah, 1
	jne	$L18591
	fld	QWORD PTR [ecx]
	fcomp	QWORD PTR __real@41efffffffe00000
	fnstsw	ax
	test	ah, 65					; 00000041H
	jnp	$L18592

; 835  :    case objectValue:
; 836  :       return other == objectValue
; 837  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	xor	eax, eax

; 842  : }

	ret	0
$L12284:

; 822  :    case booleanValue:
; 823  :       return ( other == nullValue  &&  value_.bool_ == false )
; 824  :              || other == intValue
; 825  :              || other == uintValue
; 826  :              || other == realValue
; 827  :              || other == stringValue
; 828  :              || other == booleanValue;

	test	eax, eax
	jne	SHORT $L18581
	cmp	BYTE PTR [ecx], 0
	jmp	SHORT $L18629
$L18581:
	cmp	eax, 1
	je	$L18592
$L18573:
	cmp	eax, 2
	je	$L18592
$L18579:
	cmp	eax, 3
	je	$L18592
	cmp	eax, 4
	je	$L18592
	cmp	eax, 5
	jmp	SHORT $L18629
$L12285:

; 829  :    case stringValue:
; 830  :       return other == stringValue
; 831  :              || ( other == nullValue  &&  (!value_.string_  ||  value_.string_[0] == 0) );

	cmp	eax, 4
	je	$L18592
	test	eax, eax
	jne	SHORT $L18591
	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	$L18592
	cmp	BYTE PTR [ecx], 0
	jmp	SHORT $L18629
$L12286:

; 832  :    case arrayValue:
; 833  :       return other == arrayValue
; 834  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	cmp	eax, 6
	je	$L18592
	test	eax, eax
	jne	SHORT $L18591
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	jmp	SHORT $L18629
$L12287:

; 835  :    case objectValue:
; 836  :       return other == objectValue
; 837  :              ||  ( other == nullValue  &&  value_.map_->size() == 0 );

	cmp	eax, 7
	je	$L18592
	test	eax, eax
	jne	SHORT $L18591
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
$L18630:
	test	eax, eax
$L18629:
	je	$L18592
$L18591:
	xor	eax, eax

; 842  : }

	ret	0
$L12288:

; 838  :    default:
; 839  :       JSON_ASSERT_UNREACHABLE;
; 840  :    }
; 841  :    return false; // unreachable;

	xor	al, al

; 842  : }

	ret	0
	npad	2
$L18631:
	DD	$L12280
	DD	$L12281
	DD	$L12282
	DD	$L12283
	DD	$L12285
	DD	$L12284
	DD	$L12286
	DD	$L12287
?isConvertibleTo@Value@Json@@QBE_NW4ValueType@2@@Z ENDP	; Json::Value::isConvertibleTo
_TEXT	ENDS
PUBLIC	?asBool@Value@Json@@QBE_NXZ			; Json::Value::asBool
; Function compile flags: /Ogtpy
;	COMDAT ?asBool@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?asBool@Value@Json@@QBE_NXZ PROC NEAR			; Json::Value::asBool, COMDAT
; _this$ = eax

; 771  :    switch ( type_ )

	movsx	ecx, BYTE PTR [eax+8]
	cmp	ecx, 7
	ja	SHORT $L12270
	jmp	DWORD PTR $L18645[ecx*4]
$L12265:

; 772  :    {
; 773  :    case nullValue:
; 774  :       return false;
; 775  :    case intValue:
; 776  :    case uintValue:
; 777  :       return value_.int_ != 0;

	mov	edx, DWORD PTR [eax]
	xor	ecx, ecx
	test	edx, edx
	setne	cl
	mov	al, cl

; 791  : }

	ret	0
$L12266:

; 778  :    case realValue:
; 779  :       return value_.real_ != 0.0;

	fld	QWORD PTR __real@0000000000000000
	fld	QWORD PTR [eax]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L18644
$L18638:

; 782  :    case stringValue:
; 783  :       return value_.string_  &&  value_.string_[0] != 0;

	xor	eax, eax

; 791  : }

	ret	0
$L12267:

; 780  :    case booleanValue:
; 781  :       return value_.bool_;

	mov	al, BYTE PTR [eax]

; 791  : }

	ret	0
$L12268:

; 782  :    case stringValue:
; 783  :       return value_.string_  &&  value_.string_[0] != 0;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $L18638
	cmp	BYTE PTR [eax], 0
	je	SHORT $L18638
$L18644:
	mov	eax, 1

; 791  : }

	ret	0
$L12269:

; 784  :    case arrayValue:
; 785  :    case objectValue:
; 786  :       return value_.map_->size() != 0;

	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [edx+8]
	xor	eax, eax
	test	ecx, ecx
	setne	al

; 791  : }

	ret	0
$L12270:

; 787  :    default:
; 788  :       JSON_ASSERT_UNREACHABLE;
; 789  :    }
; 790  :    return false; // unreachable;

	xor	al, al

; 791  : }

	ret	0
$L18645:
	DD	$L12270
	DD	$L12265
	DD	$L12265
	DD	$L12266
	DD	$L12268
	DD	$L12267
	DD	$L12269
	DD	$L12269
?asBool@Value@Json@@QBE_NXZ ENDP			; Json::Value::asBool
_TEXT	ENDS
PUBLIC	?asDouble@Value@Json@@QBENXZ			; Json::Value::asDouble
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@41f0000000000000
;	COMDAT __real@41f0000000000000
CONST	SEGMENT
__real@41f0000000000000 DQ 041f0000000000000r	; 4.29497e+009
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?asDouble@Value@Json@@QBENXZ
_TEXT	SEGMENT
tv158 = -8						; size = 8
tv156 = -8						; size = 4
tv155 = -8						; size = 8
tv72 = -8						; size = 8
?asDouble@Value@Json@@QBENXZ PROC NEAR			; Json::Value::asDouble, COMDAT
; _this$ = eax

; 746  :    switch ( type_ )

	movsx	ecx, BYTE PTR [eax+8]
	sub	esp, 8
	cmp	ecx, 5
	ja	SHORT $L12253
	jmp	DWORD PTR $L18657[ecx*4]
$L12249:

; 747  :    {
; 748  :    case nullValue:
; 749  :       return 0.0;
; 750  :    case intValue:
; 751  :       return value_.int_;

	fild	DWORD PTR [eax]
	fstp	QWORD PTR tv158[esp+8]
	fld	QWORD PTR tv158[esp+8]

; 766  : }

	add	esp, 8
	ret	0
$L12250:

; 752  :    case uintValue:
; 753  :       return value_.uint_;

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	mov	DWORD PTR tv156[esp+8], eax
	fild	DWORD PTR tv156[esp+8]
	jge	SHORT $L18653
	fadd	QWORD PTR __real@41f0000000000000
$L18653:
	fstp	QWORD PTR tv155[esp+8]
	fld	QWORD PTR tv155[esp+8]

; 766  : }

	add	esp, 8
	ret	0
$L12251:

; 754  :    case realValue:
; 755  :       return value_.real_;

	fld	QWORD PTR [eax]

; 766  : }

	add	esp, 8
	ret	0
$L12252:

; 756  :    case booleanValue:
; 757  :       return value_.bool_ ? 1.0 : 0.0;

	cmp	BYTE PTR [eax], 0
	je	SHORT $L18649
	fld	QWORD PTR __real@3ff0000000000000
	fstp	QWORD PTR tv72[esp+8]
	fld	QWORD PTR tv72[esp+8]

; 766  : }

	add	esp, 8
	ret	0
$L18649:

; 756  :    case booleanValue:
; 757  :       return value_.bool_ ? 1.0 : 0.0;

	fld	QWORD PTR __real@0000000000000000
	fstp	QWORD PTR tv72[esp+8]
	fld	QWORD PTR tv72[esp+8]

; 766  : }

	add	esp, 8
	ret	0
$L12253:

; 758  :    case stringValue:
; 759  :    case arrayValue:
; 760  :    case objectValue:
; 761  :       JSON_ASSERT( "Type is not convertible to double" && false );
; 762  :    default:
; 763  :       JSON_ASSERT_UNREACHABLE;
; 764  :    }
; 765  :    return 0; // unreachable;

	fld	QWORD PTR __real@0000000000000000

; 766  : }

	add	esp, 8
	ret	0
$L18657:
	DD	$L12253
	DD	$L12249
	DD	$L12250
	DD	$L12251
	DD	$L12253
	DD	$L12252
?asDouble@Value@Json@@QBENXZ ENDP			; Json::Value::asDouble
_TEXT	ENDS
PUBLIC	?asUInt@Value@Json@@QBEIXZ			; Json::Value::asUInt
EXTRN	__ftol2:NEAR
; Function compile flags: /Ogtpy
;	COMDAT ?asUInt@Value@Json@@QBEIXZ
_TEXT	SEGMENT
?asUInt@Value@Json@@QBEIXZ PROC NEAR			; Json::Value::asUInt, COMDAT
; _this$ = eax

; 719  :    switch ( type_ )

	movsx	ecx, BYTE PTR [eax+8]
	cmp	ecx, 5
	ja	SHORT $L12237
	jmp	DWORD PTR $L18662[ecx*4]
$L12231:

; 720  :    {
; 721  :    case nullValue:
; 722  :       return 0;
; 723  :    case intValue:
; 724  :       JSON_ASSERT( value_.int_ >= 0  &&  "Negative integer can not be converted to unsigned integer" );
; 725  :       return value_.int_;

	mov	eax, DWORD PTR [eax]

; 741  : }

	ret	0
$L12234:

; 726  :    case uintValue:
; 727  :       return value_.uint_;
; 728  :    case realValue:
; 729  :       JSON_ASSERT( value_.real_ >= 0  &&  value_.real_ <= maxUInt &&  "Real out of unsigned integer range" );
; 730  :       return UInt( value_.real_ );

	fld	QWORD PTR [eax]
	jmp	__ftol2
$L12236:

; 731  :    case booleanValue:
; 732  :       return value_.bool_ ? 1 : 0;

	mov	dl, BYTE PTR [eax]
	xor	ecx, ecx
	test	dl, dl
	setne	cl
	mov	eax, ecx

; 741  : }

	ret	0
$L12237:

; 733  :    case stringValue:
; 734  :    case arrayValue:
; 735  :    case objectValue:
; 736  :       JSON_ASSERT( "Type is not convertible to double" && false );
; 737  :    default:
; 738  :       JSON_ASSERT_UNREACHABLE;
; 739  :    }
; 740  :    return 0; // unreachable;

	xor	eax, eax

; 741  : }

	ret	0
	npad	3
$L18662:
	DD	$L12237
	DD	$L12231
	DD	$L12231
	DD	$L12234
	DD	$L12237
	DD	$L12236
?asUInt@Value@Json@@QBEIXZ ENDP				; Json::Value::asUInt
_TEXT	ENDS
PUBLIC	?asInt@Value@Json@@QBEHXZ			; Json::Value::asInt
; Function compile flags: /Ogtpy
;	COMDAT ?asInt@Value@Json@@QBEHXZ
_TEXT	SEGMENT
?asInt@Value@Json@@QBEHXZ PROC NEAR			; Json::Value::asInt, COMDAT
; _this$ = eax

; 692  :    switch ( type_ )

	movsx	ecx, BYTE PTR [eax+8]
	cmp	ecx, 5
	ja	SHORT $L12219
	jmp	DWORD PTR $L18666[ecx*4]
$L12213:

; 693  :    {
; 694  :    case nullValue:
; 695  :       return 0;
; 696  :    case intValue:
; 697  :       return value_.int_;

	mov	eax, DWORD PTR [eax]

; 714  : }

	ret	0
$L12216:

; 698  :    case uintValue:
; 699  :       JSON_ASSERT( value_.uint_ < maxInt  &&  "integer out of signed integer range" );
; 700  :       return value_.uint_;
; 701  :    case realValue:
; 702  :       JSON_ASSERT( value_.real_ >= minInt  &&  value_.real_ <= maxInt &&  "Real out of signed integer range" );
; 703  :       return Int( value_.real_ );

	fld	QWORD PTR [eax]
	jmp	__ftol2
$L12218:

; 704  :    case booleanValue:
; 705  :       return value_.bool_ ? 1 : 0;

	mov	dl, BYTE PTR [eax]
	xor	ecx, ecx
	test	dl, dl
	setne	cl
	mov	eax, ecx

; 714  : }

	ret	0
$L12219:

; 706  :    case stringValue:
; 707  :    case arrayValue:
; 708  :    case objectValue:
; 709  :       JSON_ASSERT( "Type is not convertible to double" && false );
; 710  :    default:
; 711  :       JSON_ASSERT_UNREACHABLE;
; 712  :    }
; 713  :    return 0; // unreachable;

	xor	eax, eax

; 714  : }

	ret	0
	npad	3
$L18666:
	DD	$L12219
	DD	$L12213
	DD	$L12213
	DD	$L12216
	DD	$L12219
	DD	$L12218
?asInt@Value@Json@@QBEHXZ ENDP				; Json::Value::asInt
_TEXT	ENDS
PUBLIC	?asCString@Value@Json@@QBEPBDXZ			; Json::Value::asCString
; Function compile flags: /Ogtpy
;	COMDAT ?asCString@Value@Json@@QBEPBDXZ
_TEXT	SEGMENT
?asCString@Value@Json@@QBEPBDXZ PROC NEAR		; Json::Value::asCString, COMDAT
; _this$ = eax

; 653  :    JSON_ASSERT( type_ == stringValue );
; 654  :    return value_.string_;

	mov	eax, DWORD PTR [eax]

; 655  : }

	ret	0
?asCString@Value@Json@@QBEPBDXZ ENDP			; Json::Value::asCString
_TEXT	ENDS
PUBLIC	?compare@Value@Json@@QAEHABV12@@Z		; Json::Value::compare
; Function compile flags: /Ogtpy
;	COMDAT ?compare@Value@Json@@QAEHABV12@@Z
_TEXT	SEGMENT
?compare@Value@Json@@QAEHABV12@@Z PROC NEAR		; Json::Value::compare, COMDAT

; 516  :    /*
; 517  :    int typeDelta = other.type_ - type_;
; 518  :    switch ( type_ )
; 519  :    {
; 520  :    case nullValue:
; 521  : 
; 522  :       return other.type_ == type_;
; 523  :    case intValue:
; 524  :       if ( other.type_.isNumeric()
; 525  :    case uintValue:
; 526  :    case realValue:
; 527  :    case booleanValue:
; 528  :       break;
; 529  :    case stringValue,
; 530  :       break;
; 531  :    case arrayValue:
; 532  :       delete value_.array_;
; 533  :       break;
; 534  :    case objectValue:
; 535  :       delete value_.map_;
; 536  :    default:
; 537  :       JSON_ASSERT_UNREACHABLE;
; 538  :    }
; 539  :    */
; 540  :    return 0;  // unreachable

	xor	eax, eax

; 541  : }

	ret	0
?compare@Value@Json@@QAEHABV12@@Z ENDP			; Json::Value::compare
_TEXT	ENDS
PUBLIC	?type@Value@Json@@QBE?AW4ValueType@2@XZ		; Json::Value::type
; Function compile flags: /Ogtpy
;	COMDAT ?type@Value@Json@@QBE?AW4ValueType@2@XZ
_TEXT	SEGMENT
?type@Value@Json@@QBE?AW4ValueType@2@XZ PROC NEAR	; Json::Value::type, COMDAT
; _this$ = eax

; 509  :    return type_;

	movsx	eax, BYTE PTR [eax+8]

; 510  : }

	ret	0
?type@Value@Json@@QBE?AW4ValueType@2@XZ ENDP		; Json::Value::type
_TEXT	ENDS
PUBLIC	?swap@Value@Json@@QAEXAAV12@@Z			; Json::Value::swap
; Function compile flags: /Ogtpy
;	COMDAT ?swap@Value@Json@@QAEXAAV12@@Z
_TEXT	SEGMENT
?swap@Value@Json@@QAEXAAV12@@Z PROC NEAR		; Json::Value::swap, COMDAT
; _this$ = edx
; _other$ = eax

; 497  :    ValueType temp = type_;

	movsx	ecx, BYTE PTR [edx+8]
	push	ebx

; 498  :    type_ = other.type_;

	mov	bl, BYTE PTR [eax+8]
	mov	BYTE PTR [edx+8], bl

; 499  :    other.type_ = temp;

	mov	BYTE PTR [eax+8], cl

; 500  :    std::swap( value_, other.value_ );

	mov	ecx, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [edx+4]
	push	edi
	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR [edx], edi
	mov	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+4], edi

; 501  :    int temp2 = allocated_;
; 502  :    allocated_ = other.allocated_;

	mov	edi, DWORD PTR [eax+8]
	mov	DWORD PTR [eax], ecx
	shl	edi, 23					; 00000017H
	sar	edi, 23					; 00000017H
	mov	DWORD PTR [eax+4], esi
	mov	esi, DWORD PTR [edx+8]
	xor	edi, esi
	mov	ecx, esi
	shl	ecx, 23					; 00000017H
	and	edi, 256				; 00000100H
	xor	edi, esi
	mov	DWORD PTR [edx+8], edi

; 503  :    other.allocated_ = temp2;

	mov	edi, DWORD PTR [eax+8]
	sar	ecx, 31					; 0000001fH
	shl	ecx, 8
	xor	ecx, edi
	mov	edx, edi
	pop	edi
	and	ecx, 256				; 00000100H
	xor	edx, ecx
	pop	esi
	mov	DWORD PTR [eax+8], edx
	pop	ebx

; 504  : }

	ret	0
?swap@Value@Json@@QAEXAAV12@@Z ENDP			; Json::Value::swap
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@_N@Z				; Json::Value::Value
; Function compile flags: /Ogtpy
;	COMDAT ??0Value@Json@@QAE@_N@Z
_TEXT	SEGMENT
??0Value@Json@@QAE@_N@Z PROC NEAR			; Json::Value::Value, COMDAT
; _this$ = eax
; _value$ = ecx

; 392  : {

	mov	BYTE PTR [eax+8], 5
	mov	DWORD PTR [eax+12], 0

; 393  :    value_.bool_ = value;

	mov	BYTE PTR [eax], cl

; 394  : }

	ret	0
??0Value@Json@@QAE@_N@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@N@Z				; Json::Value::Value
; Function compile flags: /Ogtpy
;	COMDAT ??0Value@Json@@QAE@N@Z
_TEXT	SEGMENT
_value$ = 8						; size = 8
??0Value@Json@@QAE@N@Z PROC NEAR			; Json::Value::Value, COMDAT
; _this$ = eax

; 334  :    value_.real_ = value;

	fld	QWORD PTR _value$[esp-4]
	mov	BYTE PTR [eax+8], 3
	fstp	QWORD PTR [eax]
	mov	DWORD PTR [eax+12], 0

; 335  : }

	ret	8
??0Value@Json@@QAE@N@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@I@Z				; Json::Value::Value
; Function compile flags: /Ogtpy
;	COMDAT ??0Value@Json@@QAE@I@Z
_TEXT	SEGMENT
??0Value@Json@@QAE@I@Z PROC NEAR			; Json::Value::Value, COMDAT
; _this$ = eax
; _value$ = ecx

; 323  : {

	mov	BYTE PTR [eax+8], 2
	mov	DWORD PTR [eax+12], 0

; 324  :    value_.uint_ = value;

	mov	DWORD PTR [eax], ecx

; 325  : }

	ret	0
??0Value@Json@@QAE@I@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@H@Z				; Json::Value::Value
; Function compile flags: /Ogtpy
;	COMDAT ??0Value@Json@@QAE@H@Z
_TEXT	SEGMENT
??0Value@Json@@QAE@H@Z PROC NEAR			; Json::Value::Value, COMDAT
; _this$ = eax
; _value$ = ecx

; 312  : {

	mov	BYTE PTR [eax+8], 1
	mov	DWORD PTR [eax+12], 0

; 313  :    value_.int_ = value;

	mov	DWORD PTR [eax], ecx

; 314  : }

	ret	0
??0Value@Json@@QAE@H@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	?isStaticString@CZString@Value@Json@@QBE_NXZ	; Json::Value::CZString::isStaticString
; Function compile flags: /Ogtpy
;	COMDAT ?isStaticString@CZString@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?isStaticString@CZString@Value@Json@@QBE_NXZ PROC NEAR	; Json::Value::CZString::isStaticString, COMDAT
; _this$ = ecx

; 244  :    return index_ == noDuplication;

	mov	edx, DWORD PTR [ecx+4]
	xor	eax, eax
	test	edx, edx
	sete	al

; 245  : }

	ret	0
?isStaticString@CZString@Value@Json@@QBE_NXZ ENDP	; Json::Value::CZString::isStaticString
_TEXT	ENDS
PUBLIC	?c_str@CZString@Value@Json@@QBEPBDXZ		; Json::Value::CZString::c_str
; Function compile flags: /Ogtpy
;	COMDAT ?c_str@CZString@Value@Json@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@CZString@Value@Json@@QBEPBDXZ PROC NEAR		; Json::Value::CZString::c_str, COMDAT
; _this$ = eax

; 238  :    return cstr_;

	mov	eax, DWORD PTR [eax]

; 239  : }

	ret	0
?c_str@CZString@Value@Json@@QBEPBDXZ ENDP		; Json::Value::CZString::c_str
_TEXT	ENDS
PUBLIC	?index@CZString@Value@Json@@QBEHXZ		; Json::Value::CZString::index
; Function compile flags: /Ogtpy
;	COMDAT ?index@CZString@Value@Json@@QBEHXZ
_TEXT	SEGMENT
?index@CZString@Value@Json@@QBEHXZ PROC NEAR		; Json::Value::CZString::index, COMDAT
; _this$ = eax

; 231  :    return index_;

	mov	eax, DWORD PTR [eax+4]

; 232  : }

	ret	0
?index@CZString@Value@Json@@QBEHXZ ENDP			; Json::Value::CZString::index
_TEXT	ENDS
PUBLIC	??8CZString@Value@Json@@QBE_NABV012@@Z		; Json::Value::CZString::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8CZString@Value@Json@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8CZString@Value@Json@@QBE_NABV012@@Z PROC NEAR	; Json::Value::CZString::operator==, COMDAT
; _this$ = edx
; _other$ = ecx

; 222  :    if ( cstr_ )

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	push	esi
	je	SHORT $L11971

; 223  :       return strcmp( cstr_, other.cstr_ ) == 0;

	mov	esi, DWORD PTR [ecx]
	push	ebx
	npad	6
$L18707:
	mov	dl, BYTE PTR [eax]
	mov	bl, BYTE PTR [esi]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L18708
	test	cl, cl
	je	SHORT $L18709
	mov	dl, BYTE PTR [eax+1]
	mov	bl, BYTE PTR [esi+1]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L18708
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L18707
$L18709:
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	pop	ebx
	mov	al, cl
	pop	esi

; 225  : }

	ret	0
$L18708:

; 223  :       return strcmp( cstr_, other.cstr_ ) == 0;

	sbb	eax, eax
	sbb	eax, -1
	xor	ecx, ecx
	test	eax, eax
	sete	cl
	pop	ebx
	mov	al, cl
	pop	esi

; 225  : }

	ret	0
$L11971:

; 224  :    return index_ == other.index_;

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, esi
	neg	eax
	sbb	eax, eax
	inc	eax
	pop	esi

; 225  : }

	ret	0
??8CZString@Value@Json@@QBE_NABV012@@Z ENDP		; Json::Value::CZString::operator==
_TEXT	ENDS
PUBLIC	??MCZString@Value@Json@@QBE_NABV012@@Z		; Json::Value::CZString::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MCZString@Value@Json@@QBE_NABV012@@Z
_TEXT	SEGMENT
??MCZString@Value@Json@@QBE_NABV012@@Z PROC NEAR	; Json::Value::CZString::operator<, COMDAT
; _this$ = edx
; _other$ = ecx

; 214  :    if ( cstr_ )

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	push	esi
	je	SHORT $L11966

; 215  :       return strcmp( cstr_, other.cstr_ ) < 0;

	mov	esi, DWORD PTR [ecx]
	push	ebx
	npad	6
$L18714:
	mov	dl, BYTE PTR [eax]
	mov	bl, BYTE PTR [esi]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L18715
	test	cl, cl
	je	SHORT $L18716
	mov	dl, BYTE PTR [eax+1]
	mov	bl, BYTE PTR [esi+1]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L18715
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L18714
$L18716:
	xor	eax, eax
	xor	ecx, ecx
	test	eax, eax
	setl	cl
	pop	ebx
	mov	al, cl
	pop	esi

; 217  : }

	ret	0
$L18715:

; 215  :       return strcmp( cstr_, other.cstr_ ) < 0;

	sbb	eax, eax
	sbb	eax, -1
	xor	ecx, ecx
	test	eax, eax
	setl	cl
	pop	ebx
	mov	al, cl
	pop	esi

; 217  : }

	ret	0
$L11966:

; 216  :    return index_ < other.index_;

	mov	esi, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx+4]
	xor	eax, eax
	cmp	edx, esi
	setl	al
	pop	esi

; 217  : }

	ret	0
??MCZString@Value@Json@@QBE_NABV012@@Z ENDP		; Json::Value::CZString::operator<
_TEXT	ENDS
PUBLIC	?swap@CZString@Value@Json@@AAEXAAV123@@Z	; Json::Value::CZString::swap
; Function compile flags: /Ogtpy
;	COMDAT ?swap@CZString@Value@Json@@AAEXAAV123@@Z
_TEXT	SEGMENT
?swap@CZString@Value@Json@@AAEXAAV123@@Z PROC NEAR	; Json::Value::CZString::swap, COMDAT
; _this$ = ecx
; _other$ = eax

; 199  :    std::swap( cstr_, other.cstr_ );

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR [ecx], esi
	mov	DWORD PTR [eax], edx

; 200  :    std::swap( index_, other.index_ );

	mov	esi, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+4], esi
	mov	DWORD PTR [eax+4], edx
	pop	esi

; 201  : }

	ret	0
?swap@CZString@Value@Json@@AAEXAAV123@@Z ENDP		; Json::Value::CZString::swap
_TEXT	ENDS
PUBLIC	??0CZString@Value@Json@@QAE@H@Z			; Json::Value::CZString::CZString
; Function compile flags: /Ogtpy
;	COMDAT ??0CZString@Value@Json@@QAE@H@Z
_TEXT	SEGMENT
??0CZString@Value@Json@@QAE@H@Z PROC NEAR		; Json::Value::CZString::CZString, COMDAT
; _this$ = eax
; _index$ = ecx

; 171  : {

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], ecx

; 172  : }

	ret	0
??0CZString@Value@Json@@QAE@H@Z ENDP			; Json::Value::CZString::CZString
_TEXT	ENDS
PUBLIC	??0CommentInfo@Value@Json@@QAE@XZ		; Json::Value::CommentInfo::CommentInfo
; Function compile flags: /Ogtpy
;	COMDAT ??0CommentInfo@Value@Json@@QAE@XZ
_TEXT	SEGMENT
??0CommentInfo@Value@Json@@QAE@XZ PROC NEAR		; Json::Value::CommentInfo::CommentInfo, COMDAT
; _this$ = ecx

; 137  : {

	mov	eax, ecx
	mov	DWORD PTR [eax], 0

; 138  : }

	ret	0
??0CommentInfo@Value@Json@@QAE@XZ ENDP			; Json::Value::CommentInfo::CommentInfo
_TEXT	ENDS
PUBLIC	??0ValueIterator@Json@@QAE@ABV01@@Z		; Json::ValueIterator::ValueIterator
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_valueiterator.inl
;	COMDAT ??0ValueIterator@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0ValueIterator@Json@@QAE@ABV01@@Z PROC NEAR		; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = eax
; _other$ = ecx

; 249  : {

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 250  : }

	ret	0
??0ValueIterator@Json@@QAE@ABV01@@Z ENDP		; Json::ValueIterator::ValueIterator
_TEXT	ENDS
PUBLIC	??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z ; Json::ValueIterator::ValueIterator
; Function compile flags: /Ogtpy
;	COMDAT ??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z
_TEXT	SEGMENT
??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z PROC NEAR ; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = eax
; _other$ = ecx

; 244  : {

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 245  : }

	ret	0
??0ValueIterator@Json@@QAE@ABVValueConstIterator@1@@Z ENDP ; Json::ValueIterator::ValueIterator
_TEXT	ENDS
PUBLIC	?memberName@ValueIteratorBase@Json@@QBEPBDXZ	; Json::ValueIteratorBase::memberName
; Function compile flags: /Ogtpy
;	COMDAT ?memberName@ValueIteratorBase@Json@@QBEPBDXZ
_TEXT	SEGMENT
?memberName@ValueIteratorBase@Json@@QBEPBDXZ PROC NEAR	; Json::ValueIteratorBase::memberName, COMDAT
; _this$ = eax

; 163  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 164  :    const char *name = (*current_).first.c_str();

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx+16]

; 165  :    return name ? name : "";

	test	eax, eax
	jne	SHORT $L18747
	mov	eax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
$L18747:

; 166  : #else
; 167  :    if ( !isArray_ )
; 168  :       return ValueInternalMap::key( iterator_.map_ );
; 169  :    return "";
; 170  : #endif
; 171  : }

	ret	0
?memberName@ValueIteratorBase@Json@@QBEPBDXZ ENDP	; Json::ValueIteratorBase::memberName
_TEXT	ENDS
PUBLIC	?copy@ValueIteratorBase@Json@@IAEXABV12@@Z	; Json::ValueIteratorBase::copy
; Function compile flags: /Ogtpy
;	COMDAT ?copy@ValueIteratorBase@Json@@IAEXABV12@@Z
_TEXT	SEGMENT
?copy@ValueIteratorBase@Json@@IAEXABV12@@Z PROC NEAR	; Json::ValueIteratorBase::copy, COMDAT
; _this$ = edx
; _other$ = eax

; 110  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 111  :    current_ = other.current_;

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx

; 112  : #else
; 113  :    if ( isArray_ )
; 114  :       iterator_.array_ = other.iterator_.array_;
; 115  :    iterator_.map_ = other.iterator_.map_;
; 116  : #endif
; 117  : }

	ret	0
?copy@ValueIteratorBase@Json@@IAEXABV12@@Z ENDP		; Json::ValueIteratorBase::copy
_TEXT	ENDS
PUBLIC	?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z	; Json::ValueIteratorBase::isEqual
; Function compile flags: /Ogtpy
;	COMDAT ?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z
_TEXT	SEGMENT
?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z PROC NEAR ; Json::ValueIteratorBase::isEqual, COMDAT
; _this$ = eax
; _other$ = ecx

; 97   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 98   :    return current_ == other.current_;

	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [ecx]
	neg	eax
	sbb	eax, eax
	inc	eax

; 99   : #else
; 100  :    if ( isArray_ )
; 101  :       return ValueInternalArray::equals( iterator_.array_, other.iterator_.array_ );
; 102  :    return ValueInternalMap::equals( iterator_.map_, other.iterator_.map_ );
; 103  : #endif
; 104  : }

	ret	0
?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z ENDP	; Json::ValueIteratorBase::isEqual
_TEXT	ENDS
PUBLIC	??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueIteratorBase::ValueIteratorBase
; Function compile flags: /Ogtpy
;	COMDAT ??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z
_TEXT	SEGMENT
??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z PROC NEAR ; Json::ValueIteratorBase::ValueIteratorBase, COMDAT
; _this$ = eax
; _current$ = ecx

; 21   : {

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 22   : }

	ret	0
??0ValueIteratorBase@Json@@QAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ENDP ; Json::ValueIteratorBase::ValueIteratorBase
_TEXT	ENDS
PUBLIC	??0ValueIteratorBase@Json@@QAE@XZ		; Json::ValueIteratorBase::ValueIteratorBase
; Function compile flags: /Ogtpy
;	COMDAT ??0ValueIteratorBase@Json@@QAE@XZ
_TEXT	SEGMENT
??0ValueIteratorBase@Json@@QAE@XZ PROC NEAR		; Json::ValueIteratorBase::ValueIteratorBase, COMDAT
; _this$ = eax

; 14   : {

	mov	DWORD PTR [eax], 0

; 15   : }

	ret	0
??0ValueIteratorBase@Json@@QAE@XZ ENDP			; Json::ValueIteratorBase::ValueIteratorBase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0ValueAllocator@Json@@QAE@XZ
_TEXT	SEGMENT
??0ValueAllocator@Json@@QAE@XZ PROC NEAR		; Json::ValueAllocator::ValueAllocator, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], OFFSET FLAT:??_7ValueAllocator@Json@@6B@
	ret	0
??0ValueAllocator@Json@@QAE@XZ ENDP			; Json::ValueAllocator::ValueAllocator
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
_TEXT	ENDS
;	COMDAT ?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z PROC NEAR ; Json::DefaultValueAllocator::releaseStringValue, COMDAT
; _this$ = ecx

; 90   :       if ( value )

	mov	eax, DWORD PTR _value$[esp-4]
	test	eax, eax
	je	SHORT $L11756

; 91   :          free( value );

	push	eax
	call	_free
	pop	ecx
$L11756:

; 92   :    }

	ret	4
?releaseStringValue@DefaultValueAllocator@Json@@UAEXPAD@Z ENDP ; Json::DefaultValueAllocator::releaseStringValue
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
_length$ = 12						; size = 4
?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z PROC NEAR ; Json::DefaultValueAllocator::duplicateStringValue, COMDAT
; _this$ = ecx

; 75   :    {

	push	ebx

; 76   :       //@todo invesgate this old optimization
; 77   :       //if ( !value  ||  value[0] == 0 )
; 78   :       //   return 0;
; 79   : 
; 80   :       if ( length == unknown )

	mov	ebx, DWORD PTR _length$[esp]
	cmp	ebx, -1
	push	esi
	mov	esi, DWORD PTR _value$[esp+4]
	push	edi
	jne	SHORT $L11750

; 81   :          length = (unsigned int)strlen(value);

	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$L18798:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $L18798
	sub	eax, edx
	mov	ebx, eax
$L11750:

; 82   :       char *newString = static_cast<char *>( malloc( length + 1 ) );

	lea	eax, DWORD PTR [ebx+1]
	push	eax
	call	_malloc

; 83   :       memcpy( newString, value, length );

	mov	ecx, ebx
	mov	edx, ecx
	shr	ecx, 2
	mov	edi, eax
	rep movsd
	mov	ecx, edx
	add	esp, 4
	and	ecx, 3
	rep movsb
	pop	edi
	pop	esi

; 84   :       newString[length] = 0;

	mov	BYTE PTR [eax+ebx], 0
	pop	ebx

; 85   :       return newString;
; 86   :    }

	ret	8
?duplicateStringValue@DefaultValueAllocator@Json@@UAEPADPBDI@Z ENDP ; Json::DefaultValueAllocator::duplicateStringValue
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z
_TEXT	SEGMENT
_memberName$ = 8					; size = 4
?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z PROC NEAR ; Json::DefaultValueAllocator::releaseMemberName, COMDAT
; _this$ = ecx

; 70   :       releaseStringValue( memberName );

	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+16]
?releaseMemberName@DefaultValueAllocator@Json@@UAEXPAD@Z ENDP ; Json::DefaultValueAllocator::releaseMemberName
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z
_TEXT	SEGMENT
_memberName$ = 8					; size = 4
?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z PROC NEAR ; Json::DefaultValueAllocator::makeMemberName, COMDAT
; _this$ = ecx

; 65   :       return duplicateStringValue( memberName );

	mov	edx, DWORD PTR _memberName$[esp-4]
	mov	eax, DWORD PTR [ecx]
	push	-1
	push	edx
	call	DWORD PTR [eax+12]

; 66   :    }

	ret	4
?makeMemberName@DefaultValueAllocator@Json@@UAEPADPBD@Z ENDP ; Json::DefaultValueAllocator::makeMemberName
_TEXT	ENDS
PUBLIC	??1ValueAllocator@Json@@UAE@XZ			; Json::ValueAllocator::~ValueAllocator
; Function compile flags: /Ogtpy
;	COMDAT ??1ValueAllocator@Json@@UAE@XZ
_TEXT	SEGMENT
??1ValueAllocator@Json@@UAE@XZ PROC NEAR		; Json::ValueAllocator::~ValueAllocator, COMDAT
; _this$ = ecx

; 53   : {

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7ValueAllocator@Json@@6B@

; 54   : }

	ret	0
??1ValueAllocator@Json@@UAE@XZ ENDP			; Json::ValueAllocator::~ValueAllocator
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\include\json\value.h
_TEXT	ENDS
;	COMDAT ?c_str@StaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@StaticString@Json@@QBEPBDXZ PROC NEAR		; Json::StaticString::c_str, COMDAT
; _this$ = eax

; 77   :          return str_;

	mov	eax, DWORD PTR [eax]

; 78   :       }

	ret	0
?c_str@StaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::c_str
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??BStaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
??BStaticString@Json@@QBEPBDXZ PROC NEAR		; Json::StaticString::operator char const *, COMDAT
; _this$ = eax

; 72   :          return str_;

	mov	eax, DWORD PTR [eax]

; 73   :       }

	ret	0
??BStaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::operator char const *
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0StaticString@Json@@QAE@PBD@Z
_TEXT	SEGMENT
??0StaticString@Json@@QAE@PBD@Z PROC NEAR		; Json::StaticString::StaticString, COMDAT
; _this$ = eax
; _czstring$ = ecx

; 67   :       {

	mov	DWORD PTR [eax], ecx

; 68   :       }

	ret	0
??0StaticString@Json@@QAE@PBD@Z ENDP			; Json::StaticString::StaticString
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
;	COMDAT ??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*, COMDAT
; _this$ = eax

; 220  : 			return ((reference)**(const_iterator *)this);

	mov	eax, DWORD PTR [eax]

; 221  : 			}

	ret	0
??Diterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Uninitialized_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >, COMDAT
; __First$ = ecx
; __Last$ = eax

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

	sub	eax, ecx
	push	esi
	sar	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Dest$[esp]
	push	esi
	push	ecx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi

; 129  : 	}

	ret	0
??$_Uninitialized_copy@PAPBVPathArgument@Json@@PAPBV12@V?$allocator@PBVPathArgument@Json@@@std@@@std@@YAPAPBVPathArgument@Json@@PAPBV12@00AAV?$allocator@PBVPathArgument@Json@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::PathArgument const * *,Json::PathArgument const * *,std::allocator<Json::PathArgument const *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost, COMDAT
; _this$ = eax

; 1010 : 		return (_Left(_Myhead));

	mov	eax, DWORD PTR [eax+4]

; 1011 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 423  : 		return (_TREE_CONST_ITERATOR(_Myhead));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 424  : 		}

	ret	0
?end@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 413  : 		return (_TREE_CONST_ITERATOR(_Lmost()));

	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [eax], ecx

; 414  : 		}

	ret	0
?begin@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@ABQAU120@@Z
_TEXT	SEGMENT
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@ABQAU120@@Z PROC NEAR ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

	test	eax, eax
	je	SHORT $L19947
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$L19947:

; 43   : 	}

	ret	0
??$_Construct@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@PAU123@@std@@YAXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@ABQAU120@@Z ENDP ; std::_Construct<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *,std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Ucopy@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ucopy<Json::PathArgument const * *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

	sub	eax, ecx
	push	esi
	sar	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Ptr$[esp]
	push	esi
	push	ecx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi

; 805  : 		}

	ret	4
??$_Ucopy@PAPBVPathArgument@Json@@@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV23@00@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ucopy<Json::PathArgument const * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z PROC NEAR ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $L19987
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$L19987:

; 148  : 		}

	ret	0
?construct@?$allocator@PAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@QAEXPAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABQAU342@@Z ENDP ; std::allocator<std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node *>::construct
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator, COMDAT
; _this$ = eax
; __Ptr$ = ecx

; 215  : 			{	// construct with pointer _Ptr

	mov	DWORD PTR [eax], ecx

; 216  : 			}

	ret	0
??0iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator::iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@@Z
_TEXT	SEGMENT
??0iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::iterator, COMDAT
; _this$ = eax
; __Ptr$ = ecx

; 215  : 			{	// construct with pointer _Ptr

	mov	DWORD PTR [eax], ecx

; 216  : 			}

	ret	0
??0iterator@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::iterator::iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@@Z
_TEXT	SEGMENT
??0iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::iterator, COMDAT
; _this$ = eax
; __Ptr$ = ecx

; 215  : 			{	// construct with pointer _Ptr

	mov	DWORD PTR [eax], ecx

; 216  : 			}

	ret	0
??0iterator@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@PAPBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::iterator::iterator
_TEXT	ENDS
EXTRN	__CxxThrowException@8:NEAR
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode, COMDAT

; 1106 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 1107 : 		int _Linkcnt = 0;
; 1108 : 
; 1109 : 		_TRY_BEGIN
; 1110 : 		this->_Alptr.construct(&_Left(_Wherenode), 0);

	test	eax, eax
	je	SHORT $L20048
	mov	DWORD PTR [eax], 0
$L20048:

; 1111 : 		++_Linkcnt;
; 1112 : 		this->_Alptr.construct(&_Parent(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $L20075
	mov	DWORD PTR [ecx], 0
$L20075:

; 1113 : 		++_Linkcnt;
; 1114 : 		this->_Alptr.construct(&_Right(_Wherenode), 0);

	lea	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $L20102
	mov	DWORD PTR [ecx], 0
$L20102:

; 1115 : 		_CATCH_ALL
; 1116 : 		if (1 < _Linkcnt)
; 1117 : 			this->_Alptr.destroy(&_Parent(_Wherenode));
; 1118 : 		if (0 < _Linkcnt)
; 1119 : 			this->_Alptr.destroy(&_Left(_Wherenode));
; 1120 : 		this->_Alnod.deallocate(_Wherenode, 1);
; 1121 : 		_RERAISE;
; 1122 : 		_CATCH_END
; 1123 : 		_Color(_Wherenode) = _Black;

	mov	BYTE PTR [eax+40], 1

; 1124 : 		_Isnil(_Wherenode) = false;

	mov	BYTE PTR [eax+41], 0

; 1125 : 		return (_Wherenode);
; 1126 : 		}

	ret	0
?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate, COMDAT
; __Wherenode$ = ecx

; 1069 : 		_Nodeptr _Pnode = _Left(_Wherenode);

	mov	eax, DWORD PTR [ecx]

; 1070 : 		_Left(_Wherenode) = _Right(_Pnode);

	mov	edx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx], edx

; 1071 : 
; 1072 : 		if (!_Isnil(_Right(_Pnode)))

	mov	edx, DWORD PTR [eax+8]
	push	ebx
	mov	bl, BYTE PTR [edx+41]
	test	bl, bl
	jne	SHORT $L14865

; 1073 : 			_Parent(_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [edx+4], ecx
$L14865:

; 1074 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1075 : 
; 1076 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[esp]
	mov	edx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $L14866

; 1077 : 			_Root() = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax
	pop	ebx

; 1085 : 		}

	ret	4
$L14866:

; 1078 : 		else if (_Wherenode == _Right(_Parent(_Wherenode)))

	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx+8]
	jne	SHORT $L14868

; 1079 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx+8], eax

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax
	pop	ebx

; 1085 : 		}

	ret	4
$L14868:

; 1080 : 		else
; 1081 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx], eax

; 1082 : 
; 1083 : 		_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax+8], ecx

; 1084 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax
	pop	ebx

; 1085 : 		}

	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root, COMDAT
; _this$ = eax

; 1064 : 		return (_Parent(_Myhead));

	mov	eax, DWORD PTR [eax+4]
	add	eax, 4

; 1065 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Root
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Min, COMDAT
; __Pnode$ = eax

; 1042 : 		while (!_Isnil(_Left(_Pnode)))

	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+41]
	test	dl, dl
	jne	SHORT $L14859
	npad	7
$L14858:

; 1043 : 			_Pnode = _Left(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	dl, BYTE PTR [ecx+41]
	test	dl, dl
	je	SHORT $L14858
$L14859:

; 1044 : 		return (_Pnode);
; 1045 : 		}

	ret	0
?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Min
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z
_TEXT	SEGMENT
?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Max, COMDAT
; __Pnode$ = eax

; 1035 : 		while (!_Isnil(_Right(_Pnode)))

	mov	ecx, DWORD PTR [eax+8]
	mov	dl, BYTE PTR [ecx+41]
	test	dl, dl
	jne	SHORT $L14855
	npad	6
$L14854:

; 1036 : 			_Pnode = _Right(_Pnode);

	mov	eax, ecx
	mov	ecx, DWORD PTR [eax+8]
	mov	dl, BYTE PTR [ecx+41]
	test	dl, dl
	je	SHORT $L14854
$L14855:

; 1037 : 		return (_Pnode);
; 1038 : 		}

	ret	0
?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Max
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate, COMDAT
; __Wherenode$ = ecx

; 1015 : 		_Nodeptr _Pnode = _Right(_Wherenode);

	mov	eax, DWORD PTR [ecx+8]

; 1016 : 		_Right(_Wherenode) = _Left(_Pnode);

	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+8], edx

; 1017 : 
; 1018 : 		if (!_Isnil(_Left(_Pnode)))

	mov	edx, DWORD PTR [eax]
	push	ebx
	mov	bl, BYTE PTR [edx+41]
	test	bl, bl
	jne	SHORT $L14847

; 1019 : 			_Parent(_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [edx+4], ecx
$L14847:

; 1020 : 		_Parent(_Pnode) = _Parent(_Wherenode);

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 1021 : 
; 1022 : 		if (_Wherenode == _Root())

	mov	edx, DWORD PTR _this$[esp]
	mov	edx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [edx+4]
	jne	SHORT $L14848

; 1023 : 			_Root() = _Pnode;

	mov	DWORD PTR [edx+4], eax

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax
	pop	ebx

; 1031 : 		}

	ret	4
$L14848:

; 1024 : 		else if (_Wherenode == _Left(_Parent(_Wherenode)))

	mov	edx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edx]
	jne	SHORT $L14850

; 1025 : 			_Left(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx], eax

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax
	pop	ebx

; 1031 : 		}

	ret	4
$L14850:

; 1026 : 		else
; 1027 : 			_Right(_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [edx+8], eax

; 1028 : 
; 1029 : 		_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [eax], ecx

; 1030 : 		_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], eax
	pop	ebx

; 1031 : 		}

	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 463  : 		return (iterator(_Myfirst));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 464  : 		}

	ret	0
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 463  : 		return (iterator(_Myfirst));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 464  : 		}

	ret	0
?begin@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 473  : 		return (iterator(_Mylast));

	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 474  : 		}

	ret	0
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 463  : 		return (iterator(_Myfirst));

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 464  : 		}

	ret	0
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc, COMDAT
; _this$ = edx

; 268  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	jne	SHORT $L14475

; 269  : 				;	// end() shouldn't be incremented, don't move
; 270  : 			else if (!_Isnil(_Right(_Ptr)))

	mov	ecx, DWORD PTR [eax+8]
	push	ebx
	mov	bl, BYTE PTR [ecx+41]
	test	bl, bl
	jne	SHORT $L20401

; 271  : 				_Ptr = _Min(_Right(_Ptr));	// ==> smallest of right subtree

	mov	eax, DWORD PTR [ecx]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	jne	SHORT $L20382
	npad	3
$L20381:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	je	SHORT $L20381
$L20382:
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 279  : 				}
; 280  : 			}

	ret	0
$L20401:

; 272  : 			else
; 273  : 				{	// climb looking for right subtree
; 274  : 				_Nodeptr _Pnode;
; 275  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 276  : 					&& _Ptr == _Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	jne	SHORT $L14479
	npad	7
$L14478:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $L14479

; 277  : 					_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	je	SHORT $L14478
$L14479:

; 278  : 				_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [edx], eax
	pop	ebx
$L14475:

; 279  : 				}
; 280  : 			}

	ret	0
?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec, COMDAT
; _this$ = edx

; 251  : 			if (_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	je	SHORT $L14461

; 252  : 				_Ptr = _Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], eax

; 263  : 				}
; 264  : 			}

	ret	0
$L14461:

; 253  : 			else if (!_Isnil(_Left(_Ptr)))

	mov	ecx, DWORD PTR [eax]
	push	ebx
	mov	bl, BYTE PTR [ecx+41]
	test	bl, bl
	jne	SHORT $L20459

; 254  : 				_Ptr = _Max(_Left(_Ptr));	// ==> largest of left subtree

	mov	eax, DWORD PTR [ecx+8]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	jne	SHORT $L20437
$L20436:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	je	SHORT $L20436
$L20437:
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 263  : 				}
; 264  : 			}

	ret	0
$L20459:

; 255  : 			else
; 256  : 				{	// climb looking for left subtree
; 257  : 				_Nodeptr _Pnode;
; 258  : 				while (!_Isnil(_Pnode = _Parent(_Ptr))
; 259  : 					&& _Ptr == _Left(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	jne	SHORT $L20462
	npad	3
$L14467:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $L14468

; 260  : 					_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	je	SHORT $L14467
$L14468:

; 261  : 				if (!_Isnil(_Pnode))

	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	jne	SHORT $L20462

; 262  : 					_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], eax
$L20462:
	pop	ebx

; 263  : 				}
; 264  : 			}

	ret	0
?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\functional
_TEXT	ENDS
;	COMDAT ??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z
_TEXT	SEGMENT
??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z PROC NEAR ; std::less<Json::Value::CZString>::operator(), COMDAT
; __Left$ = edx
; __Right$ = ecx

; 139  : 		return (_Left < _Right);

	jmp	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
??R?$less@VCZString@Value@Json@@@std@@QBE_NABVCZString@Value@Json@@0@Z ENDP ; std::less<Json::Value::CZString>::operator()
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost, COMDAT
; _this$ = eax

; 1049 : 		return (_Right(_Myhead));

	mov	eax, DWORD PTR [eax+4]
	add	eax, 8

; 1050 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEAAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rmost
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound, COMDAT
; _this$ = eax

; 988  : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [eax+4]
	push	ebp
	mov	ebp, DWORD PTR __Keyval$[esp]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 989  : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 990  : 
; 991  : 		while (!_Isnil(_Pnode))

	mov	cl, BYTE PTR [edi+41]
	test	cl, cl
	jne	SHORT $L14433
	push	ebx
	push	esi
$L14432:

; 992  : 			if (this->comp(_Key(_Pnode), _Keyval))

	mov	ecx, DWORD PTR [edi+16]
	test	ecx, ecx
	je	SHORT $L20510
	mov	esi, DWORD PTR [ebp]
	npad	1
$L20520:
	mov	bl, BYTE PTR [ecx]
	mov	dl, bl
	cmp	bl, BYTE PTR [esi]
	jne	SHORT $L20521
	test	dl, dl
	je	SHORT $L20522
	mov	bl, BYTE PTR [ecx+1]
	mov	dl, bl
	cmp	bl, BYTE PTR [esi+1]
	jne	SHORT $L20521
	add	ecx, 2
	add	esi, 2
	test	dl, dl
	jne	SHORT $L20520
$L20522:
	xor	ecx, ecx
	test	ecx, ecx
	jmp	SHORT $L20525
$L20521:
	sbb	ecx, ecx
	sbb	ecx, -1
	test	ecx, ecx
	jmp	SHORT $L20525
$L20510:
	mov	ecx, DWORD PTR [edi+20]
	cmp	ecx, DWORD PTR [ebp+4]
$L20525:
	setl	cl
	test	cl, cl
	je	SHORT $L14434

; 993  : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	edi, DWORD PTR [edi+8]

; 994  : 			else

	jmp	SHORT $L14435
$L14434:

; 995  : 				{	// _Pnode not less than _Keyval, remember it
; 996  : 				_Wherenode = _Pnode;

	mov	eax, edi

; 997  : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	edi, DWORD PTR [edi]
$L14435:
	mov	cl, BYTE PTR [edi+41]
	test	cl, cl
	je	SHORT $L14432
	pop	esi
	pop	ebx
$L14433:
	pop	edi
	pop	ebp

; 998  : 				}
; 999  : 
; 1000 : 		return (_Wherenode);	// return best remembered candidate
; 1001 : 		}

	ret	4
?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Init, COMDAT
; _this$ = esi

; 902  : 		_Myhead = _Buynode();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax

; 903  : 		_Isnil(_Myhead) = true;

	mov	BYTE PTR [eax+41], 1

; 904  : 		_Root() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 905  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 906  : 		_Mysize = 0;

	mov	DWORD PTR [esi+8], 0

; 907  : 		}

	ret	0
?_Init@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Init
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 890  : 		{	// free entire subtree, recursively

	push	ebx
	push	esi
	push	edi

; 891  : 		for (_Nodeptr _Pnode = _Rootnode; !_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, DWORD PTR __Rootnode$[esp+8]
	mov	al, BYTE PTR [edi+41]
	test	al, al
	mov	ebx, ecx
	mov	esi, edi
	jne	SHORT $L14387
$L14385:

; 892  : 			{	// free subtrees, then node
; 893  : 			_Erase(_Right(_Pnode));

	mov	eax, DWORD PTR [esi+8]
	push	eax
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase

; 894  : 			_Pnode = _Left(_Pnode);

	mov	esi, DWORD PTR [esi]

; 895  : 			this->_Alnod.destroy(_Rootnode);	// destroy, free erased node

	mov	ecx, edi
	call	??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ

; 896  : 			this->_Alnod.deallocate(_Rootnode, 1);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	mov	al, BYTE PTR [esi+41]
	add	esp, 4
	test	al, al
	mov	edi, esi
	je	SHORT $L14385
$L14387:
	pop	edi
	pop	esi
	pop	ebx

; 897  : 			}
; 898  : 		}

	ret	4
?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z
_TEXT	SEGMENT
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = esi

; 362  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+41], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 363  : 		}

	mov	eax, esi
	ret	0
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABU?$less@VCZString@Value@Json@@@1@ABV?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 473  : 		return (iterator(_Mylast));

	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 474  : 		}

	ret	0
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 473  : 		return (iterator(_Mylast));

	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx

; 474  : 		}

	ret	0
?end@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::end
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=, COMDAT
; _this$ = eax
; __Right$ = edx

; 246  : 			return (!(*this == _Right));

	mov	ecx, DWORD PTR [eax]
	push	esi
	mov	esi, DWORD PTR [edx]
	xor	eax, eax
	cmp	ecx, esi
	setne	al
	pop	esi

; 247  : 			}

	ret	0
??9const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NABV012@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator--, COMDAT
; _this$ = esi

; 228  : 			_Dec();

	mov	edx, esi
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec

; 229  : 			return (*this);

	mov	eax, esi

; 230  : 			}

	ret	0
??Fconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++, COMDAT
; _this$ = esi

; 215  : 			_Inc();

	mov	edx, esi
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc

; 216  : 			return (*this);

	mov	eax, esi

; 217  : 			}

	ret	0
??Econst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator--, COMDAT
; _this$ = esi

; 340  : 			--(*(const_iterator *)this);

	mov	edx, esi
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec

; 341  : 			return (*this);

	mov	eax, esi

; 342  : 			}

	ret	0
??Fiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator--
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++, COMDAT
; _this$ = esi

; 327  : 			++(*(const_iterator *)this);

	mov	edx, esi
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc

; 328  : 			return (*this);

	mov	eax, esi

; 329  : 			}

	ret	0
??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEAAV012@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ
_TEXT	SEGMENT
??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator->, COMDAT
; _this$ = eax

; 322  : 			return (&**this);

	mov	eax, DWORD PTR [eax]
	add	eax, 16					; 00000010H

; 323  : 			}

	ret	0
??Citerator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBEPAU?$pair@$$CBVCZString@Value@Json@@V23@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator->
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound, COMDAT
; ___$ReturnUdt$ = esi
; __Keyval$ = eax

; 810  : 		return (_TREE_ITERATOR(_Lbound(_Keyval)));

	push	eax
	mov	eax, DWORD PTR _this$[esp]
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
	mov	DWORD PTR [esi], eax
	mov	eax, esi

; 811  : 		}

	ret	4
?lower_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::lower_bound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
__Where$ = -8						; size = 4
$T20793 = -4						; size = 4
?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = ebx
; __Keyval$ = edi

; 787  : 		{	// find an element in mutable sequence that matches _Keyval

	sub	esp, 8
	push	esi

; 788  : 		iterator _Where = lower_bound(_Keyval);

	push	edi
	mov	esi, eax
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

	mov	esi, DWORD PTR [esi+4]
	cmp	eax, esi
	mov	DWORD PTR __Where$[esp+12], eax
	je	SHORT $L20792
	lea	ecx, DWORD PTR [eax+16]
	mov	edx, edi
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	jne	SHORT $L20792
	lea	eax, DWORD PTR __Where$[esp+12]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx], eax
	mov	eax, ebx
	pop	esi

; 791  : 		}

	add	esp, 8
	ret	0
$L20792:

; 789  : 		return (_Where == end() || this->comp(_Keyval, _Key(_Where._Mynode()))
; 790  : 			? end() : _Where);

	mov	DWORD PTR $T20793[esp+12], esi
	lea	eax, DWORD PTR $T20793[esp+12]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ebx], eax
	mov	eax, ebx
	pop	esi

; 791  : 		}

	add	esp, 8
	ret	0
?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear, COMDAT
; _this$ = eax

; 780  : 		{	// erase all

	push	esi
	mov	esi, eax

; 781  : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase

; 782  : 		_Root() = _Myhead, _Mysize = 0;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax

; 783  : 		_Lmost() = _Myhead, _Rmost() = _Myhead;

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi

; 784  : 		}

	ret	0
?clear@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty, COMDAT
; _this$ = ecx

; 458  : 		return (size() == 0);

	mov	edx, DWORD PTR [ecx+8]
	xor	eax, eax
	test	edx, edx
	sete	al

; 459  : 		}

	ret	0
?empty@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QBE_NXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::empty
_TEXT	ENDS
PUBLIC	?isNumeric@Value@Json@@QBE_NXZ			; Json::Value::isNumeric
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
;	COMDAT ?isNumeric@Value@Json@@QBE_NXZ
_TEXT	SEGMENT
?isNumeric@Value@Json@@QBE_NXZ PROC NEAR		; Json::Value::isNumeric, COMDAT
; _this$ = eax

; 1218 :    return isIntegral() || isDouble();

	mov	al, BYTE PTR [eax+8]
	cmp	al, 1
	je	SHORT $L20911
	cmp	al, 2
	je	SHORT $L20911
	cmp	al, 5
	je	SHORT $L20911
	cmp	al, 3
	je	SHORT $L20911
	xor	eax, eax

; 1219 : }

	ret	0
$L20911:

; 1218 :    return isIntegral() || isDouble();

	mov	eax, 1

; 1219 : }

	ret	0
?isNumeric@Value@Json@@QBE_NXZ ENDP			; Json::Value::isNumeric
_TEXT	ENDS
PUBLIC	?clear@Value@Json@@QAEXXZ			; Json::Value::clear
; Function compile flags: /Ogtpy
;	COMDAT ?clear@Value@Json@@QAEXXZ
_TEXT	SEGMENT
?clear@Value@Json@@QAEXXZ PROC NEAR			; Json::Value::clear, COMDAT
; _this$ = eax

; 885  :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue  || type_ == objectValue );
; 886  : 
; 887  :    switch ( type_ )

	movsx	ecx, BYTE PTR [eax+8]
	cmp	ecx, 6
	jl	SHORT $L12314
	cmp	ecx, 7
	jg	SHORT $L12314
	push	esi

; 888  :    {
; 889  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 890  :    case arrayValue:
; 891  :    case objectValue:
; 892  :       value_.map_->clear();

	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi
	pop	esi
$L12314:

; 893  :       break;
; 894  : #else
; 895  :    case arrayValue:
; 896  :       value_.array_->clear();
; 897  :       break;
; 898  :    case objectValue:
; 899  :       value_.map_->clear();
; 900  :       break;
; 901  : #endif
; 902  :    default:
; 903  :       break;
; 904  :    }
; 905  : }

	ret	0
?clear@Value@Json@@QAEXXZ ENDP				; Json::Value::clear
_TEXT	ENDS
PUBLIC	?size@Value@Json@@QBEIXZ			; Json::Value::size
; Function compile flags: /Ogtpy
;	COMDAT ?size@Value@Json@@QBEIXZ
_TEXT	SEGMENT
_itLast$12300 = -4					; size = 4
?size@Value@Json@@QBEIXZ PROC NEAR			; Json::Value::size, COMDAT
; _this$ = ecx

; 848  : {

	push	ecx

; 849  :    switch ( type_ )

	movsx	eax, BYTE PTR [ecx+8]
	cmp	eax, 7
	ja	SHORT $L12303
	jmp	DWORD PTR $L21030[eax*4]
$L12298:

; 850  :    {
; 851  :    case nullValue:
; 852  :    case intValue:
; 853  :    case uintValue:
; 854  :    case realValue:
; 855  :    case booleanValue:
; 856  :    case stringValue:
; 857  :       return 0;
; 858  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 859  :    case arrayValue:  // size of the array is highest index + 1
; 860  :       if ( !value_.map_->empty() )

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $L12303

; 861  :       {
; 862  :          ObjectValues::const_iterator itLast = value_.map_->end();

	mov	eax, DWORD PTR [eax+4]

; 863  :          --itLast;

	lea	edx, DWORD PTR _itLast$12300[esp+4]
	mov	DWORD PTR _itLast$12300[esp+4], eax
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec

; 864  :          return (*itLast).first.index()+1;

	mov	ecx, DWORD PTR _itLast$12300[esp+4]
	mov	eax, DWORD PTR [ecx+20]
	inc	eax

; 879  : }

	pop	ecx
	ret	0
$L12302:

; 865  :       }
; 866  :       return 0;
; 867  :    case objectValue:
; 868  :       return Int( value_.map_->size() );

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx+8]

; 879  : }

	pop	ecx
	ret	0
$L12303:

; 869  : #else
; 870  :    case arrayValue:
; 871  :       return Int( value_.array_->size() );
; 872  :    case objectValue:
; 873  :       return Int( value_.map_->size() );
; 874  : #endif
; 875  :    default:
; 876  :       JSON_ASSERT_UNREACHABLE;
; 877  :    }
; 878  :    return 0; // unreachable;

	xor	eax, eax

; 879  : }

	pop	ecx
	ret	0
$L21030:
	DD	$L12303
	DD	$L12303
	DD	$L12303
	DD	$L12303
	DD	$L12303
	DD	$L12303
	DD	$L12298
	DD	$L12302
?size@Value@Json@@QBEIXZ ENDP				; Json::Value::size
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@ABVStaticString@1@@Z		; Json::Value::Value
; Function compile flags: /Ogtpy
;	COMDAT ??0Value@Json@@QAE@ABVStaticString@1@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
??0Value@Json@@QAE@ABVStaticString@1@@Z PROC NEAR	; Json::Value::Value, COMDAT
; _this$ = eax

; 368  : {

	mov	BYTE PTR [eax+8], 4
	and	DWORD PTR [eax+8], -257			; fffffeffH

; 369  :    value_.string_ = const_cast<char *>( value.c_str() );

	mov	ecx, DWORD PTR _value$[esp-4]
	mov	DWORD PTR [eax+12], 0
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 370  : }

	ret	4
??0Value@Json@@QAE@ABVStaticString@1@@Z ENDP		; Json::Value::Value
_TEXT	ENDS
PUBLIC	??4ValueIterator@Json@@QAEAAV01@ABV01@@Z	; Json::ValueIterator::operator=
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_valueiterator.inl
;	COMDAT ??4ValueIterator@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4ValueIterator@Json@@QAEAAV01@ABV01@@Z PROC NEAR	; Json::ValueIterator::operator=, COMDAT
; _this$ = eax
; _other$ = ecx

; 255  :    copy( other );

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 256  :    return *this;
; 257  : }

	ret	0
??4ValueIterator@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::ValueIterator::operator=
_TEXT	ENDS
PUBLIC	??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueIterator::ValueIterator
; Function compile flags: /Ogtpy
;	COMDAT ??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z
_TEXT	SEGMENT
??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z PROC NEAR ; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = eax
; _current$ = ecx

; 228  : {

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 229  : }

	ret	0
??0ValueIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ENDP ; Json::ValueIterator::ValueIterator
_TEXT	ENDS
PUBLIC	??0ValueIterator@Json@@QAE@XZ			; Json::ValueIterator::ValueIterator
; Function compile flags: /Ogtpy
;	COMDAT ??0ValueIterator@Json@@QAE@XZ
_TEXT	SEGMENT
??0ValueIterator@Json@@QAE@XZ PROC NEAR			; Json::ValueIterator::ValueIterator, COMDAT
; _this$ = eax

; 221  : {

	mov	DWORD PTR [eax], 0

; 222  : }

	ret	0
??0ValueIterator@Json@@QAE@XZ ENDP			; Json::ValueIterator::ValueIterator
_TEXT	ENDS
PUBLIC	??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z ; Json::ValueConstIterator::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z
_TEXT	SEGMENT
??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z PROC NEAR ; Json::ValueConstIterator::operator=, COMDAT
; _this$ = eax
; _other$ = ecx

; 207  :    copy( other );

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 208  :    return *this;
; 209  : }

	ret	0
??4ValueConstIterator@Json@@QAEAAV01@ABVValueIteratorBase@1@@Z ENDP ; Json::ValueConstIterator::operator=
_TEXT	ENDS
PUBLIC	??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ; Json::ValueConstIterator::ValueConstIterator
; Function compile flags: /Ogtpy
;	COMDAT ??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z
_TEXT	SEGMENT
??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z PROC NEAR ; Json::ValueConstIterator::ValueConstIterator, COMDAT
; _this$ = eax
; _current$ = ecx

; 190  : {

	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 191  : }

	ret	0
??0ValueConstIterator@Json@@AAE@ABViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@Z ENDP ; Json::ValueConstIterator::ValueConstIterator
_TEXT	ENDS
PUBLIC	??0ValueConstIterator@Json@@QAE@XZ		; Json::ValueConstIterator::ValueConstIterator
; Function compile flags: /Ogtpy
;	COMDAT ??0ValueConstIterator@Json@@QAE@XZ
_TEXT	SEGMENT
??0ValueConstIterator@Json@@QAE@XZ PROC NEAR		; Json::ValueConstIterator::ValueConstIterator, COMDAT
; _this$ = eax

; 183  : {

	mov	DWORD PTR [eax], 0

; 184  : }

	ret	0
??0ValueConstIterator@Json@@QAE@XZ ENDP			; Json::ValueConstIterator::ValueConstIterator
_TEXT	ENDS
PUBLIC	?decrement@ValueIteratorBase@Json@@IAEXXZ	; Json::ValueIteratorBase::decrement
; Function compile flags: /Ogtpy
;	COMDAT ?decrement@ValueIteratorBase@Json@@IAEXXZ
_TEXT	SEGMENT
?decrement@ValueIteratorBase@Json@@IAEXXZ PROC NEAR	; Json::ValueIteratorBase::decrement, COMDAT
; _this$ = edx

; 67   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 68   :    --current_;

	jmp	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec
?decrement@ValueIteratorBase@Json@@IAEXXZ ENDP		; Json::ValueIteratorBase::decrement
_TEXT	ENDS
PUBLIC	?increment@ValueIteratorBase@Json@@IAEXXZ	; Json::ValueIteratorBase::increment
; Function compile flags: /Ogtpy
;	COMDAT ?increment@ValueIteratorBase@Json@@IAEXXZ
_TEXT	SEGMENT
?increment@ValueIteratorBase@Json@@IAEXXZ PROC NEAR	; Json::ValueIteratorBase::increment, COMDAT
; _this$ = edx

; 54   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 55   :    ++current_;

	jmp	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc
?increment@ValueIteratorBase@Json@@IAEXXZ ENDP		; Json::ValueIteratorBase::increment
_TEXT	ENDS
PUBLIC	?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ	; Json::ValueIteratorBase::deref
; Function compile flags: /Ogtpy
;	COMDAT ?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ
_TEXT	SEGMENT
?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ PROC NEAR ; Json::ValueIteratorBase::deref, COMDAT
; _this$ = eax

; 41   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 42   :    return current_->second;

	mov	eax, DWORD PTR [eax]
	add	eax, 24					; 00000018H

; 43   : #else
; 44   :    if ( isArray_ )
; 45   :       return ValueInternalArray::dereference( iterator_.array_ );
; 46   :    return ValueInternalMap::value( iterator_.map_ );
; 47   : #endif
; 48   : }

	ret	0
?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ ENDP	; Json::ValueIteratorBase::deref
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0DefaultValueAllocator@Json@@QAE@XZ
_TEXT	SEGMENT
??0DefaultValueAllocator@Json@@QAE@XZ PROC NEAR		; Json::DefaultValueAllocator::DefaultValueAllocator, COMDAT
; _this$ = eax
	mov	DWORD PTR [eax], OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	ret	0
??0DefaultValueAllocator@Json@@QAE@XZ ENDP		; Json::DefaultValueAllocator::DefaultValueAllocator
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
_TEXT	ENDS
;	COMDAT ??1DefaultValueAllocator@Json@@UAE@XZ
_TEXT	SEGMENT
??1DefaultValueAllocator@Json@@UAE@XZ PROC NEAR		; Json::DefaultValueAllocator::~DefaultValueAllocator, COMDAT
; _this$ = ecx

; 61   :    }

	mov	DWORD PTR [ecx], OFFSET FLAT:??_7ValueAllocator@Json@@6B@
	ret	0
??1DefaultValueAllocator@Json@@UAE@XZ ENDP		; Json::DefaultValueAllocator::~DefaultValueAllocator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GValueAllocator@Json@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GValueAllocator@Json@@UAEPAXI@Z PROC NEAR		; Json::ValueAllocator::`scalar deleting destructor', COMDAT
; _this$ = ecx
	test	BYTE PTR ___flags$[esp-4], 1
	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7ValueAllocator@Json@@6B@
	je	SHORT $L21166
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L21166:
	mov	eax, esi
	pop	esi
	ret	4
??_GValueAllocator@Json@@UAEPAXI@Z ENDP			; Json::ValueAllocator::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First1$ = 12						; size = 4
__Last1$ = 16						; size = 4
__First2$ = 20						; size = 4
??$mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z PROC NEAR ; std::mismatch<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT

; 1077 : 	{	// return [_First1, _Last1) and [_First2, _Last2) mismatch

	push	ebx

; 1078 : 	for (; _First1 != _Last1 && *_First1 == *_First2; )

	mov	ebx, DWORD PTR __Last1$[esp]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR __First1$[esp+8]
	cmp	esi, ebx
	push	edi
	mov	edi, DWORD PTR __First2$[esp+12]
	je	$L16129
	npad	4
$L16128:
	lea	eax, DWORD PTR [edi+16]
	push	eax
	lea	ecx, DWORD PTR [esi+16]
	push	ecx
	call	??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator==<Json::Value::CZString const ,Json::Value>
	add	esp, 8
	test	al, al
	je	$L16129

; 1079 : 		++_First1, ++_First2;

	mov	al, BYTE PTR [esi+41]
	test	al, al
	jne	SHORT $L21441
	mov	ecx, DWORD PTR [esi+8]
	mov	al, BYTE PTR [ecx+41]
	test	al, al
	jne	SHORT $L21587
	mov	eax, DWORD PTR [ecx]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	jne	SHORT $L21456
$L21455:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	je	SHORT $L21455
$L21456:
	mov	esi, ecx
	jmp	SHORT $L21441
$L21587:
	mov	eax, DWORD PTR [esi+4]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	jne	SHORT $L21444
	npad	5
$L21443:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $L21444
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	je	SHORT $L21443
$L21444:
	mov	esi, eax
$L21441:
	mov	al, BYTE PTR [edi+41]
	test	al, al
	jne	SHORT $L21557
	mov	ecx, DWORD PTR [edi+8]
	mov	al, BYTE PTR [ecx+41]
	test	al, al
	jne	SHORT $L21589
	mov	eax, DWORD PTR [ecx]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	jne	SHORT $L21572
	npad	3
$L21571:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	je	SHORT $L21571
$L21572:
	mov	edi, ecx
	jmp	SHORT $L21557
$L21589:
	mov	eax, DWORD PTR [edi+4]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	jne	SHORT $L21560
	npad	7
$L21559:
	cmp	edi, DWORD PTR [eax+8]
	jne	SHORT $L21560
	mov	edi, eax
	mov	eax, DWORD PTR [eax+4]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	je	SHORT $L21559
$L21560:
	mov	edi, eax
$L21557:

; 1078 : 	for (; _First1 != _Last1 && *_First1 == *_First2; )

	cmp	esi, ebx
	jne	$L16128
$L16129:

; 1080 : 	return (pair<_InIt1, _InIt2>(_First1, _First2));

	mov	DWORD PTR [ebp+4], edi
	pop	edi
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx

; 1081 : 	}

	ret	0
??$mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z ENDP ; std::mismatch<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>, COMDAT
; __Off$ = edx

; 470  : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $L15859
	push	ebx
	npad	2
$L21747:

; 471  : 		++_Off;

	inc	DWORD PTR [edx]
	mov	al, BYTE PTR [ecx+41]
	test	al, al
	jne	SHORT $L21742
	mov	eax, DWORD PTR [ecx+8]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	jne	SHORT $L21758
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	jne	SHORT $L21742
	npad	2

; 470  : 	for (; _First != _Last; ++_First)

$L21730:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	je	SHORT $L21730
	jmp	SHORT $L21742
$L21758:
	mov	eax, DWORD PTR [ecx+4]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	jne	SHORT $L21745
$L21744:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $L21745
	mov	ecx, eax
	mov	eax, DWORD PTR [eax+4]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	je	SHORT $L21744
$L21745:
	mov	ecx, eax
$L21742:
	cmp	ecx, esi
	jne	SHORT $L21747
	pop	ebx
$L15859:
	pop	esi

; 472  : 	}

	ret	0
??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z
_TEXT	SEGMENT
$T21764 = -8						; size = 8
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z PROC NEAR ; std::equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT

; 1100 : 	return (mismatch(_First1, _Last1, _First2).first == _Last1);

	mov	eax, DWORD PTR __First2$[esp-4]
	mov	ecx, DWORD PTR __First1$[esp-4]
	sub	esp, 8
	push	esi
	mov	esi, DWORD PTR __Last1$[esp+8]
	push	eax
	push	esi
	push	ecx
	lea	edx, DWORD PTR $T21764[esp+24]
	push	edx
	call	??$mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z ; std::mismatch<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	mov	edx, DWORD PTR [eax]
	add	esp, 16					; 00000010H
	xor	ecx, ecx
	cmp	edx, esi
	sete	cl
	mov	al, cl
	pop	esi

; 1101 : 	}

	add	esp, 8
	ret	0
??$equal@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z ENDP ; std::equal<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__Last1$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z PROC NEAR ; std::lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>, COMDAT

; 1185 : 	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)

	mov	eax, DWORD PTR __First1$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR __Last1$[esp]
	cmp	eax, ebx
	push	ebp
	mov	ebp, DWORD PTR __Last2$[esp+4]
	push	esi
	push	edi
	je	SHORT $L21867
$L21779:
	mov	ecx, DWORD PTR __First2$[esp+12]
	cmp	ecx, ebp
	je	SHORT $L15817

; 1186 : 		if (*_First1 < *_First2)

	lea	esi, DWORD PTR [ecx+16]
	lea	edi, DWORD PTR [eax+16]
	push	esi
	push	edi
	call	??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator<<Json::Value::CZString const ,Json::Value>
	add	esp, 8
	test	al, al
	jne	SHORT $L21863

; 1188 : 		else if (*_First2 < *_First1)

	push	edi
	push	esi
	call	??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ; std::operator<<Json::Value::CZString const ,Json::Value>
	add	esp, 8
	test	al, al
	jne	SHORT $L21864
	lea	edx, DWORD PTR __First1$[esp+12]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc
	lea	edx, DWORD PTR __First2$[esp+12]
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc
	mov	eax, DWORD PTR __First1$[esp+12]
	cmp	eax, ebx
	jne	SHORT $L21779
$L21867:
	mov	ecx, DWORD PTR __First2$[esp+12]
$L21866:

; 1190 : 	return (_First1 == _Last1 && _First2 != _Last2);

	cmp	ecx, ebp
	je	SHORT $L21772
	pop	edi
	pop	esi
	pop	ebp
	mov	eax, 1
	pop	ebx

; 1191 : 	}

	ret	0
$L21863:
	pop	edi
	pop	esi
	pop	ebp

; 1187 : 			return (true);

	mov	al, 1
	pop	ebx

; 1191 : 	}

	ret	0
$L21864:
	pop	edi
	pop	esi
	pop	ebp

; 1189 : 			return (false);

	xor	al, al
	pop	ebx

; 1191 : 	}

	ret	0
$L15817:

; 1190 : 	return (_First1 == _Last1 && _First2 != _Last2);

	cmp	eax, ebx
	je	SHORT $L21866
$L21772:
	pop	edi
	pop	esi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 1191 : 	}

	ret	0
??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z ENDP ; std::lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@H@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAHUbidirectional_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@H@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAHUbidirectional_iterator_tag@0@@Z PROC NEAR ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,int>, COMDAT
; __Off$ = edx

; 470  : 	for (; _First != _Last; ++_First)

	mov	ecx, DWORD PTR __First$[esp-4]
	push	esi
	mov	esi, DWORD PTR __Last$[esp]
	cmp	ecx, esi
	je	SHORT $L15813
	push	ebx
	npad	2
$L22020:

; 471  : 		++_Off;

	inc	DWORD PTR [edx]
	mov	al, BYTE PTR [ecx+41]
	test	al, al
	jne	SHORT $L21990
	mov	eax, DWORD PTR [ecx+8]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	jne	SHORT $L22031
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	jne	SHORT $L21990
	npad	2

; 470  : 	for (; _First != _Last; ++_First)

$L22011:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	je	SHORT $L22011
	jmp	SHORT $L21990
$L22031:
	mov	eax, DWORD PTR [ecx+4]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	jne	SHORT $L21993
$L21992:
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $L21993
	mov	ecx, eax
	mov	eax, DWORD PTR [eax+4]
	mov	bl, BYTE PTR [eax+41]
	test	bl, bl
	je	SHORT $L21992
$L21993:
	mov	ecx, eax
$L21990:
	cmp	ecx, esi
	jne	SHORT $L22020
	pop	ebx
$L15813:
	pop	esi

; 472  : 	}

	ret	0
??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@H@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAHUbidirectional_iterator_tag@0@@Z ENDP ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,int>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAI@Z
_TEXT	SEGMENT
$T22037 = -4						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Off$ = 16						; size = 4
??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAI@Z PROC NEAR ; std::_Distance<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>, COMDAT

; 497  : 	{	// add to _Off distance between iterators

	push	ecx

; 498  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	eax, DWORD PTR $T22037[esp+4]
	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	push	eax
	push	ecx
	push	edx
	mov	edx, DWORD PTR __Off$[esp+12]
	call	??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>

; 499  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAI@Z ENDP ; std::_Distance<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
$T22119 = -8						; size = 8
??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z PROC NEAR ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 1159 : 	return (_Left.size() == _Right.size()
; 1160 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	mov	edx, DWORD PTR [ecx+8]
	sub	esp, 8
	push	esi
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $L22048
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax]
	mov	esi, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [esi]
	push	eax
	push	esi
	push	ecx
	lea	ecx, DWORD PTR $T22119[esp+24]
	push	ecx
	call	??$mismatch@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA?AU?$pair@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@0@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@00@Z ; std::mismatch<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	mov	ecx, DWORD PTR [eax]
	add	esp, 16					; 00000010H
	cmp	ecx, esi
	jne	SHORT $L22048
	mov	eax, 1
	pop	esi

; 1161 : 	}

	add	esp, 8
	ret	0
$L22048:

; 1159 : 	return (_Left.size() == _Right.size()
; 1160 : 		&& equal(_Left.begin(), _Left.end(), _Right.begin()));

	xor	eax, eax
	pop	esi

; 1161 : 	}

	add	esp, 8
	ret	0
??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z PROC NEAR ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; __Left$ = ecx
; __Right$ = eax

; 1172 : 	return (lexicographical_compare(_Left.begin(), _Left.end(),
; 1173 : 		_Right.begin(), _Right.end()));

	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	push	esi
	mov	esi, DWORD PTR [ecx]
	push	eax
	push	edx
	push	ecx
	push	esi
	call	??$lexicographical_compare@Vconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@std@@YA_NVconst_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@000@Z ; std::lexicographical_compare<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator,std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator>
	add	esp, 16					; 00000010H
	pop	esi

; 1174 : 	}

	ret	0
??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAHViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z
_TEXT	SEGMENT
$T22197 = -4						; size = 1
__Off$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAHViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z PROC NEAR ; std::distance<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>, COMDAT

; 487  : 	{	// return distance between iterators

	push	ecx

; 488  : 	typename iterator_traits<_InIt>::difference_type _Off = 0;
; 489  : 	_Distance2(_First, _Last, _Off, _Iter_cat(_First));

	mov	ecx, DWORD PTR __Last$[esp]
	mov	edx, DWORD PTR __First$[esp]
	mov	DWORD PTR __Off$[esp+4], 0
	mov	eax, DWORD PTR $T22197[esp+4]
	push	eax
	push	ecx
	push	edx
	lea	edx, DWORD PTR __Off$[esp+16]
	call	??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@H@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAHUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,int>

; 490  : 	return (_Off);

	mov	eax, DWORD PTR __Off$[esp+16]

; 491  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$distance@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@@std@@YAHViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ENDP ; std::distance<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
__Keyval$ = 8						; size = 4
?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound, COMDAT
; _this$ = eax

; 1089 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [eax+4]
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

	mov	cl, BYTE PTR [edi+41]
	test	cl, cl
	jne	SHORT $L15038

; 1093 : 			if (this->comp(_Keyval, _Key(_Pnode)))

	mov	ecx, DWORD PTR __Keyval$[esp]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR [ecx]
	push	esi
$L15037:
	test	ebp, ebp
	je	SHORT $L22238
	mov	esi, DWORD PTR [edi+16]
	mov	ecx, ebp
$L22248:
	mov	bl, BYTE PTR [ecx]
	mov	dl, bl
	cmp	bl, BYTE PTR [esi]
	jne	SHORT $L22249
	test	dl, dl
	je	SHORT $L22250
	mov	bl, BYTE PTR [ecx+1]
	mov	dl, bl
	cmp	bl, BYTE PTR [esi+1]
	jne	SHORT $L22249
	add	ecx, 2
	add	esi, 2
	test	dl, dl
	jne	SHORT $L22248
$L22250:
	xor	ecx, ecx
	test	ecx, ecx
	jmp	SHORT $L22254
$L22249:
	sbb	ecx, ecx
	sbb	ecx, -1
	test	ecx, ecx
	jmp	SHORT $L22254
$L22238:
	mov	edx, DWORD PTR __Keyval$[esp+12]
	mov	ecx, DWORD PTR [edx+4]
	cmp	ecx, DWORD PTR [edi+20]
$L22254:
	setl	cl
	test	cl, cl
	je	SHORT $L15039

; 1094 : 				{	// _Pnode greater than _Keyval, remember it
; 1095 : 				_Wherenode = _Pnode;

	mov	eax, edi

; 1096 : 				_Pnode = _Left(_Pnode);	// descend left subtree

	mov	edi, DWORD PTR [edi]

; 1097 : 				}
; 1098 : 			else

	jmp	SHORT $L15040
$L15039:

; 1099 : 				_Pnode = _Right(_Pnode);	// descend right subtree

	mov	edi, DWORD PTR [edi+8]
$L15040:

; 1090 : 		_Nodeptr _Wherenode = _Myhead;	// end() if search fails
; 1091 : 
; 1092 : 		while (!_Isnil(_Pnode))

	mov	cl, BYTE PTR [edi+41]
	test	cl, cl
	je	SHORT $L15037
	pop	esi
	pop	ebp
	pop	ebx
$L15038:
	pop	edi

; 1100 : 
; 1101 : 		return (_Wherenode);	// return best remembered candidate
; 1102 : 		}

	ret	4
?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z
_TEXT	SEGMENT
??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = esi

; 332  : 			{	// postincrement

	push	edi

; 333  : 			iterator _Tmp = *this;

	mov	edi, DWORD PTR [edx]

; 334  : 			++*this;

	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc

; 335  : 			return (_Tmp);

	mov	DWORD PTR [esi], edi
	mov	eax, esi
	pop	edi

; 336  : 			}

	ret	0
??Eiterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV012@H@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?upper_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?upper_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::upper_bound, COMDAT
; ___$ReturnUdt$ = esi
; __Keyval$ = eax

; 820  : 		return (_TREE_ITERATOR(_Ubound(_Keyval)));

	push	eax
	mov	eax, DWORD PTR _this$[esp]
	call	?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound
	mov	DWORD PTR [esi], eax
	mov	eax, esi

; 821  : 		}

	ret	4
?upper_bound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::upper_bound
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@2@ABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@2@ABVCZString@Value@Json@@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range, COMDAT
; _this$ = ebx
; ___$ReturnUdt$ = esi
; __Keyval$ = edi

; 829  : 		{	// find range equivalent to _Keyval in mutable tree

	push	ebp

; 830  : 		return (_Pairii(lower_bound(_Keyval), upper_bound(_Keyval)));

	push	edi
	mov	eax, ebx
	call	?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound
	mov	ebp, eax
	push	edi
	mov	eax, ebx
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ebp
	mov	eax, esi
	pop	ebp

; 831  : 		}

	ret	0
?equal_range@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@V123@@2@ABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::equal_range
_TEXT	ENDS
PUBLIC	?end@Value@Json@@QAE?AVValueIterator@2@XZ	; Json::Value::end
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
;	COMDAT ?end@Value@Json@@QAE?AVValueIterator@2@XZ
_TEXT	SEGMENT
?end@Value@Json@@QAE?AVValueIterator@2@XZ PROC NEAR	; Json::Value::end, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 1393 :    switch ( type_ )

	movsx	ecx, BYTE PTR [edx+8]
	cmp	ecx, 6
	jl	SHORT $L12821
	cmp	ecx, 7
	jg	SHORT $L12821

; 1394 :    {
; 1395 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1396 :    case arrayValue:
; 1397 :       if ( value_.array_ )
; 1398 :       {
; 1399 :          ValueInternalArray::IteratorState it;
; 1400 :          value_.array_->makeEndIterator( it );
; 1401 :          return iterator( it );
; 1402 :       }
; 1403 :       break;
; 1404 :    case objectValue:
; 1405 :       if ( value_.map_ )
; 1406 :       {
; 1407 :          ValueInternalMap::IteratorState it;
; 1408 :          value_.map_->makeEndIterator( it );
; 1409 :          return iterator( it );
; 1410 :       }
; 1411 :       break;
; 1412 : #else
; 1413 :    case arrayValue:
; 1414 :    case objectValue:
; 1415 :       if ( value_.map_ )

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $L12821

; 1416 :          return iterator( value_.map_->end() );

	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1423 : }

	ret	0
$L12821:

; 1417 :       break;
; 1418 : #endif
; 1419 :    default:
; 1420 :       break;
; 1421 :    }
; 1422 :    return iterator();

	mov	DWORD PTR [eax], 0

; 1423 : }

	ret	0
?end@Value@Json@@QAE?AVValueIterator@2@XZ ENDP		; Json::Value::end
_TEXT	ENDS
PUBLIC	?begin@Value@Json@@QAE?AVValueIterator@2@XZ	; Json::Value::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@Value@Json@@QAE?AVValueIterator@2@XZ
_TEXT	SEGMENT
?begin@Value@Json@@QAE?AVValueIterator@2@XZ PROC NEAR	; Json::Value::begin, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 1358 :    switch ( type_ )

	movsx	ecx, BYTE PTR [edx+8]
	cmp	ecx, 6
	jl	SHORT $L12807
	cmp	ecx, 7
	jg	SHORT $L12807

; 1359 :    {
; 1360 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1361 :    case arrayValue:
; 1362 :       if ( value_.array_ )
; 1363 :       {
; 1364 :          ValueInternalArray::IteratorState it;
; 1365 :          value_.array_->makeBeginIterator( it );
; 1366 :          return iterator( it );
; 1367 :       }
; 1368 :       break;
; 1369 :    case objectValue:
; 1370 :       if ( value_.map_ )
; 1371 :       {
; 1372 :          ValueInternalMap::IteratorState it;
; 1373 :          value_.map_->makeBeginIterator( it );
; 1374 :          return iterator( it );
; 1375 :       }
; 1376 :       break;
; 1377 : #else
; 1378 :    case arrayValue:
; 1379 :    case objectValue:
; 1380 :       if ( value_.map_ )

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $L12807

; 1381 :          return iterator( value_.map_->begin() );

	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1388 : }

	ret	0
$L12807:

; 1382 :       break;
; 1383 : #endif
; 1384 :    default:
; 1385 :       break;
; 1386 :    }
; 1387 :    return iterator();

	mov	DWORD PTR [eax], 0

; 1388 : }

	ret	0
?begin@Value@Json@@QAE?AVValueIterator@2@XZ ENDP	; Json::Value::begin
_TEXT	ENDS
PUBLIC	?end@Value@Json@@QBE?AVValueConstIterator@2@XZ	; Json::Value::end
; Function compile flags: /Ogtpy
;	COMDAT ?end@Value@Json@@QBE?AVValueConstIterator@2@XZ
_TEXT	SEGMENT
?end@Value@Json@@QBE?AVValueConstIterator@2@XZ PROC NEAR ; Json::Value::end, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 1322 :    switch ( type_ )

	movsx	ecx, BYTE PTR [edx+8]
	cmp	ecx, 6
	jl	SHORT $L12793
	cmp	ecx, 7
	jg	SHORT $L12793

; 1323 :    {
; 1324 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1325 :    case arrayValue:
; 1326 :       if ( value_.array_ )
; 1327 :       {
; 1328 :          ValueInternalArray::IteratorState it;
; 1329 :          value_.array_->makeEndIterator( it );
; 1330 :          return const_iterator( it );
; 1331 :       }
; 1332 :       break;
; 1333 :    case objectValue:
; 1334 :       if ( value_.map_ )
; 1335 :       {
; 1336 :          ValueInternalMap::IteratorState it;
; 1337 :          value_.map_->makeEndIterator( it );
; 1338 :          return const_iterator( it );
; 1339 :       }
; 1340 :       break;
; 1341 : #else
; 1342 :    case arrayValue:
; 1343 :    case objectValue:
; 1344 :       if ( value_.map_ )

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $L12793

; 1345 :          return const_iterator( value_.map_->end() );

	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1352 : }

	ret	0
$L12793:

; 1346 :       break;
; 1347 : #endif
; 1348 :    default:
; 1349 :       break;
; 1350 :    }
; 1351 :    return const_iterator();

	mov	DWORD PTR [eax], 0

; 1352 : }

	ret	0
?end@Value@Json@@QBE?AVValueConstIterator@2@XZ ENDP	; Json::Value::end
_TEXT	ENDS
PUBLIC	?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ ; Json::Value::begin
; Function compile flags: /Ogtpy
;	COMDAT ?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ
_TEXT	SEGMENT
?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ PROC NEAR ; Json::Value::begin, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 1287 :    switch ( type_ )

	movsx	ecx, BYTE PTR [edx+8]
	cmp	ecx, 6
	jl	SHORT $L12779
	cmp	ecx, 7
	jg	SHORT $L12779

; 1288 :    {
; 1289 : #ifdef JSON_VALUE_USE_INTERNAL_MAP
; 1290 :    case arrayValue:
; 1291 :       if ( value_.array_ )
; 1292 :       {
; 1293 :          ValueInternalArray::IteratorState it;
; 1294 :          value_.array_->makeBeginIterator( it );
; 1295 :          return const_iterator( it );
; 1296 :       }
; 1297 :       break;
; 1298 :    case objectValue:
; 1299 :       if ( value_.map_ )
; 1300 :       {
; 1301 :          ValueInternalMap::IteratorState it;
; 1302 :          value_.map_->makeBeginIterator( it );
; 1303 :          return const_iterator( it );
; 1304 :       }
; 1305 :       break;
; 1306 : #else
; 1307 :    case arrayValue:
; 1308 :    case objectValue:
; 1309 :       if ( value_.map_ )

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $L12779

; 1310 :          return const_iterator( value_.map_->begin() );

	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 1317 : }

	ret	0
$L12779:

; 1311 :       break;
; 1312 : #endif
; 1313 :    default:
; 1314 :       break;
; 1315 :    }
; 1316 :    return const_iterator();

	mov	DWORD PTR [eax], 0

; 1317 : }

	ret	0
?begin@Value@Json@@QBE?AVValueConstIterator@2@XZ ENDP	; Json::Value::begin
_TEXT	ENDS
PUBLIC	?isValidIndex@Value@Json@@QBE_NI@Z		; Json::Value::isValidIndex
; Function compile flags: /Ogtpy
;	COMDAT ?isValidIndex@Value@Json@@QBE_NI@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
?isValidIndex@Value@Json@@QBE_NI@Z PROC NEAR		; Json::Value::isValidIndex, COMDAT
; _this$ = ecx

; 1014 :    return index < size();

	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	cmp	DWORD PTR _index$[esp-4], eax
	sbb	eax, eax
	neg	eax

; 1015 : }

	ret	4
?isValidIndex@Value@Json@@QBE_NI@Z ENDP			; Json::Value::isValidIndex
_TEXT	ENDS
PUBLIC	??8Value@Json@@QBE_NABV01@@Z			; Json::Value::operator==
; Function compile flags: /Ogtpy
;	COMDAT ??8Value@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
??8Value@Json@@QBE_NABV01@@Z PROC NEAR			; Json::Value::operator==, COMDAT
; _this$ = edx
; _other$ = ecx

; 608  :    if ( type_ != other.type_ )

	mov	al, BYTE PTR [edx+8]
	push	ebx
	cmp	al, BYTE PTR [ecx+8]
	je	SHORT $L12163

; 609  :       return false;

	xor	al, al
	pop	ebx

; 642  : }

	ret	0
$L12163:

; 610  :    switch ( type_ )

	movsx	eax, al
	cmp	eax, 7
	push	esi
	ja	$L12180
	jmp	DWORD PTR $L22583[eax*4]
$L12168:
	pop	esi

; 611  :    {
; 612  :    case nullValue:
; 613  :       return true;

	mov	al, 1
	pop	ebx

; 642  : }

	ret	0
$L12169:

; 614  :    case intValue:
; 615  :       return value_.int_ == other.value_.int_;

	mov	esi, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	sub	eax, esi
	neg	eax
	sbb	eax, eax
	pop	esi
	inc	eax
	pop	ebx

; 642  : }

	ret	0
$L12171:

; 616  :    case uintValue:
; 617  :       return value_.uint_ == other.value_.uint_;
; 618  :    case realValue:
; 619  :       return value_.real_ == other.value_.real_;

	fld	QWORD PTR [ecx]
	fld	QWORD PTR [edx]
	fucompp
	fnstsw	ax
	test	ah, 68					; 00000044H
	jp	SHORT $L22564
	pop	esi

; 627  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 628  :    case arrayValue:
; 629  :    case objectValue:
; 630  :       return value_.map_->size() == other.value_.map_->size()
; 631  :              && (*value_.map_) == (*other.value_.map_);

	mov	eax, 1
	pop	ebx

; 642  : }

	ret	0
$L12172:

; 620  :    case booleanValue:
; 621  :       return value_.bool_ == other.value_.bool_;

	mov	al, BYTE PTR [edx]
	sub	al, BYTE PTR [ecx]
	neg	al
	pop	esi
	pop	ebx
	sbb	eax, eax
	inc	eax

; 642  : }

	ret	0
$L12173:

; 622  :    case stringValue:
; 623  :       return ( value_.string_ == other.value_.string_ )
; 624  :              || ( other.value_.string_  
; 625  :                   &&  value_.string_  
; 626  :                   && strcmp( value_.string_, other.value_.string_ ) == 0 );

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx]
	cmp	eax, ecx
	je	SHORT $L22582
	test	ecx, ecx
	je	SHORT $L22564
	test	eax, eax
	je	SHORT $L22564
	mov	esi, ecx
$L22577:
	mov	dl, BYTE PTR [eax]
	mov	bl, BYTE PTR [esi]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L22578
	test	cl, cl
	je	SHORT $L22579
	mov	dl, BYTE PTR [eax+1]
	mov	bl, BYTE PTR [esi+1]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L22578
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L22577
$L22579:
	xor	eax, eax
	jmp	SHORT $L22580
$L22578:
	sbb	eax, eax
	sbb	eax, -1
$L22580:
	test	eax, eax
	je	SHORT $L22582
$L22564:
	pop	esi
	xor	eax, eax
	pop	ebx

; 642  : }

	ret	0
$L12174:

; 627  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 628  :    case arrayValue:
; 629  :    case objectValue:
; 630  :       return value_.map_->size() == other.value_.map_->size()
; 631  :              && (*value_.map_) == (*other.value_.map_);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $L22564
	call	??$?8V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator==<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	test	al, al
	je	SHORT $L22564
$L22582:
	pop	esi
	mov	eax, 1
	pop	ebx

; 642  : }

	ret	0
$L12180:
	pop	esi

; 632  : #else
; 633  :    case arrayValue:
; 634  :       return value_.array_->compare( *(other.value_.array_) ) == 0;
; 635  :    case objectValue:
; 636  :       return value_.map_->compare( *(other.value_.map_) ) == 0;
; 637  : #endif
; 638  :    default:
; 639  :       JSON_ASSERT_UNREACHABLE;
; 640  :    }
; 641  :    return 0;  // unreachable

	xor	al, al
	pop	ebx

; 642  : }

	ret	0
	npad	1
$L22583:
	DD	$L12168
	DD	$L12169
	DD	$L12169
	DD	$L12171
	DD	$L12173
	DD	$L12172
	DD	$L12174
	DD	$L12174
??8Value@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator==
_TEXT	ENDS
PUBLIC	??MValue@Json@@QBE_NABV01@@Z			; Json::Value::operator<
; Function compile flags: /Ogtpy
;	COMDAT ??MValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
??MValue@Json@@QBE_NABV01@@Z PROC NEAR			; Json::Value::operator<, COMDAT
; _this$ = edx
; _other$ = ecx

; 545  : {

	push	esi

; 546  :    int typeDelta = type_ - other.type_;

	movsx	esi, BYTE PTR [edx+8]
	push	edi
	movsx	edi, BYTE PTR [ecx+8]
	mov	eax, esi
	sub	eax, edi

; 547  :    if ( typeDelta )

	je	SHORT $L12126

; 548  :       return typeDelta < 0 ? true : false;

	test	eax, eax
	pop	edi
	setl	al
	pop	esi

; 585  : }

	ret	0
$L12126:

; 549  :    switch ( type_ )

	cmp	esi, 7
	ja	$L12145
	jmp	DWORD PTR $L22606[esi*4]
$L12132:

; 550  :    {
; 551  :    case nullValue:
; 552  :       return false;
; 553  :    case intValue:
; 554  :       return value_.int_ < other.value_.int_;

	mov	eax, DWORD PTR [edx]
	mov	esi, DWORD PTR [ecx]
	xor	edx, edx
	cmp	eax, esi
	setl	dl
	pop	edi
	mov	al, dl
	pop	esi

; 585  : }

	ret	0
$L12133:

; 555  :    case uintValue:
; 556  :       return value_.uint_ < other.value_.uint_;

	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	sbb	eax, eax
	pop	edi
	neg	eax
	pop	esi

; 585  : }

	ret	0
$L12134:

; 557  :    case realValue:
; 558  :       return value_.real_ < other.value_.real_;

	fld	QWORD PTR [edx]
	fcomp	QWORD PTR [ecx]
	fnstsw	ax
	test	ah, 5
	jnp	SHORT $L22591
$L22590:
	pop	edi

; 561  :    case stringValue:
; 562  :       return ( value_.string_ == 0  &&  other.value_.string_ )
; 563  :              || ( other.value_.string_  
; 564  :                   &&  value_.string_  
; 565  :                   && strcmp( value_.string_, other.value_.string_ ) < 0 );

	xor	eax, eax
	pop	esi

; 585  : }

	ret	0
$L12135:

; 559  :    case booleanValue:
; 560  :       return value_.bool_ < other.value_.bool_;

	mov	dl, BYTE PTR [edx]
	xor	eax, eax
	cmp	dl, BYTE PTR [ecx]
	pop	edi
	pop	esi
	sbb	eax, eax
	neg	eax

; 585  : }

	ret	0
$L12136:

; 561  :    case stringValue:
; 562  :       return ( value_.string_ == 0  &&  other.value_.string_ )
; 563  :              || ( other.value_.string_  
; 564  :                   &&  value_.string_  
; 565  :                   && strcmp( value_.string_, other.value_.string_ ) < 0 );

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	jne	SHORT $L22589
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $L22591
	pop	edi
	xor	eax, eax
	pop	esi

; 585  : }

	ret	0
$L22589:

; 561  :    case stringValue:
; 562  :       return ( value_.string_ == 0  &&  other.value_.string_ )
; 563  :              || ( other.value_.string_  
; 564  :                   &&  value_.string_  
; 565  :                   && strcmp( value_.string_, other.value_.string_ ) < 0 );

	mov	ecx, DWORD PTR [ecx]
	test	ecx, ecx
	je	SHORT $L22590
	mov	esi, ecx
	push	ebx
	npad	7
$L22601:
	mov	dl, BYTE PTR [eax]
	mov	bl, BYTE PTR [esi]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L22602
	test	cl, cl
	je	SHORT $L22603
	mov	dl, BYTE PTR [eax+1]
	mov	bl, BYTE PTR [esi+1]
	mov	cl, dl
	cmp	dl, bl
	jne	SHORT $L22602
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L22601
$L22603:
	xor	eax, eax
	jmp	SHORT $L22604
$L22602:
	sbb	eax, eax
	sbb	eax, -1
$L22604:
	test	eax, eax
	pop	ebx
	jge	SHORT $L22590
$L22591:
	pop	edi
	mov	eax, 1
	pop	esi

; 585  : }

	ret	0
$L12137:

; 566  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 567  :    case arrayValue:
; 568  :    case objectValue:
; 569  :       {
; 570  :          int delta = int( value_.map_->size() - other.value_.map_->size() );

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [edx]
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, DWORD PTR [eax+8]

; 571  :          if ( delta )

	je	SHORT $L12139

; 572  :             return delta < 0;

	xor	eax, eax
	test	esi, esi
	pop	edi
	setl	al
	pop	esi

; 585  : }

	ret	0
$L12139:
	pop	edi
	pop	esi

; 573  :          return (*value_.map_) < (*other.value_.map_);

	jmp	??$?MV?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@YA_NABV?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0@Z ; std::operator<<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
$L12145:
	pop	edi

; 574  :       }
; 575  : #else
; 576  :    case arrayValue:
; 577  :       return value_.array_->compare( *(other.value_.array_) ) < 0;
; 578  :    case objectValue:
; 579  :       return value_.map_->compare( *(other.value_.map_) ) < 0;
; 580  : #endif
; 581  :    default:
; 582  :       JSON_ASSERT_UNREACHABLE;
; 583  :    }
; 584  :    return 0;  // unreachable

	xor	al, al
	pop	esi

; 585  : }

	ret	0
$L22606:
	DD	$L12145
	DD	$L12132
	DD	$L12133
	DD	$L12134
	DD	$L12136
	DD	$L12135
	DD	$L12137
	DD	$L12137
??MValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator<
_TEXT	ENDS
PUBLIC	?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z ; Json::ValueIteratorBase::computeDistance
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_valueiterator.inl
;	COMDAT ?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z
_TEXT	SEGMENT
$T22617 = -4						; size = 1
__Off$22622 = -4					; size = 4
?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z PROC NEAR ; Json::ValueIteratorBase::computeDistance, COMDAT
; _this$ = ecx
; _other$ = eax

; 79   : {

	push	ecx

; 80   : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 81   : # ifdef JSON_USE_CPPTL_SMALLMAP
; 82   :    return current_ - other.current_;
; 83   : # else
; 84   :    return difference_type( std::distance( current_, other.current_ ) );

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __Off$22622[esp+4], 0
	mov	edx, DWORD PTR $T22617[esp+4]
	push	edx
	push	eax
	push	ecx
	lea	edx, DWORD PTR __Off$22622[esp+16]
	call	??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@H@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAHUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,int>
	mov	eax, DWORD PTR __Off$22622[esp+16]

; 85   : # endif
; 86   : #else
; 87   :    if ( isArray_ )
; 88   :       return ValueInternalArray::distance( iterator_.array_, other.iterator_.array_ );
; 89   :    return ValueInternalMap::distance( iterator_.map_, other.iterator_.map_ );
; 90   : #endif
; 91   : }

	add	esp, 16					; 00000010H
	ret	0
?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z ENDP ; Json::ValueIteratorBase::computeDistance
_TEXT	ENDS
;	COMDAT ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
_BSS	SEGMENT
?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA DD 01H DUP (?) ; `Json::valueAllocator'::`2'::$S4
; Function compile flags: /Ogtpy
_BSS	ENDS
;	COMDAT ?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ
_TEXT	SEGMENT
?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ PROC NEAR ; Json::valueAllocator, COMDAT

; 97   :    static DefaultValueAllocator defaultAllocator;

	mov	cl, BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	mov	eax, 1
	test	cl, al
	jne	SHORT $L22637
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, eax
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L22637:

; 98   :    static ValueAllocator *valueAllocator = &defaultAllocator;
; 99   :    return valueAllocator;

	mov	eax, OFFSET FLAT:?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A

; 100  : }

	ret	0
?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ENDP	; Json::valueAllocator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_GDefaultValueAllocator@Json@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GDefaultValueAllocator@Json@@UAEPAXI@Z PROC NEAR	; Json::DefaultValueAllocator::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1DefaultValueAllocator@Json@@UAE@XZ	; Json::DefaultValueAllocator::~DefaultValueAllocator
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L22641
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L22641:
	mov	eax, esi
	pop	esi
	ret	4
??_GDefaultValueAllocator@Json@@UAEPAXI@Z ENDP		; Json::DefaultValueAllocator::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
;	COMDAT ??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z PROC NEAR ; std::operator==<Json::Value::CZString const ,Json::Value>, COMDAT

; 59   : 	{	// test for pair equality

	push	esi

; 60   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	mov	esi, DWORD PTR __Right$[esp]
	push	edi
	mov	edi, DWORD PTR __Left$[esp+4]
	mov	ecx, esi
	mov	edx, edi
	call	??8CZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator==
	test	al, al
	je	SHORT $L23394
	lea	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [edi+8]
	call	??8Value@Json@@QBE_NABV01@@Z		; Json::Value::operator==
	test	al, al
	je	SHORT $L23394
	pop	edi
	mov	eax, 1
	pop	esi

; 61   : 	}

	ret	0
$L23394:
	pop	edi

; 60   : 	return (_Left.first == _Right.first && _Left.second == _Right.second);

	xor	eax, eax
	pop	esi

; 61   : 	}

	ret	0
??$?8$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ENDP ; std::operator==<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = esi
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L23462
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L23462:
	xor	eax, eax
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+4], al
	test	BYTE PTR ___flags$[esp-4], 1
	je	SHORT $L23472
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L23472:
	mov	eax, esi
	ret	4
??_G?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPAXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC NEAR ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Ptr$ = esi

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L23565
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L23565:
	xor	eax, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+4], al

; 50   : 	}

	ret	0
??$_Destroy@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::_Destroy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
_TEXT	ENDS
;	COMDAT ??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z PROC NEAR ; std::operator<<Json::Value::CZString const ,Json::Value>, COMDAT

; 75   : 	{	// test if _Left < _Right for pairs

	push	esi

; 76   : 	return (_Left.first < _Right.first ||
; 77   : 		!(_Right.first < _Left.first) && _Left.second < _Right.second);

	mov	esi, DWORD PTR __Right$[esp]
	push	edi
	mov	edi, DWORD PTR __Left$[esp+4]
	mov	ecx, esi
	mov	edx, edi
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	jne	SHORT $L23579
	mov	ecx, edi
	mov	edx, esi
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	jne	SHORT $L23578
	lea	ecx, DWORD PTR [esi+8]
	lea	edx, DWORD PTR [edi+8]
	call	??MValue@Json@@QBE_NABV01@@Z		; Json::Value::operator<
	test	al, al
	jne	SHORT $L23579
$L23578:
	pop	edi
	xor	eax, eax
	pop	esi

; 78   : 	}

	ret	0
$L23579:
	pop	edi

; 76   : 	return (_Left.first < _Right.first ||
; 77   : 		!(_Right.first < _Left.first) && _Left.second < _Right.second);

	mov	eax, 1
	pop	esi

; 78   : 	}

	ret	0
??$?M$$CBVCZString@Value@Json@@V12@@std@@YA_NABU?$pair@$$CBVCZString@Value@Json@@V23@@0@0@Z ENDP ; std::operator<<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy, COMDAT
; __Ptr$ = esi

; 152  : 		_Destroy(_Ptr);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L23692
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L23692:
	xor	eax, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+4], al

; 153  : 		}

	ret	0
?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __First$ = eax
; __Last$ = edi

; 224  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi
	mov	esi, eax

; 225  : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $L15943
	push	ebx
	xor	ebx, ebx
	npad	6
$L15941:

; 226  : 		_Al.destroy(_First);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L23851
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L23851:
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	BYTE PTR [esi+4], bl
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $L15941
	pop	ebx
$L15943:
	pop	esi

; 227  : 	}

	ret	0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$23880 = -4					; size = 1
__First$ = 8						; size = 4
__Al$ = 12						; size = 4
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __Last$ = edi

; 216  : 	{	// destroy [_First, _Last)

	push	ecx

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	mov	eax, DWORD PTR __Cat$23880[esp+4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 218  : 	}

	add	esp, 8
	ret	0
??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Cat$23895 = 12					; size = 1
__First$ = 12						; size = 4
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy, COMDAT
; __Last$ = edi

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR __Cat$23895[esp-4]
	push	eax
	mov	eax, DWORD PTR __First$[esp]
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	pop	ecx

; 788  : 		}

	ret	8
?_Destroy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Destroy
_TEXT	ENDS
PUBLIC	??0PathArgument@Json@@QAE@I@Z			; Json::PathArgument::PathArgument
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
;	COMDAT ??0PathArgument@Json@@QAE@I@Z
_TEXT	SEGMENT
_index$ = 8						; size = 4
??0PathArgument@Json@@QAE@I@Z PROC NEAR			; Json::PathArgument::PathArgument, COMDAT
; _this$ = eax

; 1438 : {

	xor	ecx, ecx
	mov	DWORD PTR [eax+20], ecx
	mov	DWORD PTR [eax+24], 15			; 0000000fH
	mov	BYTE PTR [eax+4], cl
	mov	ecx, DWORD PTR _index$[esp-4]
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], 1

; 1439 : }

	ret	4
??0PathArgument@Json@@QAE@I@Z ENDP			; Json::PathArgument::PathArgument
_TEXT	ENDS
PUBLIC	??0PathArgument@Json@@QAE@XZ			; Json::PathArgument::PathArgument
; Function compile flags: /Ogtpy
;	COMDAT ??0PathArgument@Json@@QAE@XZ
_TEXT	SEGMENT
??0PathArgument@Json@@QAE@XZ PROC NEAR			; Json::PathArgument::PathArgument, COMDAT
; _this$ = eax

; 1431 : {

	xor	ecx, ecx
	mov	DWORD PTR [eax+24], 15			; 0000000fH
	mov	DWORD PTR [eax+20], ecx
	mov	BYTE PTR [eax+4], cl
	mov	DWORD PTR [eax+32], ecx

; 1432 : }

	ret	0
??0PathArgument@Json@@QAE@XZ ENDP			; Json::PathArgument::PathArgument
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1StyledWriter@Json@@QAE@XZ
_TEXT	SEGMENT
??1StyledWriter@Json@@QAE@XZ PROC NEAR			; Json::StyledWriter::~StyledWriter, COMDAT
; _this$ = esi
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $L24160
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L24160:
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], ebx
	mov	BYTE PTR [esi+16], bl
	mov	eax, DWORD PTR [esi]
	cmp	eax, ebx
	je	SHORT $L24184
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L24184:
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx
	pop	ebx
	ret	0
??1StyledWriter@Json@@QAE@XZ ENDP			; Json::StyledWriter::~StyledWriter
_TEXT	ENDS
PUBLIC	??9Value@Json@@QBE_NABV01@@Z			; Json::Value::operator!=
; Function compile flags: /Ogtpy
;	COMDAT ??9Value@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
??9Value@Json@@QBE_NABV01@@Z PROC NEAR			; Json::Value::operator!=, COMDAT
; _this$ = edx
; _other$ = ecx

; 647  :    return !( *this == other );

	call	??8Value@Json@@QBE_NABV01@@Z		; Json::Value::operator==
	neg	al
	sbb	eax, eax
	inc	eax

; 648  : }

	ret	0
??9Value@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator!=
_TEXT	ENDS
PUBLIC	??OValue@Json@@QBE_NABV01@@Z			; Json::Value::operator>
; Function compile flags: /Ogtpy
;	COMDAT ??OValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
??OValue@Json@@QBE_NABV01@@Z PROC NEAR			; Json::Value::operator>, COMDAT
; _this$ = ecx
; _other$ = edx

; 602  :    return other < *this;

	jmp	??MValue@Json@@QBE_NABV01@@Z		; Json::Value::operator<
??OValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator>
_TEXT	ENDS
PUBLIC	??PValue@Json@@QBE_NABV01@@Z			; Json::Value::operator>=
; Function compile flags: /Ogtpy
;	COMDAT ??PValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
??PValue@Json@@QBE_NABV01@@Z PROC NEAR			; Json::Value::operator>=, COMDAT
; _this$ = edx
; _other$ = ecx

; 596  :    return !(*this < other);

	call	??MValue@Json@@QBE_NABV01@@Z		; Json::Value::operator<
	neg	al
	sbb	eax, eax
	inc	eax

; 597  : }

	ret	0
??PValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator>=
_TEXT	ENDS
PUBLIC	??NValue@Json@@QBE_NABV01@@Z			; Json::Value::operator<=
; Function compile flags: /Ogtpy
;	COMDAT ??NValue@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
??NValue@Json@@QBE_NABV01@@Z PROC NEAR			; Json::Value::operator<=, COMDAT
; _this$ = edx
; _other$ = ecx

; 590  :    return !(other > *this);

	call	??MValue@Json@@QBE_NABV01@@Z		; Json::Value::operator<
	neg	al
	sbb	eax, eax
	inc	eax

; 591  : }

	ret	0
??NValue@Json@@QBE_NABV01@@Z ENDP			; Json::Value::operator<=
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::Value
; Function compile flags: /Ogtpy
;	COMDAT ??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; Json::Value::Value, COMDAT
; _this$ = esi
; _value$ = eax

; 355  : {

	push	edi
	mov	edi, eax
	mov	BYTE PTR [esi+8], 4
	or	DWORD PTR [esi+8], 256			; 00000100H
	mov	DWORD PTR [esi+12], 0

; 356  :    value_.string_ = valueAllocator()->duplicateStringValue( value.c_str(), 
; 357  :                                                             (unsigned int)value.length() );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	cmp	DWORD PTR [edi+24], 16			; 00000010H
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+20]
	jb	SHORT $L24220
	mov	edi, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx]
	push	eax
	push	edi
	call	DWORD PTR [edx+12]
	mov	DWORD PTR [esi], eax

; 358  : 
; 359  : }

	mov	eax, esi
	pop	edi
	ret	0

; 356  :    value_.string_ = valueAllocator()->duplicateStringValue( value.c_str(), 
; 357  :                                                             (unsigned int)value.length() );

$L24220:
	mov	edx, DWORD PTR [ecx]
	push	eax
	add	edi, 4
	push	edi
	call	DWORD PTR [edx+12]
	mov	DWORD PTR [esi], eax

; 358  : 
; 359  : }

	mov	eax, esi
	pop	edi
	ret	0
??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@PBD@Z			; Json::Value::Value
; Function compile flags: /Ogtpy
;	COMDAT ??0Value@Json@@QAE@PBD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
??0Value@Json@@QAE@PBD@Z PROC NEAR			; Json::Value::Value, COMDAT
; _this$ = esi

; 344  : {

	mov	BYTE PTR [esi+8], 4
	or	DWORD PTR [esi+8], 256			; 00000100H
	mov	DWORD PTR [esi+12], 0

; 345  :    value_.string_ = valueAllocator()->duplicateStringValue( value );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _value$[esp-4]
	mov	eax, DWORD PTR [ecx]
	push	-1
	push	edx
	call	DWORD PTR [eax+12]
	mov	DWORD PTR [esi], eax

; 346  : }

	mov	eax, esi
	ret	4
??0Value@Json@@QAE@PBD@Z ENDP				; Json::Value::Value
_TEXT	ENDS
PUBLIC	??1CZString@Value@Json@@QAE@XZ			; Json::Value::CZString::~CZString
; Function compile flags: /Ogtpy
;	COMDAT ??1CZString@Value@Json@@QAE@XZ
_TEXT	SEGMENT
??1CZString@Value@Json@@QAE@XZ PROC NEAR		; Json::Value::CZString::~CZString, COMDAT
; _this$ = esi

; 192  :    if ( cstr_  &&  index_ == duplicate )

	cmp	DWORD PTR [esi], 0
	je	SHORT $L11940
	cmp	DWORD PTR [esi+4], 1
	jne	SHORT $L11940

; 193  :       valueAllocator()->releaseMemberName( const_cast<char *>( cstr_ ) );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+8]
$L11940:

; 194  : }

	ret	0
??1CZString@Value@Json@@QAE@XZ ENDP			; Json::Value::CZString::~CZString
_TEXT	ENDS
PUBLIC	??0CZString@Value@Json@@QAE@ABV012@@Z		; Json::Value::CZString::CZString
; Function compile flags: /Ogtpy
;	COMDAT ??0CZString@Value@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0CZString@Value@Json@@QAE@ABV012@@Z PROC NEAR		; Json::Value::CZString::CZString, COMDAT
; _this$ = edi
; _other$ = eax

; 187  : {

	push	esi
	mov	esi, eax
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $L24231
	cmp	DWORD PTR [esi], 0
	je	SHORT $L24231
	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+4]
	jmp	SHORT $L24232
$L24231:
	mov	eax, DWORD PTR [esi]
$L24232:
	mov	DWORD PTR [edi], eax
	cmp	DWORD PTR [esi], 0
	je	SHORT $L24233
	mov	ecx, DWORD PTR [esi+4]
	xor	eax, eax
	test	ecx, ecx
	setne	al
	pop	esi
	mov	DWORD PTR [edi+4], eax

; 188  : }

	mov	eax, edi
	ret	0
$L24233:

; 187  : {

	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [edi+4], esi

; 188  : }

	mov	eax, edi
	pop	esi
	ret	0
??0CZString@Value@Json@@QAE@ABV012@@Z ENDP		; Json::Value::CZString::CZString
_TEXT	ENDS
PUBLIC	??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ; Json::Value::CZString::CZString
; Function compile flags: /Ogtpy
;	COMDAT ??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z
_TEXT	SEGMENT
??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z PROC NEAR ; Json::Value::CZString::CZString, COMDAT
; _this$ = edi
; _cstr$ = esi
; _allocate$ = ebx

; 178  : {

	cmp	ebx, 1
	jne	SHORT $L24239
	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ecx]
	push	esi
	call	DWORD PTR [eax+4]
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 179  : }

	mov	eax, edi
	ret	0
$L24239:

; 178  : {

	mov	eax, esi
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], ebx

; 179  : }

	mov	eax, edi
	ret	0
??0CZString@Value@Json@@QAE@PBDW4DuplicationPolicy@012@@Z ENDP ; Json::Value::CZString::CZString
_TEXT	ENDS
PUBLIC	?setComment@CommentInfo@Value@Json@@QAEXPBD@Z	; Json::Value::CommentInfo::setComment
; Function compile flags: /Ogtpy
;	COMDAT ?setComment@CommentInfo@Value@Json@@QAEXPBD@Z
_TEXT	SEGMENT
_text$ = 8						; size = 4
?setComment@CommentInfo@Value@Json@@QAEXPBD@Z PROC NEAR	; Json::Value::CommentInfo::setComment, COMDAT
; _this$ = esi

; 150  :    if ( comment_ )

	cmp	DWORD PTR [esi], 0
	je	SHORT $L11923

; 151  :       valueAllocator()->releaseStringValue( comment_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+16]
$L11923:

; 152  :    comment_ = valueAllocator()->duplicateStringValue( text );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _text$[esp-4]
	mov	eax, DWORD PTR [ecx]
	push	-1
	push	edx
	call	DWORD PTR [eax+12]
	mov	DWORD PTR [esi], eax

; 153  : }

	ret	4
?setComment@CommentInfo@Value@Json@@QAEXPBD@Z ENDP	; Json::Value::CommentInfo::setComment
_TEXT	ENDS
PUBLIC	??1CommentInfo@Value@Json@@QAE@XZ		; Json::Value::CommentInfo::~CommentInfo
; Function compile flags: /Ogtpy
;	COMDAT ??1CommentInfo@Value@Json@@QAE@XZ
_TEXT	SEGMENT
??1CommentInfo@Value@Json@@QAE@XZ PROC NEAR		; Json::Value::CommentInfo::~CommentInfo, COMDAT
; _this$ = ecx

; 141  : {

	push	esi
	mov	esi, ecx

; 142  :    if ( comment_ )

	cmp	DWORD PTR [esi], 0
	je	SHORT $L11918

; 143  :       valueAllocator()->releaseStringValue( comment_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+16]
$L11918:
	pop	esi

; 144  : }

	ret	0
??1CommentInfo@Value@Json@@QAE@XZ ENDP			; Json::Value::CommentInfo::~CommentInfo
_TEXT	ENDS
PUBLIC	?index@ValueIteratorBase@Json@@QBEIXZ		; Json::ValueIteratorBase::index
;	COMDAT xdata$x
xdata$x	SEGMENT
$T24380	DD	0ffffffffH
	DD	FLAT:$L24252
$T24377	DD	019930520H
	DD	01H
	DD	FLAT:$T24380
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_valueiterator.inl
xdata$x	ENDS
;	COMDAT ?index@ValueIteratorBase@Json@@QBEIXZ
_TEXT	SEGMENT
_czstring$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?index@ValueIteratorBase@Json@@QBEIXZ PROC NEAR		; Json::ValueIteratorBase::index, COMDAT

; 146  : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$?index@ValueIteratorBase@Json@@QBEIXZ
	push	eax

; 147  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 148  :    const Value::CZString czstring = (*current_).first;

	mov	eax, DWORD PTR _this$[esp+8]
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	esi
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+20]
	add	esi, 16					; 00000010H
	test	eax, eax
	push	edi
	je	SHORT $L24293
	cmp	DWORD PTR [esi], 0
	je	SHORT $L24293
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, 1
	jne	SHORT $L24378
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, 1
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L24378:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+4]
	mov	edi, eax
	jmp	SHORT $L24294
$L24293:
	mov	edi, DWORD PTR [esi]
$L24294:
	cmp	DWORD PTR [esi], 0
	je	SHORT $L24295
	mov	ecx, DWORD PTR [esi+4]
	xor	eax, eax
	test	ecx, ecx
	setne	al
	jmp	SHORT $L24296
$L24295:
	mov	eax, DWORD PTR [esi+4]
$L24296:

; 149  :    if ( !czstring.c_str() )

	test	edi, edi

; 150  :       return czstring.index();

	je	SHORT $L11872

; 151  :    return Value::UInt( -1 );

	cmp	eax, 1
	mov	DWORD PTR __$EHRec$[esp+36], -1
	jne	SHORT $L24365
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, 1
	jne	SHORT $L24369
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, 1
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L24369:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [ecx]
	push	edi
	call	DWORD PTR [edx+8]
$L24365:
	or	eax, -1
$L11872:

; 152  : #else
; 153  :    if ( isArray_ )
; 154  :       return Value::UInt( ValueInternalArray::indexOf( iterator_.array_ ) );
; 155  :    return Value::UInt( -1 );
; 156  : #endif
; 157  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L24252:
	lea	esi, DWORD PTR _czstring$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$?index@ValueIteratorBase@Json@@QBEIXZ:
	mov	eax, OFFSET FLAT:$T24377
	jmp	___CxxFrameHandler
text$x	ENDS
?index@ValueIteratorBase@Json@@QBEIXZ ENDP		; Json::ValueIteratorBase::index
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
;	COMDAT ??0DummyValueAllocatorInitializer@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = 8						; size = 4
??0DummyValueAllocatorInitializer@Json@@QAE@XZ PROC NEAR ; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer, COMDAT

; 104  :    {
; 105  :       valueAllocator();      // ensure valueAllocator() statics are initialized before main().

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator

; 106  :    }

	mov	eax, DWORD PTR _this$[esp-4]
	ret	4
??0DummyValueAllocatorInitializer@Json@@QAE@XZ ENDP	; Json::DummyValueAllocatorInitializer::DummyValueAllocatorInitializer
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1PathArgument@Json@@QAE@XZ
_TEXT	SEGMENT
??1PathArgument@Json@@QAE@XZ PROC NEAR			; Json::PathArgument::~PathArgument, COMDAT
; _this$ = esi
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L24453
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L24453:
	xor	eax, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+4], al
	ret	0
??1PathArgument@Json@@QAE@XZ ENDP			; Json::PathArgument::~PathArgument
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ??1out_of_range@std@@UAE@XZ
_TEXT	SEGMENT
??1out_of_range@std@@UAE@XZ PROC NEAR			; std::out_of_range::~out_of_range, COMDAT
; _this$ = ecx

; 122  : 		{}	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $L24558
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L24558:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@@UAE@XZ			; exception::~exception
??1out_of_range@std@@UAE@XZ ENDP			; std::out_of_range::~out_of_range
; Function compile flags: /Ogtpy
;	COMDAT ??_GPathArgument@Json@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GPathArgument@Json@@QAEPAXI@Z PROC NEAR		; Json::PathArgument::`scalar deleting destructor', COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	call	??1PathArgument@Json@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L26762
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L26762:
	mov	eax, esi
	pop	esi
	ret	4
??_GPathArgument@Json@@QAEPAXI@Z ENDP			; Json::PathArgument::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T26870	DD	0ffffffffH
	DD	FLAT:$L26770
$T26868	DD	019930520H
	DD	01H
	DD	FLAT:$T26870
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC NEAR ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Ptr$ = ecx

; 41   : 	{	// construct object at _Ptr with value _Val

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

	xor	eax, eax
	cmp	ecx, eax
	mov	DWORD PTR __$EHRec$[esp+20], eax
	je	SHORT $L26768
	push	-1
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [ecx+4], al
	mov	eax, DWORD PTR __Val$[esp+16]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L26768:

; 43   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L26770:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z:
	mov	eax, OFFSET FLAT:$T26868
	jmp	___CxxFrameHandler
text$x	ENDS
??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z
_TEXT	SEGMENT
??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z PROC NEAR ; std::_Destroy<Json::PathArgument>, COMDAT
; __Ptr$ = esi

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

	jmp	??1PathArgument@Json@@QAE@XZ
??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z ENDP ; std::_Destroy<Json::PathArgument>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z
_TEXT	SEGMENT
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z PROC NEAR ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct, COMDAT
; __Ptr$ = ecx
; __Val$ = eax

; 147  : 		_Construct(_Ptr, _Val);

	push	eax
	call	??$_Construct@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::_Construct<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
	pop	ecx

; 148  : 		}

	ret	0
?construct@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV32@@Z ENDP ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::construct
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z PROC NEAR ; std::allocator<Json::PathArgument>::destroy, COMDAT
; __Ptr$ = esi

; 152  : 		_Destroy(_Ptr);

	jmp	??1PathArgument@Json@@QAE@XZ
?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ENDP ; std::allocator<Json::PathArgument>::destroy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; __First$ = ebx
; __Last$ = ecx
; __Dest$ = eax

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	esi
	mov	esi, ecx

; 1049 : 	while (_First != _Last)

	cmp	ebx, esi
	push	edi
	mov	edi, eax
	je	SHORT $L26908
	npad	6
$L16088:

; 1050 : 		*--_Dest = *--_Last;

	push	-1
	push	0
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	esi, ebx
	jne	SHORT $L16088
$L26908:

; 1051 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi

; 1052 : 	}

	ret	0
??$_Copy_backward_opt@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; __First$ = eax
; __Last$ = edi

; 224  : 	{	// destroy [_First, _Last), arbitrary type

	push	esi
	mov	esi, eax

; 225  : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $L16001
$L15999:

; 226  : 		_Al.destroy(_First);

	call	??1PathArgument@Json@@QAE@XZ
	add	esi, 36					; 00000024H
	cmp	esi, edi
	jne	SHORT $L15999
$L16001:
	pop	esi

; 227  : 	}

	ret	0
??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T27123	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L26943
	DD	0ffffffffH
	DD	00H
$T27125	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L26936
$T27124	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T27125
$T27117	DD	019930520H
	DD	03H
	DD	FLAT:$T27123
	DD	01H
	DD	FLAT:$T27124
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Val$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __Count$ = ecx

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 208  : 	_FwdIt _Next = _First;
; 209  : 
; 210  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	2
$L15947:

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	edi, ebx
	jbe	SHORT $L15949

; 212  : 		_Al.construct(_First, _Val);

	cmp	esi, ebx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	je	SHORT $L27081
	mov	eax, DWORD PTR __Val$[ebp]
	push	-1
	push	ebx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	push	eax
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L27081:
	dec	edi
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $L15947
$L26936:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	cmp	esi, edi
	je	SHORT $L15952
	npad	3
$L15950:

; 215  : 		_Al.destroy(_Next);

	call	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $L15950
$L15952:

; 216  : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$L27126:
$L15949:

; 217  : 	_CATCH_END
; 218  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L27122:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L26943:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	eax, OFFSET FLAT:$T27117
	jmp	___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??4PathArgument@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4PathArgument@Json@@QAEAAV01@ABV01@@Z PROC NEAR	; Json::PathArgument::operator=, COMDAT
; _this$ = esi
; ___that$ = edi
	push	-1
	push	0
	push	edi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], ecx
	mov	eax, esi
	ret	0
??4PathArgument@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::PathArgument::operator=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z
_TEXT	SEGMENT
??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z PROC NEAR ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; __First$ = ebx
; __Last$ = eax
; __Dest$ = ecx

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	esi
	mov	esi, eax

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

	cmp	ebx, esi
	push	edi
	mov	edi, ecx
	je	SHORT $L27169
	npad	6
$L27162:
	push	-1
	push	0
	sub	esi, 28					; 0000001cH
	sub	edi, 28					; 0000001cH
	push	esi
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	esi, ebx
	jne	SHORT $L27162
$L27169:
	mov	eax, edi
	pop	edi
	pop	esi

; 1070 : 	}

	ret	0
??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ENDP ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z
_TEXT	SEGMENT
??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z PROC NEAR ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __First$ = eax
; __Last$ = edi
; __Val$ = ebx

; 1134 : 	{	// copy _Val through [_First, _Last)

	push	esi
	mov	esi, eax

; 1135 : 	for (; _First != _Last; ++_First)

	cmp	esi, edi
	je	SHORT $L15751
$L15749:

; 1136 : 		*_First = _Val;

	push	-1
	push	0
	push	ebx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $L15749
$L15751:
	pop	esi

; 1137 : 	}

	ret	0
??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ENDP ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z
_TEXT	SEGMENT
??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z PROC NEAR ; std::fill<Json::PathArgument *,Json::PathArgument>, COMDAT
; __First$ = eax
; __Last$ = ebx
; __Val$ = edi

; 1134 : 	{	// copy _Val through [_First, _Last)

	push	esi
	mov	esi, eax

; 1135 : 	for (; _First != _Last; ++_First)

	cmp	esi, ebx
	je	SHORT $L15709
$L15707:

; 1136 : 		*_First = _Val;

	push	-1
	push	0
	push	edi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], ecx
	add	esi, 36					; 00000024H
	cmp	esi, ebx
	jne	SHORT $L15707
$L15709:
	pop	esi

; 1137 : 	}

	ret	0
??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z ENDP ; std::fill<Json::PathArgument *,Json::PathArgument>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z PROC NEAR ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; __First$ = eax
; __Last$ = edi

; 216  : 	{	// destroy [_First, _Last)

	push	esi
	mov	esi, eax

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	cmp	esi, edi
	je	SHORT $L27241
$L27239:
	call	??1PathArgument@Json@@QAE@XZ
	add	esi, 36					; 00000024H
	cmp	esi, edi
	jne	SHORT $L27239
$L27241:
	pop	esi

; 218  : 	}

	ret	0
??$_Destroy_range@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z ENDP ; std::_Destroy_range<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$27252 = -4					; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __Val$ = edx
; __Al$ = ecx

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

	mov	eax, DWORD PTR __Cat$27252[esp+4]
	push	eax
	mov	eax, DWORD PTR __First$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __Count$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 258  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Uninitialized_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0PathArgument@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0PathArgument@Json@@QAE@ABV01@@Z PROC NEAR		; Json::PathArgument::PathArgument, COMDAT
; _this$ = esi
; ___that$ = edi
	xor	eax, eax
	push	-1
	push	eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	push	edi
	mov	ecx, esi
	mov	BYTE PTR [esi+4], al
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], ecx
	mov	eax, esi
	ret	0
??0PathArgument@Json@@QAE@ABV01@@Z ENDP			; Json::PathArgument::PathArgument
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy, COMDAT
; __First$ = eax
; __Last$ = edi

; 786  : 		{	// destroy [_First, _Last) using allocator

	push	esi
	mov	esi, eax

; 787  : 		_Destroy_range(_First, _Last, this->_Alval);

	cmp	esi, edi
	je	SHORT $L27402
$L27400:
	call	??1PathArgument@Json@@QAE@XZ
	add	esi, 36					; 00000024H
	cmp	esi, edi
	jne	SHORT $L27400
$L27402:
	pop	esi

; 788  : 		}

	ret	0
?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z
_TEXT	SEGMENT
__Cat$27428 = -4					; size = 1
?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill, COMDAT
; _this$ = ecx
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = edx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Cat$27428[esp+4]
	push	eax
	push	ecx
	push	edx
	push	edi
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 879  : 		return (_Ptr + _Count);

	mov	eax, esi
	imul	eax, 28					; 0000001cH
	add	eax, edi

; 880  : 		}

	add	esp, 20					; 00000014H
	ret	0
?_Ufill@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAV32@IABV32@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ufill
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ
_TEXT	SEGMENT
__Cat$27455 = -4					; size = 1
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy, COMDAT
; _this$ = esi

; 791  : 		{	// free all storage

	push	ecx

; 792  : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $L27460

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR __Cat$27455[esp+4]
	push	edi
	mov	edi, DWORD PTR [esi+8]
	push	ecx
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 8
	pop	edi
$L27460:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0

; 798  : 		}

	pop	ecx
	ret	0
?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy, COMDAT
; _this$ = ebx

; 791  : 		{	// free all storage

	push	esi

; 792  : 		if (_Myfirst != 0)

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $L27550
	push	edi

; 793  : 			{	// something to free, destroy and deallocate it
; 794  : 			_Destroy(_Myfirst, _Mylast);

	mov	edi, DWORD PTR [ebx+8]
	cmp	esi, edi
	je	SHORT $L27538
$L27536:
	call	??1PathArgument@Json@@QAE@XZ
	add	esi, 36					; 00000024H
	cmp	esi, edi
	jne	SHORT $L27536
$L27538:

; 795  : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$L27550:

; 796  : 			}
; 797  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	pop	esi

; 798  : 		}

	ret	0
?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__Cat$27599 = -4					; size = 1
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = esi

; 387  : 		{	// destroy the object

	push	ecx

; 388  : 		_Tidy();

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $L27601
	mov	ecx, DWORD PTR __Cat$27599[esp+4]
	push	edi
	mov	edi, DWORD PTR [esi+8]
	push	ecx
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 8
	pop	edi
$L27601:
	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR [esi+12], 0

; 389  : 		}

	pop	ecx
	ret	0
??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ebx

; 387  : 		{	// destroy the object

	push	esi

; 388  : 		_Tidy();

	mov	esi, DWORD PTR [ebx+4]
	test	esi, esi
	je	SHORT $L27715
	push	edi
	mov	edi, DWORD PTR [ebx+8]
	cmp	esi, edi
	je	SHORT $L27702
$L27700:
	call	??1PathArgument@Json@@QAE@XZ
	add	esi, 36					; 00000024H
	cmp	esi, edi
	jne	SHORT $L27700
$L27702:
	mov	eax, DWORD PTR [ebx+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$L27715:
	mov	DWORD PTR [ebx+4], 0
	mov	DWORD PTR [ebx+8], 0
	mov	DWORD PTR [ebx+12], 0
	pop	esi

; 389  : 		}

	ret	0
??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
_TEXT	ENDS
PUBLIC	?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ; Json::Value::setComment
;	COMDAT xdata$x
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
xdata$x	SEGMENT
$T27791	DD	0ffffffffH
	DD	FLAT:$L27728
$T27789	DD	019930520H
	DD	01H
	DD	FLAT:$T27791
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
_TEXT	SEGMENT
$T27725 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_comment$ = 8						; size = 4
_placement$ = 12					; size = 4
?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z PROC NEAR ; Json::Value::setComment, COMDAT
; _this$ = ecx

; 1246 : {

	push	-1
	push	__ehhandler$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1247 :    if ( !comments_ )

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	jne	SHORT $L12740

; 1248 :       comments_ = new CommentInfo[numberOfCommentPlacement];

	push	16					; 00000010H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T27725[esp+28], eax
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+36], 0
	je	SHORT $L27726
	push	OFFSET FLAT:??1CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::~CommentInfo
	push	OFFSET FLAT:??0CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::CommentInfo
	push	3
	lea	esi, DWORD PTR [eax+4]
	push	4
	push	esi
	mov	DWORD PTR [eax], 3
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	jmp	SHORT $L27727
$L27726:
	xor	esi, esi
$L27727:
	mov	DWORD PTR __$EHRec$[esp+36], -1
	mov	DWORD PTR [edi+12], esi
$L12740:

; 1249 :    comments_[placement].setComment( comment );

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR _placement$[esp+24]
	lea	esi, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR [esi], 0
	mov	ebx, 1
	mov	edi, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	je	SHORT $L27786
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, bl
	jne	SHORT $L27774
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, ebx
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, edi
	call	_atexit
	add	esp, 4
$L27774:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+16]
$L27786:
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, bl
	jne	SHORT $L27783
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, ebx
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, edi
	call	_atexit
	add	esp, 4
$L27783:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	eax, DWORD PTR _comment$[esp+24]
	mov	edx, DWORD PTR [ecx]
	push	-1
	push	eax
	call	DWORD PTR [edx+12]

; 1250 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+28]
	pop	edi
	mov	DWORD PTR [esi], eax
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L27728:
	mov	eax, DWORD PTR $T27725[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z:
	mov	eax, OFFSET FLAT:$T27789
	jmp	___CxxFrameHandler
text$x	ENDS
?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ENDP ; Json::Value::setComment
PUBLIC	??AValue@Json@@QBEABV01@PBD@Z			; Json::Value::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
$T28045	DD	0ffffffffH
	DD	FLAT:$L27801
$T28042	DD	019930520H
	DD	01H
	DD	FLAT:$T28045
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??AValue@Json@@QBEABV01@PBD@Z
_TEXT	SEGMENT
_actualKey$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
__Where$27949 = 8					; size = 4
_this$ = 8						; size = 4
$T27916 = 12						; size = 4
_key$ = 12						; size = 4
??AValue@Json@@QBEABV01@PBD@Z PROC NEAR			; Json::Value::operator[], COMDAT

; 1021 : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??AValue@Json@@QBEABV01@PBD@Z
	push	eax
	mov	eax, DWORD PTR _this$[esp+8]
	mov	DWORD PTR fs:__except_list, esp

; 1022 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1023 :    if ( type_ == nullValue )

	mov	cl, BYTE PTR [eax+8]
	sub	esp, 8
	test	cl, cl

; 1024 :       return null;

	je	SHORT $L28044

; 1025 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1026 :    CZString actualKey( key, CZString::noDuplication );

	mov	ecx, DWORD PTR _key$[esp+16]
	push	esi
	push	edi
	mov	DWORD PTR _actualKey$[esp+28], ecx
	mov	DWORD PTR _actualKey$[esp+32], 0

; 1027 :    ObjectValues::const_iterator it = value_.map_->find( actualKey );

	mov	esi, DWORD PTR [eax]
	lea	edx, DWORD PTR _actualKey$[esp+28]
	push	edx
	mov	eax, esi
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
	mov	edi, DWORD PTR [esi+4]
	cmp	eax, edi
	mov	DWORD PTR __Where$27949[esp+24], eax
	je	SHORT $L27915
	lea	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR _actualKey$[esp+28]
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	jne	SHORT $L27915
	lea	eax, DWORD PTR __Where$27949[esp+24]
	jmp	SHORT $L27917
$L27915:
	mov	DWORD PTR $T27916[esp+24], edi
	lea	eax, DWORD PTR $T27916[esp+24]
$L27917:

; 1028 :    if ( it == value_.map_->end() )

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	pop	edi
	pop	esi
	jne	SHORT $L12409
$L28044:

; 1029 :       return null;

	mov	eax, OFFSET FLAT:?null@Value@Json@@2V12@B ; Json::Value::null

; 1030 :    return (*it).second;
; 1031 : #else
; 1032 :    const Value *value = value_.map_->find( key );
; 1033 :    return value ? *value : null;
; 1034 : #endif
; 1035 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	8
$L12409:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	eax, 24					; 00000018H
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L27801:
	lea	esi, DWORD PTR _actualKey$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??AValue@Json@@QBEABV01@PBD@Z:
	mov	eax, OFFSET FLAT:$T28042
	jmp	___CxxFrameHandler
text$x	ENDS
??AValue@Json@@QBEABV01@PBD@Z ENDP			; Json::Value::operator[]
PUBLIC	??AValue@Json@@QBEABV01@I@Z			; Json::Value::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
$T28268	DD	0ffffffffH
	DD	FLAT:$L28055
$T28265	DD	019930520H
	DD	01H
	DD	FLAT:$T28268
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??AValue@Json@@QBEABV01@I@Z
_TEXT	SEGMENT
_key$ = -20						; size = 8
__$EHRec$ = -12						; size = 12
__Where$28166 = 8					; size = 4
_this$ = 8						; size = 4
$T28139 = 12						; size = 4
_index$ = 12						; size = 4
??AValue@Json@@QBEABV01@I@Z PROC NEAR			; Json::Value::operator[], COMDAT

; 954  : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??AValue@Json@@QBEABV01@I@Z
	push	eax
	mov	eax, DWORD PTR _this$[esp+8]
	mov	DWORD PTR fs:__except_list, esp

; 955  :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue );
; 956  :    if ( type_ == nullValue )

	mov	cl, BYTE PTR [eax+8]
	sub	esp, 8
	test	cl, cl

; 957  :       return null;

	je	SHORT $L28267

; 958  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 959  :    CZString key( index );

	mov	ecx, DWORD PTR _index$[esp+16]
	push	esi
	push	edi
	mov	DWORD PTR _key$[esp+28], 0
	mov	DWORD PTR _key$[esp+32], ecx

; 960  :    ObjectValues::const_iterator it = value_.map_->find( key );

	mov	esi, DWORD PTR [eax]
	lea	edx, DWORD PTR _key$[esp+28]
	push	edx
	mov	eax, esi
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
	mov	edi, DWORD PTR [esi+4]
	cmp	eax, edi
	mov	DWORD PTR __Where$28166[esp+24], eax
	je	SHORT $L28138
	lea	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR _key$[esp+28]
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	jne	SHORT $L28138
	lea	eax, DWORD PTR __Where$28166[esp+24]
	jmp	SHORT $L28140
$L28138:
	mov	DWORD PTR $T28139[esp+24], edi
	lea	eax, DWORD PTR $T28139[esp+24]
$L28140:

; 961  :    if ( it == value_.map_->end() )

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax]
	cmp	eax, ecx
	pop	edi
	pop	esi
	jne	SHORT $L12361
$L28267:

; 962  :       return null;

	mov	eax, OFFSET FLAT:?null@Value@Json@@2V12@B ; Json::Value::null

; 963  :    return (*it).second;
; 964  : #else
; 965  :    Value *value = value_.array_->find( index );
; 966  :    return value ? *value : null;
; 967  : #endif
; 968  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	8
$L12361:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	add	eax, 24					; 00000018H
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L28055:
	lea	esi, DWORD PTR _key$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??AValue@Json@@QBEABV01@I@Z:
	mov	eax, OFFSET FLAT:$T28265
	jmp	___CxxFrameHandler
text$x	ENDS
??AValue@Json@@QBEABV01@I@Z ENDP			; Json::Value::operator[]
PUBLIC	??_ECommentInfo@Value@Json@@QAEPAXI@Z		; Json::Value::CommentInfo::`vector deleting destructor'
; Function compile flags: /Ogtpy
;	COMDAT ??_ECommentInfo@Value@Json@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_ECommentInfo@Value@Json@@QAEPAXI@Z PROC NEAR		; Json::Value::CommentInfo::`vector deleting destructor', COMDAT
; _this$ = esi
	push	ebx
	mov	bl, BYTE PTR ___flags$[esp]
	test	bl, 2
	je	SHORT $L12069
	mov	eax, DWORD PTR [esi-4]
	push	edi
	push	OFFSET FLAT:??1CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::~CommentInfo
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	4
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	test	bl, 1
	je	SHORT $L12070
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L12070:
	mov	eax, edi
	pop	edi
	pop	ebx
	ret	4
$L12069:
	cmp	DWORD PTR [esi], 0
	je	SHORT $L28277
	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+16]
$L28277:
	test	bl, 1
	je	SHORT $L12072
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L12072:
	mov	eax, esi
	pop	ebx
	ret	4
??_ECommentInfo@Value@Json@@QAEPAXI@Z ENDP		; Json::Value::CommentInfo::`vector deleting destructor'
_TEXT	ENDS
PUBLIC	??4CZString@Value@Json@@QAEAAV012@ABV012@@Z	; Json::Value::CZString::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4CZString@Value@Json@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
??4CZString@Value@Json@@QAEAAV012@ABV012@@Z PROC NEAR	; Json::Value::CZString::operator=, COMDAT
; _this$ = edi
; _other$ = eax

; 205  : {

	push	ebx
	push	esi
	mov	esi, eax

; 206  :    CZString temp( other );

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $L28307
	cmp	DWORD PTR [esi], 0
	je	SHORT $L28307
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, 1
	jne	SHORT $L28373
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, 1
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L28373:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+4]
	jmp	SHORT $L28308
$L28307:
	mov	eax, DWORD PTR [esi]
$L28308:
	cmp	DWORD PTR [esi], 0
	je	SHORT $L28309
	mov	edx, DWORD PTR [esi+4]
	xor	ecx, ecx
	test	edx, edx
	setne	cl
	mov	esi, ecx
	jmp	SHORT $L28310
$L28309:
	mov	esi, DWORD PTR [esi+4]
$L28310:

; 207  :    swap( temp );

	mov	ebx, DWORD PTR [edi]

; 208  :    return *this;

	test	ebx, ebx
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi+4], esi
	je	SHORT $L28372
	cmp	eax, 1
	jne	SHORT $L28372
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, 1
	jne	SHORT $L28364
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, 1
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L28364:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [ecx]
	push	ebx
	call	DWORD PTR [edx+8]
$L28372:
	pop	esi
	mov	eax, edi
	pop	ebx

; 209  : }

	ret	0
??4CZString@Value@Json@@QAEAAV012@ABV012@@Z ENDP	; Json::Value::CZString::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Gout_of_range@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gout_of_range@std@@UAEPAXI@Z PROC NEAR		; std::out_of_range::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1out_of_range@std@@UAE@XZ		; std::out_of_range::~out_of_range
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L28377
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L28377:
	mov	eax, esi
	pop	esi
	ret	4
??_Gout_of_range@std@@UAEPAXI@Z ENDP			; std::out_of_range::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx

; 118  : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET FLAT:??_7out_of_range@std@@6B@

; 119  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::out_of_range::out_of_range
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T29483	DD	0ffffffffH
	DD	FLAT:$L29350
$T29481	DD	019930520H
	DD	01H
	DD	FLAT:$T29483
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z PROC NEAR ; std::_Construct<Json::PathArgument,Json::PathArgument>, COMDAT
; __Ptr$ = esi
; __Val$ = edi

; 41   : 	{	// construct object at _Ptr with value _Val

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

	xor	eax, eax
	cmp	esi, eax
	mov	DWORD PTR __$EHRec$[esp+20], eax
	je	SHORT $L29348
	push	-1
	push	eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	push	edi
	mov	ecx, esi
	mov	BYTE PTR [esi+4], al
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], ecx
$L29348:

; 43   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+12]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L29350:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z:
	mov	eax, OFFSET FLAT:$T29481
	jmp	___CxxFrameHandler
text$x	ENDS
??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z ENDP ; std::_Construct<Json::PathArgument,Json::PathArgument>
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T29677	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L29497
	DD	0ffffffffH
	DD	00H
$T29679	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L29490
$T29678	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T29679
$T29671	DD	019930520H
	DD	03H
	DD	FLAT:$T29677
	DD	01H
	DD	FLAT:$T29678
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __First$ = ecx

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	2
$L16177:

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $L16179

; 82   : 		_Al.construct(_Dest, *_First);

	cmp	esi, ebx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	je	SHORT $L29636
	push	-1
	push	ebx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	push	edi
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L29636:
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 28					; 0000001cH
	jmp	SHORT $L16177
$L29490:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $L16182
	npad	3
$L16180:

; 85   : 		_Al.destroy(_Next);

	call	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $L16180
$L16182:

; 86   : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$L29680:
$L16179:

; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L29676:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L29497:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	eax, OFFSET FLAT:$T29671
	jmp	___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T29893	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L29712
	DD	0ffffffffH
	DD	00H
$T29895	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L29686
$T29894	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T29895
$T29887	DD	019930520H
	DD	03H
	DD	FLAT:$T29893
	DD	01H
	DD	FLAT:$T29894
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

$L29688:
	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $L16153

; 82   : 		_Al.construct(_Dest, *_First);

	cmp	esi, ebx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	je	SHORT $L29850
	push	-1
	push	ebx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	push	edi
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L29850:
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 28					; 0000001cH
	jmp	SHORT $L29688
$L29686:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $L16156
	npad	3
$L16154:

; 85   : 		_Al.destroy(_Next);

	call	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $L16154
$L16156:

; 86   : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$L29896:
$L16153:

; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L29892:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L29712:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Uninit_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	eax, OFFSET FLAT:$T29887
	jmp	___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T30104	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L29923
	DD	0ffffffffH
	DD	00H
$T30106	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L29902
$T30105	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T30106
$T30098	DD	019930520H
	DD	03H
	DD	FLAT:$T30104
	DD	01H
	DD	FLAT:$T30105
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
??$_Uninit_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN

	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	1

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

$L29905:
	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $L16142

; 82   : 		_Al.construct(_Dest, *_First);

	cmp	esi, ebx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	je	SHORT $L30061
	push	-1
	push	ebx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	push	edi
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L30061:
	add	esi, 28					; 0000001cH
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 28					; 0000001cH
	jmp	SHORT $L29905
$L29902:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	cmp	esi, edi
	je	SHORT $L16145
	npad	3
$L16143:

; 85   : 		_Al.destroy(_Next);

	call	?destroy@?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::destroy
	add	esi, 28					; 0000001cH
	cmp	esi, edi
	jne	SHORT $L16143
$L16145:

; 86   : 	_RERAISE;

	xor	ebx, ebx
	push	ebx
	push	ebx
	call	__CxxThrowException@8
$L30107:
$L16142:

; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L30103:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L29923:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Uninit_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	eax, OFFSET FLAT:$T30098
	jmp	___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z
_TEXT	SEGMENT
?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z PROC NEAR ; std::allocator<Json::PathArgument>::construct, COMDAT
; __Ptr$ = esi
; __Val$ = edi

; 147  : 		_Construct(_Ptr, _Val);

	jmp	??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z ; std::_Construct<Json::PathArgument,Json::PathArgument>
?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ENDP ; std::allocator<Json::PathArgument>::construct
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$30119 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __Dest$ = edx
; __Al$ = ecx

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$30119[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+8]
	push	edx
	push	eax
	call	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 129  : 	}

	add	esp, 20					; 00000014H
	ret	0
??$_Uninitialized_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *>, COMDAT
; __First$ = ebx
; __Last$ = ecx
; __Dest$ = eax

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	esi
	mov	esi, ecx

; 1049 : 	while (_First != _Last)

	cmp	ebx, esi
	push	edi
	mov	edi, eax
	je	SHORT $L30139
	npad	6
$L16044:

; 1050 : 		*--_Dest = *--_Last;

	push	-1
	push	0
	sub	esi, 36					; 00000024H
	sub	edi, 36					; 00000024H
	push	esi
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	esi, ebx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [edi+28], eax
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR [edi+32], ecx
	jne	SHORT $L16044
$L30139:

; 1051 : 	return (_Dest);

	mov	eax, edi
	pop	edi
	pop	esi

; 1052 : 	}

	ret	0
??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T30557	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L30151
	DD	0ffffffffH
	DD	00H
$T30559	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L30144
$T30558	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T30559
$T30550	DD	019930520H
	DD	03H
	DD	FLAT:$T30557
	DD	01H
	DD	FLAT:$T30558
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; __Val$ = ecx

; 207  : 	{	// copy _Count *_Val to raw _First, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, DWORD PTR __First$[ebp]
	push	edi

; 208  : 	_FwdIt _Next = _First;
; 209  : 
; 210  : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	2
$L15932:

; 211  : 	for (; 0 < _Count; --_Count, ++_First)

	cmp	DWORD PTR __Count$[ebp], ebx
	jbe	SHORT $L15934

; 212  : 		_Al.construct(_First, _Val);

	cmp	esi, ebx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	je	SHORT $L30324
	push	-1
	push	ebx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	push	edi
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], ecx
$L30324:
	mov	ecx, DWORD PTR __Count$[ebp]
	dec	ecx
	add	esi, 36					; 00000024H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Count$[ebp], ecx
	mov	DWORD PTR __First$[ebp], esi
	jmp	SHORT $L15932
$L30144:

; 213  : 	_CATCH_ALL
; 214  : 	for (; _Next != _First; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __First$[ebp]
	xor	ebx, ebx
	cmp	esi, edi
	je	SHORT $L15937
	npad	1
$L15935:

; 215  : 		_Al.destroy(_Next);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L30536
	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L30536:
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	BYTE PTR [esi+4], bl
	add	esi, 36					; 00000024H
	cmp	esi, edi
	jne	SHORT $L15935
$L15937:

; 216  : 	_RERAISE;

	push	ebx
	push	ebx
	call	__CxxThrowException@8
$L30560:
$L15934:

; 217  : 	_CATCH_END
; 218  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L30556:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L30151:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	eax, OFFSET FLAT:$T30550
	jmp	___CxxFrameHandler
text$x	ENDS
??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninitialized_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$30568 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Uninitialized_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __Dest$ = edx
; __Al$ = ecx

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$30568[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+8]
	push	edx
	push	eax
	push	ecx
	call	??$_Uninit_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 129  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z
_TEXT	SEGMENT
__Cat$30576 = -4					; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Uninitialized_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __Dest$ = edx
; __Al$ = ecx

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$30576[esp+4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+8]
	push	edx
	push	eax
	push	ecx
	call	??$_Uninit_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 129  : 	}

	add	esp, 24					; 00000018H
	ret	0
??$_Uninitialized_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$30591 = 12					; size = 1
__Last$ = 12						; size = 4
??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>, COMDAT
; _this$ = ecx
; __Ptr$ = edx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$30591[esp-4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	push	edx
	push	eax
	call	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 16					; 00000010H

; 805  : 		}

	ret	8
??$_Ucopy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAV21@00@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$copy_backward@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00@Z
_TEXT	SEGMENT
__Cat$30601 = -4					; size = 1
__Dest$ = 8						; size = 4
??$copy_backward@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00@Z PROC NEAR ; std::copy_backward<Json::PathArgument *,Json::PathArgument *>, COMDAT
; __First$ = ebx
; __Last$ = ecx

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$30601[esp+4]
	push	eax
	mov	eax, DWORD PTR __Dest$[esp+4]
	call	??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *>

; 1070 : 	}

	add	esp, 8
	ret	0
??$copy_backward@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00@Z ENDP ; std::copy_backward<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@@Z
_TEXT	SEGMENT
__Cat$30609 = -4					; size = 1
__Val$ = 8						; size = 4
__Al$ = 12						; size = 4
??$_Uninitialized_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; __First$ = edx
; __Count$ = ecx

; 255  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ecx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

	mov	eax, DWORD PTR __Cat$30609[esp+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Val$[esp+8]
	push	edx
	call	??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >

; 258  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Uninitialized_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@@Z ENDP ; std::_Uninitialized_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@Viterator@01@0PAV21@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$30624 = 12					; size = 1
__Last$ = 12						; size = 4
??$_Ucopy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@Viterator@01@0PAV21@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator>, COMDAT
; _this$ = ecx
; __Ptr$ = edx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$30624[esp-4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	push	edx
	push	eax
	push	ecx
	call	??$_Uninit_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 20					; 00000014H

; 805  : 		}

	ret	8
??$_Ucopy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@Viterator@01@0PAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Ucopy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@Vconst_iterator@01@0PAV21@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Cat$30641 = 12					; size = 1
__Last$ = 12						; size = 4
??$_Ucopy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@Vconst_iterator@01@0PAV21@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator>, COMDAT
; _this$ = ecx
; __Ptr$ = edx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$30641[esp-4]
	push	eax
	mov	eax, DWORD PTR __Last$[esp]
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	push	edx
	push	eax
	push	ecx
	call	??$_Uninit_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 20					; 00000014H

; 805  : 		}

	ret	8
??$_Ucopy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@Vconst_iterator@01@0PAV21@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Ucopy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0out_of_range@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0out_of_range@std@@QAE@ABV01@@Z PROC NEAR		; std::out_of_range::out_of_range, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET FLAT:??_7out_of_range@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0out_of_range@std@@QAE@ABV01@@Z ENDP			; std::out_of_range::out_of_range
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z
_TEXT	SEGMENT
__Cat$30662 = -4					; size = 1
_this$ = 8						; size = 4
?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ufill, COMDAT
; __Ptr$ = edi
; __Count$ = esi
; __Val$ = ecx

; 877  : 		{	// copy initializing _Count * _Val, using allocator

	push	ecx

; 878  : 		_Uninitialized_fill_n(_Ptr, _Count, _Val, this->_Alval);

	mov	eax, DWORD PTR __Cat$30662[esp+4]
	push	eax
	push	esi
	push	edi
	call	??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >

; 879  : 		return (_Ptr + _Count);

	lea	ecx, DWORD PTR [esi+esi*8]
	lea	eax, DWORD PTR [edi+ecx*4]

; 880  : 		}

	add	esp, 16					; 00000010H
	ret	4
?_Ufill@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV34@IABV34@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ufill
_TEXT	ENDS
PUBLIC	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
;	COMDAT ?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_placement$ = 12					; size = 4
?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z PROC NEAR ; Json::Value::setComment, COMDAT
; _comment$ = eax

; 1257 :    setComment( comment.c_str(), placement );

	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L30680
	mov	ecx, DWORD PTR _placement$[esp-4]
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp]
	push	eax
	call	?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ; Json::Value::setComment

; 1258 : }

	ret	8

; 1257 :    setComment( comment.c_str(), placement );

$L30680:
	mov	ecx, DWORD PTR _placement$[esp-4]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp]
	add	eax, 4
	push	eax
	call	?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ; Json::Value::setComment

; 1258 : }

	ret	8
?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ENDP ; Json::Value::setComment
_TEXT	ENDS
PUBLIC	?isMember@Value@Json@@QBE_NPBD@Z		; Json::Value::isMember
; Function compile flags: /Ogtpy
;	COMDAT ?isMember@Value@Json@@QBE_NPBD@Z
_TEXT	SEGMENT
?isMember@Value@Json@@QBE_NPBD@Z PROC NEAR		; Json::Value::isMember, COMDAT
; _this$ = ecx
; _key$ = eax

; 1110 :    const Value *value = &((*this)[key]);

	push	eax
	push	ecx
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]

; 1111 :    return value != &null;

	xor	edx, edx
	cmp	eax, OFFSET FLAT:?null@Value@Json@@2V12@B ; Json::Value::null
	setne	dl
	mov	al, dl

; 1112 : }

	ret	0
?isMember@Value@Json@@QBE_NPBD@Z ENDP			; Json::Value::isMember
_TEXT	ENDS
PUBLIC	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; Json::Value::operator[], COMDAT
; _key$ = eax

; 1048 :    return (*this)[ key.c_str() ];

	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L30700
	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	eax, DWORD PTR _this$[esp]
	push	eax
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]

; 1049 : }

	ret	4

; 1048 :    return (*this)[ key.c_str() ];

$L30700:
	add	eax, 4
	push	eax
	mov	eax, DWORD PTR _this$[esp]
	push	eax
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]

; 1049 : }

	ret	4
??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::operator[]
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T32606	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L32200
	DD	0ffffffffH
	DD	00H
$T32608	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L32193
$T32607	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T32608
$T32599	DD	019930520H
	DD	03H
	DD	FLAT:$T32606
	DD	01H
	DD	FLAT:$T32607
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Last$ = 8						; size = 4
__Dest$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >, COMDAT
; __First$ = ecx

; 77   : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	esi
	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 78   : 	_FwdIt _Next = _Dest;
; 79   : 
; 80   : 	_TRY_BEGIN

	xor	ebx, ebx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR __Next$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+12], ebx
	npad	2
$L16168:

; 81   : 	for (; _First != _Last; ++_Dest, ++_First)

	cmp	edi, DWORD PTR __Last$[ebp]
	je	SHORT $L16170

; 82   : 		_Al.construct(_Dest, *_First);

	cmp	esi, ebx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	je	SHORT $L32373
	push	-1
	push	ebx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	push	edi
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [edi+28]
	mov	DWORD PTR [esi+28], eax
	mov	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+32], ecx
$L32373:
	add	esi, 36					; 00000024H
	mov	BYTE PTR __$EHRec$[ebp+12], bl
	mov	DWORD PTR __Dest$[ebp], esi
	add	edi, 36					; 00000024H
	jmp	SHORT $L16168
$L32193:

; 83   : 	_CATCH_ALL
; 84   : 	for (; _Next != _Dest; ++_Next)

	mov	esi, DWORD PTR __Next$[ebp]
	mov	edi, DWORD PTR __Dest$[ebp]
	xor	ebx, ebx
	cmp	esi, edi
	je	SHORT $L16173
	npad	5
$L16171:

; 85   : 		_Al.destroy(_Next);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L32585
	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L32585:
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	BYTE PTR [esi+4], bl
	add	esi, 36					; 00000024H
	cmp	esi, edi
	jne	SHORT $L16171
$L16173:

; 86   : 	_RERAISE;

	push	ebx
	push	ebx
	call	__CxxThrowException@8
$L32609:
$L16170:

; 87   : 	_CATCH_END
; 88   : 	return (_Dest);
; 89   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L32605:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L32200:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z:
	mov	eax, OFFSET FLAT:$T32599
	jmp	___CxxFrameHandler
text$x	ENDS
??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
; Function compile flags: /Ogtpy
;	COMDAT ??$_Uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@@Z
_TEXT	SEGMENT
__Cat$32617 = -4					; size = 1
__First$ = 8						; size = 4
__Al$ = 12						; size = 4
??$_Uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >, COMDAT
; __Last$ = edx
; __Dest$ = ecx

; 126  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ecx

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$32617[esp+4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+8]
	push	edx
	call	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >

; 129  : 	}

	add	esp, 16					; 00000010H
	ret	0
??$_Uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
__Cat$32632 = 12					; size = 1
__First$ = 12						; size = 4
??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<Json::PathArgument *>, COMDAT
; __Last$ = edx
; __Ptr$ = ecx

; 802  : 		{	// copy initializing [_First, _Last), using allocator
; 803  : 		return (_Uninitialized_copy(_First, _Last,
; 804  : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR __Cat$32632[esp-4]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __First$[esp+4]
	push	edx
	call	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
	add	esp, 12					; 0000000cH

; 805  : 		}

	ret	8
??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<Json::PathArgument *>
_TEXT	ENDS
PUBLIC	??1Value@Json@@QAE@XZ				; Json::Value::~Value
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T33470	DD	0ffffffffH
	DD	FLAT:$L32645
	DD	00H
	DD	FLAT:$L32760
	DD	0ffffffffH
	DD	FLAT:$L33283
$T33462	DD	019930520H
	DD	03H
	DD	FLAT:$T33470
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
_TEXT	SEGMENT
$T33426 = -84						; size = 4
$T32640 = -80						; size = 28
$T32639 = -52						; size = 40
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Where$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase, COMDAT

; 590  : 		{	// erase element at _Where

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z
	push	eax

; 591  : 		if (_Isnil(_Where._Mynode()))

	mov	eax, DWORD PTR __Where$[esp+8]
	mov	DWORD PTR fs:__except_list, esp
	mov	cl, BYTE PTR [eax+41]
	sub	esp, 72					; 00000048H
	test	cl, cl
	push	esi
	push	edi
	je	SHORT $L14776

; 592  : 			_THROW(out_of_range, "invalid map/set<T> iterator");

	push	27					; 0000001bH
	mov	edi, 15					; 0000000fH
	xor	esi, esi
	push	OFFSET FLAT:??_C@_0BM@PAPJHAGI@invalid?5map?1set?$DMT?$DO?5iterator?$AA@
	lea	ecx, DWORD PTR $T32640[esp+100]
	mov	DWORD PTR $T32640[esp+124], edi
	mov	DWORD PTR $T32640[esp+120], esi
	mov	BYTE PTR $T32640[esp+104], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T32639[esp+92]
	mov	DWORD PTR __$EHRec$[esp+100], esi
	call	??0exception@@QAE@XZ			; exception::exception
	push	-1
	mov	BYTE PTR __$EHRec$[esp+104], 1
	push	esi
	lea	eax, DWORD PTR $T32640[esp+100]
	push	eax
	lea	ecx, DWORD PTR $T32639[esp+116]
	mov	DWORD PTR $T32639[esp+104], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	DWORD PTR $T32639[esp+140], edi
	mov	DWORD PTR $T32639[esp+136], esi
	mov	BYTE PTR $T32639[esp+120], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	OFFSET FLAT:__TI3?AVout_of_range@std@@
	lea	ecx, DWORD PTR $T32639[esp+96]
	mov	BYTE PTR __$EHRec$[esp+104], 0
	push	ecx
	mov	DWORD PTR $T32639[esp+100], OFFSET FLAT:??_7out_of_range@std@@6B@
	call	__CxxThrowException@8
$L33471:
$L14776:
	push	ebx
	push	ebp

; 593  : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 594  : 		++_Where;	// save successor iterator for return

	lea	edx, DWORD PTR __Where$[esp+96]
	mov	ebp, eax
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc

; 595  : 
; 596  : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 597  : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 598  : 		_Nodeptr _Pnode = _Erasednode;
; 599  : 
; 600  : 		if (_Isnil(_Left(_Pnode)))

	mov	eax, DWORD PTR [ebp]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	je	SHORT $L14789

; 601  : 			_Fixnode = _Right(_Pnode);	// must stitch up right subtree

	mov	edi, DWORD PTR [ebp+8]

; 602  : 		else if (_Isnil(_Right(_Pnode)))

	jmp	SHORT $L33465
$L14789:
	mov	edx, DWORD PTR [ebp+8]
	mov	cl, BYTE PTR [edx+41]
	test	cl, cl
	je	SHORT $L14791

; 603  : 			_Fixnode = _Left(_Pnode);	// must stitch up left subtree

	mov	edi, eax

; 604  : 		else

	jmp	SHORT $L33465
$L14791:

; 605  : 			{	// two subtrees, must lift successor node to replace erased
; 606  : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 607  : 			_Fixnode = _Right(_Pnode);	// _Fixnode is its only subtree

	mov	ecx, DWORD PTR __Where$[esp+96]

; 608  : 			}
; 609  : 
; 610  : 		if (_Pnode == _Erasednode)

	cmp	ecx, ebp
	mov	edi, DWORD PTR [ecx+8]
	jne	SHORT $L14793
$L33465:

; 611  : 			{	// at most one subtree, relink it
; 612  : 			_Fixnodeparent = _Parent(_Erasednode);
; 613  : 			if (!_Isnil(_Fixnode))

	mov	al, BYTE PTR [edi+41]
	test	al, al
	mov	esi, DWORD PTR [ebp+4]
	jne	SHORT $L14794

; 614  : 				_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$L14794:

; 615  : 
; 616  : 			if (_Root() == _Erasednode)

	mov	edx, DWORD PTR _this$[esp+96]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $L14795

; 617  : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi

; 618  : 			else if (_Left(_Fixnodeparent) == _Erasednode)

	jmp	SHORT $L14798
$L14795:
	cmp	DWORD PTR [esi], ebp
	jne	SHORT $L14797

; 619  : 				_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 620  : 			else

	jmp	SHORT $L14798
$L14797:

; 621  : 				_Right(_Fixnodeparent) = _Fixnode;	// link down to right

	mov	DWORD PTR [esi+8], edi
$L14798:

; 622  : 
; 623  : 			if (_Lmost() == _Erasednode)

	mov	ebx, DWORD PTR [edx+4]
	cmp	DWORD PTR [ebx], ebp
	jne	SHORT $L14799

; 624  : 				_Lmost() = _Isnil(_Fixnode)
; 625  : 					? _Fixnodeparent	// smallest is parent of erased node
; 626  : 					: _Min(_Fixnode);	// smallest in relinked subtree

	mov	al, BYTE PTR [edi+41]
	test	al, al
	je	SHORT $L32641
	mov	eax, esi
	jmp	SHORT $L32642
$L32641:
	mov	eax, edi
	call	?_Min@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Min
	mov	edx, DWORD PTR _this$[esp+96]
$L32642:
	mov	DWORD PTR [ebx], eax
$L14799:

; 627  : 
; 628  : 			if (_Rmost() == _Erasednode)

	mov	ebx, DWORD PTR [edx+4]
	cmp	DWORD PTR [ebx+8], ebp
	jne	SHORT $L33118

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	al, BYTE PTR [edi+41]
	test	al, al
	je	SHORT $L32643
	mov	eax, esi
	mov	DWORD PTR [ebx+8], eax

; 632  : 			}
; 633  : 		else

	jmp	SHORT $L33118
$L32643:

; 629  : 				_Rmost() = _Isnil(_Fixnode)
; 630  : 					? _Fixnodeparent	// largest is parent of erased node
; 631  : 					: _Max(_Fixnode);	// largest in relinked subtree

	mov	eax, edi
	call	?_Max@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@KAPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Max
	mov	edx, DWORD PTR _this$[esp+96]
	mov	DWORD PTR [ebx+8], eax

; 632  : 			}
; 633  : 		else

	jmp	SHORT $L33118
$L14793:

; 634  : 			{	// erased has two subtrees, _Pnode is successor to erased
; 635  : 			_Parent(_Left(_Erasednode)) = _Pnode;	// link left up

	mov	DWORD PTR [eax+4], ecx

; 636  : 			_Left(_Pnode) = _Left(_Erasednode);	// link successor down

	mov	eax, DWORD PTR [ebp]
	mov	DWORD PTR [ecx], eax

; 637  : 
; 638  : 			if (_Pnode == _Right(_Erasednode))

	cmp	ecx, DWORD PTR [ebp+8]
	jne	SHORT $L14802

; 639  : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, ecx

; 640  : 			else

	jmp	SHORT $L14803
$L14802:

; 641  : 				{	// successor further down, link in place of erased
; 642  : 				_Fixnodeparent = _Parent(_Pnode);	// parent is successor's
; 643  : 				if (!_Isnil(_Fixnode))

	mov	al, BYTE PTR [edi+41]
	test	al, al
	mov	esi, DWORD PTR [ecx+4]
	jne	SHORT $L14804

; 644  : 					_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$L14804:

; 645  : 				_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 646  : 				_Right(_Pnode) = _Right(_Erasednode);	// link successor down

	mov	edx, DWORD PTR [ebp+8]
	mov	DWORD PTR [ecx+8], edx

; 647  : 				_Parent(_Right(_Erasednode)) = _Pnode;	// link right up

	mov	eax, DWORD PTR [ebp+8]
	mov	DWORD PTR [eax+4], ecx
$L14803:

; 648  : 				}
; 649  : 
; 650  : 			if (_Root() == _Erasednode)

	mov	edx, DWORD PTR _this$[esp+96]
	mov	eax, DWORD PTR [edx+4]
	cmp	DWORD PTR [eax+4], ebp
	jne	SHORT $L14805

; 651  : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [eax+4], ecx

; 652  : 			else if (_Left(_Parent(_Erasednode)) == _Erasednode)

	jmp	SHORT $L14808
$L14805:
	mov	eax, DWORD PTR [ebp+4]
	cmp	DWORD PTR [eax], ebp
	jne	SHORT $L14807

; 653  : 				_Left(_Parent(_Erasednode)) = _Pnode;	// link down to left

	mov	DWORD PTR [eax], ecx

; 654  : 			else

	jmp	SHORT $L14808
$L14807:

; 655  : 				_Right(_Parent(_Erasednode)) = _Pnode;	// link down to right

	mov	DWORD PTR [eax+8], ecx
$L14808:

; 656  : 
; 657  : 			_Parent(_Pnode) = _Parent(_Erasednode);	// link successor up

	mov	eax, DWORD PTR [ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 658  : 			std::swap(_Color(_Pnode), _Color(_Erasednode));	// recolor it

	mov	dl, BYTE PTR [ebp+40]
	mov	al, BYTE PTR [ecx+40]
	mov	BYTE PTR [ecx+40], dl
	mov	edx, DWORD PTR _this$[esp+96]
	mov	BYTE PTR [ebp+40], al
$L33118:

; 659  : 			}
; 660  : 
; 661  : 		if (_Color(_Erasednode) == _Black)

	mov	al, BYTE PTR [ebp+40]
	mov	bl, 1
	cmp	al, bl
	jne	$L14814

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	eax, DWORD PTR [edx+4]
	cmp	edi, DWORD PTR [eax+4]
	je	$L14817
	npad	6
$L14815:
	cmp	BYTE PTR [edi+40], bl
	jne	$L14817

; 665  : 				if (_Fixnode == _Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $L14818

; 666  : 					{	// fixup left subtree
; 667  : 					_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 668  : 					if (_Color(_Pnode) == _Red)

	mov	al, BYTE PTR [ecx+40]
	test	al, al
	jne	SHORT $L14819

; 669  : 						{	// rotate red up from right subtree
; 670  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [ecx+40], bl

; 671  : 						_Color(_Fixnodeparent) = _Red;
; 672  : 						_Lrotate(_Fixnodeparent);

	push	edx
	mov	ecx, esi
	mov	BYTE PTR [esi+40], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate

; 673  : 						_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _this$[esp+96]
$L14819:

; 674  : 						}
; 675  : 
; 676  : 					if (_Isnil(_Pnode))

	mov	al, BYTE PTR [ecx+41]
	test	al, al

; 677  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 678  : 					else if (_Color(_Left(_Pnode)) == _Black

	jne	SHORT $L33468

; 679  : 						&& _Color(_Right(_Pnode)) == _Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+40], bl
	jne	SHORT $L14822
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+40], bl
	je	SHORT $L33469
$L14822:

; 680  : 						{	// redden right subtree with black children
; 681  : 						_Color(_Pnode) = _Red;
; 682  : 						_Fixnode = _Fixnodeparent;
; 683  : 						}
; 684  : 					else
; 685  : 						{	// must rearrange right subtree
; 686  : 						if (_Color(_Right(_Pnode)) == _Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+40], bl
	jne	SHORT $L14824

; 687  : 							{	// rotate red up from left sub-subtree
; 688  : 							_Color(_Left(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx]
	mov	BYTE PTR [eax+40], bl

; 689  : 							_Color(_Pnode) = _Red;
; 690  : 							_Rrotate(_Pnode);

	push	edx
	mov	BYTE PTR [ecx+40], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate

; 691  : 							_Pnode = _Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _this$[esp+96]
$L14824:

; 692  : 							}
; 693  : 
; 694  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+40]
	mov	BYTE PTR [ecx+40], al

; 695  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+40], bl

; 696  : 						_Color(_Right(_Pnode)) = _Black;

	mov	ecx, DWORD PTR [ecx+8]
	mov	BYTE PTR [ecx+40], bl

; 697  : 						_Lrotate(_Fixnodeparent);

	push	edx
	mov	ecx, esi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate

; 698  : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $L14817
$L14818:

; 699  : 						}
; 700  : 					}
; 701  : 				else
; 702  : 					{	// fixup right subtree
; 703  : 					_Pnode = _Left(_Fixnodeparent);
; 704  : 					if (_Color(_Pnode) == _Red)

	mov	al, BYTE PTR [ecx+40]
	test	al, al
	jne	SHORT $L14826

; 705  : 						{	// rotate red up from left subtree
; 706  : 						_Color(_Pnode) = _Black;

	mov	BYTE PTR [ecx+40], bl

; 707  : 						_Color(_Fixnodeparent) = _Red;
; 708  : 						_Rrotate(_Fixnodeparent);

	push	edx
	mov	ecx, esi
	mov	BYTE PTR [esi+40], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate

; 709  : 						_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _this$[esp+96]
$L14826:

; 710  : 						}
; 711  : 					if (_Isnil(_Pnode))

	mov	al, BYTE PTR [ecx+41]
	test	al, al

; 712  : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 713  : 					else if (_Color(_Right(_Pnode)) == _Black

	jne	SHORT $L33468

; 714  : 						&& _Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+40], bl
	jne	SHORT $L14829
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+40], bl
	jne	SHORT $L14829
$L33469:

; 715  : 						{	// redden left subtree with black children
; 716  : 						_Color(_Pnode) = _Red;

	mov	BYTE PTR [ecx+40], 0
$L33468:

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

	mov	ecx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [ecx+4]

; 717  : 						_Fixnode = _Fixnodeparent;

	mov	edi, esi
	cmp	edi, eax
	mov	esi, DWORD PTR [esi+4]
	jne	$L14815

; 662  : 			{	// erasing black link, must recolor/rebalance tree
; 663  : 			for (; _Fixnode != _Root() && _Color(_Fixnode) == _Black;
; 664  : 				_Fixnodeparent = _Parent(_Fixnode))

	jmp	SHORT $L14817
$L14829:

; 718  : 						}
; 719  : 					else
; 720  : 						{	// must rearrange left subtree
; 721  : 						if (_Color(_Left(_Pnode)) == _Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+40], bl
	jne	SHORT $L14831

; 722  : 							{	// rotate red up from right sub-subtree
; 723  : 							_Color(_Right(_Pnode)) = _Black;

	mov	eax, DWORD PTR [ecx+8]
	mov	BYTE PTR [eax+40], bl

; 724  : 							_Color(_Pnode) = _Red;
; 725  : 							_Lrotate(_Pnode);

	push	edx
	mov	BYTE PTR [ecx+40], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lrotate

; 726  : 							_Pnode = _Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _this$[esp+96]
$L14831:

; 727  : 							}
; 728  : 
; 729  : 						_Color(_Pnode) = _Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+40]
	mov	BYTE PTR [ecx+40], al

; 730  : 						_Color(_Fixnodeparent) = _Black;

	mov	BYTE PTR [esi+40], bl

; 731  : 						_Color(_Left(_Pnode)) = _Black;

	mov	ecx, DWORD PTR [ecx]
	mov	BYTE PTR [ecx+40], bl

; 732  : 						_Rrotate(_Fixnodeparent);

	push	edx
	mov	ecx, esi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Rrotate
$L14817:

; 733  : 						break;	// tree now recolored/rebalanced
; 734  : 						}
; 735  : 					}
; 736  : 
; 737  : 			_Color(_Fixnode) = _Black;	// ensure stopping node is black

	mov	BYTE PTR [edi+40], bl
$L14814:

; 738  : 			}
; 739  : 
; 740  : 		this->_Alnod.destroy(_Erasednode);	// destroy, free erased node

	lea	esi, DWORD PTR [ebp+16]
	mov	DWORD PTR $T33426[esp+100], esi
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+108], 2
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	mov	DWORD PTR __$EHRec$[esp+108], -1
	call	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString

; 741  : 		this->_Alnod.deallocate(_Erasednode, 1);

	push	ebp
	call	??3@YAXPAX@Z				; operator delete

; 742  : 
; 743  : 		if (0 < _Mysize)

	mov	ecx, DWORD PTR _this$[esp+100]
	mov	eax, DWORD PTR [ecx+8]
	add	esp, 4
	test	eax, eax
	pop	ebp
	pop	ebx
	jbe	SHORT $L14832

; 744  : 			--_Mysize;

	dec	eax
	mov	DWORD PTR [ecx+8], eax
$L14832:

; 745  : 
; 746  : 		return (_Where);	// return successor iterator

	mov	edx, DWORD PTR __Where$[esp+88]
	mov	eax, DWORD PTR ___$ReturnUdt$[esp+88]

; 747  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+92]
	pop	edi
	mov	DWORD PTR [eax], edx
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 84					; 00000054H
	ret	12					; 0000000cH
$L33467:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L32645:
	lea	ecx, DWORD PTR $T32640[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L32760:
	lea	ecx, DWORD PTR $T32639[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
$L33283:
	mov	esi, DWORD PTR $T33426[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z:
	mov	eax, OFFSET FLAT:$T33462
	jmp	___CxxFrameHandler
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T33752	DD	0ffffffffH
	DD	FLAT:$L33479
	DD	00H
	DD	FLAT:$L33588
$T33749	DD	019930520H
	DD	02H
	DD	FLAT:$T33752
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T33478 = -80						; size = 28
$T33477 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen, COMDAT

; 883  : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx

; 884  : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	xor	ebx, ebx
	push	OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T33478[esp+92]
	mov	DWORD PTR $T33478[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T33478[esp+112], ebx
	mov	BYTE PTR $T33478[esp+96], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T33477[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], ebx
	call	??0exception@@QAE@XZ			; exception::exception
	push	-1
	mov	BYTE PTR __$EHRec$[esp+96], 1
	push	ebx
	lea	eax, DWORD PTR $T33478[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T33477[esp+108]
	mov	DWORD PTR $T33477[esp+96], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	DWORD PTR $T33477[esp+132], 15		; 0000000fH
	mov	DWORD PTR $T33477[esp+128], ebx
	mov	BYTE PTR $T33477[esp+112], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T33477[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], bl
	push	ecx
	mov	DWORD PTR $T33477[esp+92], OFFSET FLAT:??_7length_error@std@@6B@
	call	__CxxThrowException@8
	pop	ebx
$L33753:
$L33751:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L33479:
	lea	ecx, DWORD PTR $T33478[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L33588:
	lea	ecx, DWORD PTR $T33477[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ:
	mov	eax, OFFSET FLAT:$T33749
	jmp	___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T34572	DD	0ffffffffH
	DD	FLAT:$L33766
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T34574	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L33763
$T34575	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L33765
$T34573	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T34574
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T34575
$T34562	DD	019930520H
	DD	05H
	DD	FLAT:$T34572
	DD	02H
	DD	FLAT:$T34573
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABVPathArgument@Json@@@Z
_TEXT	SEGMENT
tv534 = -68						; size = 4
__Newvec$14719 = -68					; size = 4
$T34280 = -64						; size = 4
__Ptr$14720 = -64					; size = 4
tv550 = -60						; size = 4
__Capacity$ = -60					; size = 4
__Tmp$ = -56						; size = 36
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
__Cat$34459 = 12					; size = 1
__Cat$34445 = 12					; size = 1
__Cat$34420 = 12					; size = 1
__Cat$34397 = 12					; size = 1
__Cat$34034 = 12					; size = 1
__Cat$34012 = 12					; size = 1
__Cat$33988 = 12					; size = 1
__Where$ = 12						; size = 4
__Count$ = 16						; size = 4
?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABVPathArgument@Json@@@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Insert_n, COMDAT
; __Val$ = ecx

; 809  : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABVPathArgument@Json@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	push	ebx
	mov	ebx, DWORD PTR __Count$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _this$[ebp]
	mov	DWORD PTR __$EHRec$[ebp], esp

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	push	-1
	mov	esi, ecx
	push	0
	push	esi
	lea	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR __Tmp$[ebp+24], 15		; 0000000fH
	mov	DWORD PTR __Tmp$[ebp+20], 0
	mov	BYTE PTR __Tmp$[ebp+4], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+32]
	mov	DWORD PTR __Tmp$[ebp+28], eax
	mov	DWORD PTR __Tmp$[ebp+32], ecx
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[ebp+12], esi

; 811  : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR [edi+4]
	cmp	ecx, esi
	je	SHORT $L33898
	mov	edx, DWORD PTR [edi+12]
	sub	edx, ecx
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR __Capacity$[ebp], eax
	mov	esi, eax
$L33898:

; 812  : 
; 813  : 		if (_Count == 0)

	test	ebx, ebx
	je	$L14739

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

	test	ecx, ecx
	jne	SHORT $L33920
	xor	eax, eax
	jmp	SHORT $L33921
$L33920:
	mov	edx, DWORD PTR [edi+8]
	sub	edx, ecx
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$L33921:
	mov	edx, 119304647				; 071c71c7H
	sub	edx, eax
	cmp	edx, ebx
	jae	SHORT $L14715

; 816  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
$L34576:
$L14715:

; 817  : 		else if (_Capacity < size() + _Count)

	test	ecx, ecx
	jne	SHORT $L33927
	xor	eax, eax
	jmp	SHORT $L33928
$L33927:
	mov	edx, DWORD PTR [edi+8]
	sub	edx, ecx
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$L33928:
	add	eax, ebx
	cmp	esi, eax
	jae	$L14717

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, esi
	shr	eax, 1
	mov	edx, 119304647				; 071c71c7H
	sub	edx, eax
	cmp	edx, esi
	jae	SHORT $L33760
	mov	DWORD PTR __Capacity$[ebp], 0
	mov	esi, DWORD PTR __Capacity$[ebp]
	jmp	SHORT $L33761
$L33760:
	add	esi, eax
	mov	DWORD PTR __Capacity$[ebp], esi
$L33761:

; 821  : 			if (_Capacity < size() + _Count)

	test	ecx, ecx
	jne	SHORT $L33950
	xor	eax, eax
	jmp	SHORT $L33951
$L33950:
	mov	edx, DWORD PTR [edi+8]
	sub	edx, ecx
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$L33951:
	add	eax, ebx
	cmp	esi, eax
	jae	SHORT $L14718

; 822  : 				_Capacity = size() + _Count;

	test	ecx, ecx
	jne	SHORT $L33957
	xor	eax, eax
	jmp	SHORT $L33958
$L33957:
	mov	edx, DWORD PTR [edi+8]
	sub	edx, ecx
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$L33958:
	add	eax, ebx
	mov	DWORD PTR __Capacity$[ebp], eax
	mov	esi, eax
$L14718:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	lea	eax, DWORD PTR [esi+esi*8]
	shl	eax, 2
	push	eax
	call	??2@YAPAXI@Z				; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

	mov	edx, DWORD PTR __Cat$33988[ebp]
	mov	ecx, DWORD PTR [edi+4]
	push	edx
	push	eax
	mov	DWORD PTR __Newvec$14719[ebp], eax
	mov	DWORD PTR __Ptr$14720[ebp], eax
	mov	eax, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

	mov	ecx, DWORD PTR __Cat$34012[ebp]
	add	esp, 16					; 00000010H
	push	ecx
	mov	esi, eax
	push	ebx
	push	esi
	lea	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR __Ptr$14720[ebp], esi
	call	??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	ecx, DWORD PTR [edi+8]
	lea	edx, DWORD PTR [ebx+ebx*8]
	lea	eax, DWORD PTR [esi+edx*4]
	mov	edx, DWORD PTR __Cat$34034[ebp]
	add	esp, 12					; 0000000cH
	push	edx
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR __Ptr$14720[ebp], eax
	call	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >

; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

	mov	esi, DWORD PTR [edi+4]
	add	esp, 12					; 0000000cH
	test	esi, esi
	jne	SHORT $L34045
	xor	eax, eax
	jmp	SHORT $L34046
$L34045:
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$L34046:
	add	ebx, eax

; 838  : 			if (_Myfirst != 0)

	test	esi, esi
	je	SHORT $L34373

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR [edi+8]
	cmp	esi, eax
	mov	DWORD PTR $T34280[ebp], eax
	je	SHORT $L34369
$L34367:
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L34345
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	mov	eax, DWORD PTR $T34280[ebp]
	add	esp, 4
$L34345:
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	BYTE PTR [esi+4], 0
	add	esi, 36					; 00000024H
	cmp	esi, eax
	jne	SHORT $L34367
$L34369:

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L34373:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR __Capacity$[ebp]
	lea	edx, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR __Newvec$14719[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]

; 844  : 			_Mylast = _Newvec + _Count;

	lea	edx, DWORD PTR [ebx+ebx*8]
	mov	DWORD PTR [edi+12], ecx
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [edi+8], ecx

; 845  : 			_Myfirst = _Newvec;

	mov	DWORD PTR [edi+4], eax

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

	jmp	$L14739
$L33763:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

	mov	esi, DWORD PTR __Newvec$14719[ebp]
	mov	edi, DWORD PTR __Ptr$14720[ebp]
	mov	eax, esi
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 834  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L34577:
$L14717:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, DWORD PTR __Where$[ebp]
	mov	edx, ecx
	sub	edx, esi
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ebx
	mov	DWORD PTR tv534[ebp], ecx

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	eax, DWORD PTR [ebx+ebx*8]
	jae	$L14730
	mov	edx, DWORD PTR __Cat$34397[ebp]
	shl	eax, 2
	mov	DWORD PTR tv550[ebp], eax
	push	edx
	add	eax, esi
	push	eax
	push	ecx
	mov	ecx, esi
	call	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >

; 851  : 
; 852  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [edi+8]
	mov	edx, ecx
	sub	edx, esi
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR __Cat$34420[ebp]
	push	edx
	sub	ebx, eax
	push	ebx
	push	ecx
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >

; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv550[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR [edi+8]
	add	ecx, eax

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

	mov	ebx, ecx
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+8], ecx
	sub	ebx, eax

; 863  : 			}
; 864  : 		else

	jmp	SHORT $L34571
$L33765:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [ecx+8]
	mov	edx, DWORD PTR __Where$[ebp]
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	add	edi, eax
	add	eax, edx
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 857  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L34578:
$L14730:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

	shl	eax, 2
	mov	ebx, ecx
	sub	ebx, eax
	mov	DWORD PTR tv550[ebp], eax
	mov	eax, DWORD PTR __Cat$34445[ebp]
	push	eax
	push	ecx
	push	ecx
	mov	ecx, ebx
	call	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR __Cat$34459[ebp]
	push	ecx
	mov	DWORD PTR [edi+8], eax
	mov	eax, DWORD PTR tv534[ebp]
	mov	ecx, ebx
	mov	ebx, esi
	call	??$_Copy_backward_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<Json::PathArgument *,Json::PathArgument *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

	mov	edx, DWORD PTR tv550[ebp]
	add	esp, 16					; 00000010H
	lea	ebx, DWORD PTR [edx+esi]
$L34571:
	mov	eax, esi
	lea	edi, DWORD PTR __Tmp$[ebp]
	call	??$fill@PAVPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@0ABV12@@Z ; std::fill<Json::PathArgument *,Json::PathArgument>
$L14739:

; 873  : 			}
; 874  : 		}

	cmp	DWORD PTR __Tmp$[ebp+24], 16		; 00000010H
	jb	SHORT $L34551
	mov	eax, DWORD PTR __Tmp$[ebp+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L34551:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$L34570:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L33766:
	lea	esi, DWORD PTR __Tmp$[ebp]
	jmp	??1PathArgument@Json@@QAE@XZ
__ehhandler$?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABVPathArgument@Json@@@Z:
	mov	eax, OFFSET FLAT:$T34562
	jmp	___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T34858	DD	0ffffffffH
	DD	FLAT:$L34585
	DD	00H
	DD	FLAT:$L34694
$T34855	DD	019930520H
	DD	02H
	DD	FLAT:$T34858
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T34584 = -80						; size = 28
$T34583 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen, COMDAT

; 883  : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx

; 884  : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	xor	ebx, ebx
	push	OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T34584[esp+92]
	mov	DWORD PTR $T34584[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T34584[esp+112], ebx
	mov	BYTE PTR $T34584[esp+96], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T34583[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], ebx
	call	??0exception@@QAE@XZ			; exception::exception
	push	-1
	mov	BYTE PTR __$EHRec$[esp+96], 1
	push	ebx
	lea	eax, DWORD PTR $T34584[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T34583[esp+108]
	mov	DWORD PTR $T34583[esp+96], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	DWORD PTR $T34583[esp+132], 15		; 0000000fH
	mov	DWORD PTR $T34583[esp+128], ebx
	mov	BYTE PTR $T34583[esp+112], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T34583[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], bl
	push	ecx
	mov	DWORD PTR $T34583[esp+92], OFFSET FLAT:??_7length_error@std@@6B@
	call	__CxxThrowException@8
	pop	ebx
$L34859:
$L34857:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L34585:
	lea	ecx, DWORD PTR $T34584[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L34694:
	lea	ecx, DWORD PTR $T34583[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ:
	mov	eax, OFFSET FLAT:$T34855
	jmp	___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z
_TEXT	SEGMENT
tv509 = -4						; size = 4
tv478 = -4						; size = 4
__Tmp$ = 8						; size = 4
_this$ = 8						; size = 4
tv491 = 12						; size = 4
__Where$ = 12						; size = 4
?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n, COMDAT
; __Count$ = ecx
; __Val$ = eax

; 809  : 		{	// insert _Count * _Val at _Where

	push	ecx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	push	esi
	mov	esi, ecx

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Tmp$[esp+8], ecx

; 811  : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR [ebp+4]
	test	ecx, ecx
	jne	SHORT $L34875
	xor	eax, eax
	jmp	SHORT $L34876
$L34875:
	mov	eax, DWORD PTR [ebp+12]
	sub	eax, ecx
	sar	eax, 2
$L34876:

; 812  : 
; 813  : 		if (_Count == 0)

	test	esi, esi
	je	$L35172

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

	test	ecx, ecx
	jne	SHORT $L34898
	xor	edx, edx
	jmp	SHORT $L34899
$L34898:
	mov	edx, DWORD PTR [ebp+8]
	sub	edx, ecx
	sar	edx, 2
$L34899:
	push	edi
	mov	edi, 1073741823				; 3fffffffH
	sub	edi, edx
	cmp	edi, esi
	jae	SHORT $L14644

; 816  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen
$L35187:
$L14644:

; 817  : 		else if (_Capacity < size() + _Count)

	test	ecx, ecx
	jne	SHORT $L34905
	xor	edx, edx
	jmp	SHORT $L34906
$L34905:
	mov	edx, DWORD PTR [ebp+8]
	sub	edx, ecx
	sar	edx, 2
$L34906:
	add	edx, esi
	cmp	eax, edx
	push	ebx
	jae	$L14646

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	edx, eax
	shr	edx, 1
	mov	edi, 1073741823				; 3fffffffH
	sub	edi, edx
	cmp	edi, eax
	jae	SHORT $L34865
	xor	eax, eax
	jmp	SHORT $L34866
$L34865:
	add	eax, edx
$L34866:

; 821  : 			if (_Capacity < size() + _Count)

	test	ecx, ecx
	jne	SHORT $L34928
	xor	edx, edx
	jmp	SHORT $L34929
$L34928:
	mov	edx, DWORD PTR [ebp+8]
	sub	edx, ecx
	sar	edx, 2
$L34929:
	add	edx, esi
	cmp	eax, edx
	jae	SHORT $L14647

; 822  : 				_Capacity = size() + _Count;

	test	ecx, ecx
	jne	SHORT $L34935
	xor	eax, eax
	jmp	SHORT $L34936
$L34935:
	mov	eax, DWORD PTR [ebp+8]
	sub	eax, ecx
	sar	eax, 2
$L34936:
	add	eax, esi
$L14647:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	shl	eax, 2
	push	eax
	mov	DWORD PTR tv478[esp+24], eax
	call	??2@YAPAXI@Z				; operator new

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN
; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

	mov	ecx, DWORD PTR [ebp+4]
	mov	ebx, eax
	mov	eax, DWORD PTR __Where$[esp+20]
	sub	eax, ecx
	sar	eax, 2
	lea	edi, DWORD PTR [eax*4]
	push	edi
	push	ecx
	push	ebx
	call	_memmove
	mov	edx, eax
	add	esp, 16					; 00000010H
	add	edx, edi

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

	test	esi, esi
	jbe	SHORT $L35023
	mov	eax, DWORD PTR __Tmp$[esp+16]
	mov	ecx, esi
	mov	edi, edx
	rep stosd
$L35023:

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	eax, DWORD PTR __Where$[esp+16]
	mov	ecx, DWORD PTR [ebp+8]
	sub	ecx, eax
	sar	ecx, 2
	shl	ecx, 2
	push	ecx
	push	eax
	lea	edx, DWORD PTR [edx+esi*4]
	push	edx
	call	_memmove

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);
; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);
; 834  : 			_RERAISE;
; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

	mov	eax, DWORD PTR [ebp+4]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $L35068
	xor	ecx, ecx
	jmp	SHORT $L35069
$L35068:
	mov	ecx, DWORD PTR [ebp+8]
	sub	ecx, eax
	sar	ecx, 2
$L35069:
	add	esi, ecx

; 838  : 			if (_Myfirst != 0)

	test	eax, eax
	je	SHORT $L35073

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);
; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L35073:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

	mov	eax, DWORD PTR tv478[esp+20]

; 844  : 			_Mylast = _Newvec + _Count;

	lea	ecx, DWORD PTR [ebx+esi*4]
	add	eax, ebx

; 845  : 			_Myfirst = _Newvec;

	mov	DWORD PTR [ebp+4], ebx
	pop	ebx
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp+12], eax
	mov	DWORD PTR [ebp+8], ecx
	pop	ebp

; 873  : 			}
; 874  : 		}

	pop	ecx
	ret	8
$L14646:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

	mov	edi, DWORD PTR [ebp+8]
	mov	ebx, DWORD PTR __Where$[esp+16]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 2
	cmp	eax, esi
	jae	SHORT $L14659

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

	lea	edx, DWORD PTR [eax*4]
	lea	ecx, DWORD PTR [esi*4]
	push	edx
	mov	DWORD PTR tv491[esp+20], ecx
	add	ecx, ebx
	push	ebx
	push	ecx
	call	_memmove

; 851  : 
; 852  : 			_TRY_BEGIN
; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

	mov	edi, DWORD PTR [ebp+8]
	mov	eax, edi
	sub	eax, ebx
	sar	eax, 2
	add	esp, 12					; 0000000cH
	sub	esi, eax
	lea	edx, DWORD PTR __Tmp$[esp+16]
	call	?_Ufill@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEPAPBVPathArgument@Json@@PAPBV34@IABQBV34@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Ufill

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);
; 857  : 			_RERAISE;
; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

	mov	edx, DWORD PTR [ebp+8]
	mov	eax, DWORD PTR tv491[esp+16]
	add	edx, eax
	mov	DWORD PTR [ebp+8], edx
	mov	ebp, edx

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

	sub	ebp, eax
	cmp	ebx, ebp
	je	SHORT $L35185
$L35111:
	mov	ecx, DWORD PTR __Tmp$[esp+16]
	mov	DWORD PTR [ebx], ecx
	add	ebx, 4
	cmp	ebx, ebp
	jne	SHORT $L35111
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 873  : 			}
; 874  : 		}

	pop	ecx
	ret	8
$L14659:

; 863  : 			}
; 864  : 		else
; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

	lea	eax, DWORD PTR [esi*4]
	mov	DWORD PTR tv491[esp+16], eax
	mov	esi, edi
	sub	esi, eax
	mov	eax, edi
	sub	eax, esi
	sar	eax, 2
	shl	eax, 2
	push	eax
	push	esi
	push	edi
	mov	DWORD PTR tv509[esp+32], eax
	call	_memmove
	add	eax, DWORD PTR tv509[esp+32]

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

	sub	esi, ebx
	mov	DWORD PTR [ebp+8], eax
	sar	esi, 2
	lea	eax, DWORD PTR [esi*4]
	push	eax
	sub	edi, eax
	push	ebx
	push	edi
	call	_memmove

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

	mov	edx, DWORD PTR tv491[esp+40]
	lea	eax, DWORD PTR [edx+ebx]
	add	esp, 24					; 00000018H
	cmp	ebx, eax
	je	SHORT $L35185
	npad	6
$L35170:
	mov	ecx, DWORD PTR __Tmp$[esp+16]
	mov	DWORD PTR [ebx], ecx
	add	ebx, 4
	cmp	ebx, eax
	jne	SHORT $L35170
$L35185:
	pop	ebx
	pop	edi
$L35172:
	pop	esi
	pop	ebp

; 873  : 			}
; 874  : 		}

	pop	ecx
	ret	8
$L35186:
?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T35466	DD	0ffffffffH
	DD	FLAT:$L35193
	DD	00H
	DD	FLAT:$L35302
$T35463	DD	019930520H
	DD	02H
	DD	FLAT:$T35466
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
_TEXT	SEGMENT
$T35192 = -80						; size = 28
$T35191 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen, COMDAT

; 883  : 		{	// report a length_error

	push	-1
	push	__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx

; 884  : 		_THROW(length_error, "vector<T> too long");

	push	18					; 00000012H
	xor	ebx, ebx
	push	OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T35192[esp+92]
	mov	DWORD PTR $T35192[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T35192[esp+112], ebx
	mov	BYTE PTR $T35192[esp+96], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T35191[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], ebx
	call	??0exception@@QAE@XZ			; exception::exception
	push	-1
	mov	BYTE PTR __$EHRec$[esp+96], 1
	push	ebx
	lea	eax, DWORD PTR $T35192[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T35191[esp+108]
	mov	DWORD PTR $T35191[esp+96], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	DWORD PTR $T35191[esp+132], 15		; 0000000fH
	mov	DWORD PTR $T35191[esp+128], ebx
	mov	BYTE PTR $T35191[esp+112], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T35191[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], bl
	push	ecx
	mov	DWORD PTR $T35191[esp+92], OFFSET FLAT:??_7length_error@std@@6B@
	call	__CxxThrowException@8
	pop	ebx
$L35467:
$L35465:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L35193:
	lea	ecx, DWORD PTR $T35192[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L35302:
	lea	ecx, DWORD PTR $T35191[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ:
	mov	eax, OFFSET FLAT:$T35463
	jmp	___CxxFrameHandler
text$x	ENDS
?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = eax

; 770  : 		{	// allocate array with _Capacity elements

	push	edi
	mov	edi, eax

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	eax, eax

; 772  : 		if (_Capacity == 0)

	cmp	edi, eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], eax
	jne	SHORT $L14514

; 773  : 			return (false);

	xor	al, al
	pop	edi

; 783  : 		}

	ret	0
$L14514:

; 774  : 		else if (max_size() < _Capacity)

	cmp	edi, 153391689				; 09249249H
	jbe	SHORT $L14516

; 775  : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
$L14516:

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

	imul	edi, 28					; 0000001cH
	push	edi
	call	??2@YAPAXI@Z				; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

	add	edi, eax
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edi

; 781  : 			}
; 782  : 		return (true);

	mov	al, 1
	pop	edi

; 783  : 		}

	ret	0
?_Buy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAE_NI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Buy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
$T35504 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase, COMDAT
; _this$ = edi

; 751  : 		if (_First == begin() && _Last == end())

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	push	ebx
	mov	ebx, DWORD PTR __Last$[esp]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR __First$[esp+8]
	cmp	esi, ecx
	jne	SHORT $L35836
	cmp	ebx, eax
	jne	SHORT $L35836

; 752  : 			{	// erase all
; 753  : 			clear();

	mov	eax, DWORD PTR [eax+4]
	push	eax
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [eax+8], eax

; 754  : 			return (begin());

	mov	ecx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [ecx]
	pop	esi
	mov	DWORD PTR [ebp], edx

; 760  : 			return (_First);

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 761  : 			}
; 762  : 		}

	ret	12					; 0000000cH
$L35836:

; 755  : 			}
; 756  : 		else
; 757  : 			{	// partial erase, one at a time
; 758  : 			while (_First != _Last)

	cmp	esi, ebx
	je	SHORT $L14369
$L14368:

; 759  : 				erase(_First++);

	mov	al, BYTE PTR [esi+41]
	test	al, al
	mov	ecx, esi
	jne	SHORT $L35807
	mov	eax, DWORD PTR [esi+8]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	jne	SHORT $L35838
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	jne	SHORT $L35807
$L35821:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	je	SHORT $L35821
	jmp	SHORT $L35807
$L35838:
	mov	eax, DWORD PTR [esi+4]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	jne	SHORT $L35810
$L35809:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $L35810
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	je	SHORT $L35809
$L35810:
	mov	esi, eax
$L35807:
	push	ecx
	lea	eax, DWORD PTR $T35504[esp+12]
	push	eax
	push	edi
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
	cmp	esi, ebx
	jne	SHORT $L14368
$L14369:

; 760  : 			return (_First);

	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx

; 761  : 			}
; 762  : 		}

	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = eax

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	ecx, ecx

; 772  : 		if (_Capacity == 0)

	cmp	eax, ecx
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], ecx
	jne	SHORT $L14266

; 773  : 			return (false);

	xor	al, al

; 783  : 		}

	ret	0
$L14266:

; 774  : 		else if (max_size() < _Capacity)

	cmp	eax, 119304647				; 071c71c7H
	jbe	SHORT $L14268

; 775  : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IBEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
$L14268:
	push	edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

	lea	edi, DWORD PTR [eax+eax*8]
	shl	edi, 2
	push	edi
	call	??2@YAPAXI@Z				; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

	add	edi, eax
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edi

; 781  : 			}
; 782  : 		return (true);

	mov	al, 1
	pop	edi

; 783  : 		}

	ret	0
?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABVPathArgument@Json@@@Z
_TEXT	SEGMENT
tv90 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABVPathArgument@Json@@@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::insert, COMDAT
; _this$ = edi

; 620  : 		{	// insert _Val at _Where

	push	ebx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $L35936
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR tv90[esp+8], eax
	jne	SHORT $L35875
$L35936:
	xor	esi, esi
	jmp	SHORT $L35876
$L35875:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 3
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$L35876:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	1
	push	ebx
	push	edi
	call	?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Insert_n

; 623  : 		return (begin() + _Off);

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [esi+esi*8]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR [ebp], eax
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx

; 624  : 		}

	ret	12					; 0000000cH
?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
?_Buy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE_NI@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Buy, COMDAT
; _this$ = esi
; __Capacity$ = eax

; 771  : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	xor	ecx, ecx

; 772  : 		if (_Capacity == 0)

	cmp	eax, ecx
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+12], ecx
	jne	SHORT $L14225

; 773  : 			return (false);

	xor	al, al

; 783  : 		}

	ret	0
$L14225:

; 774  : 		else if (max_size() < _Capacity)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $L14227

; 775  : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IBEXXZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Xlen
$L14227:
	push	edi

; 776  : 		else
; 777  : 			{	// nonempty array, allocate storage
; 778  : 			_Myfirst = this->_Alval.allocate(_Capacity);

	lea	edi, DWORD PTR [eax*4]
	push	edi
	call	??2@YAPAXI@Z				; operator new

; 779  : 			_Mylast = _Myfirst;
; 780  : 			_Myend = _Myfirst + _Capacity;

	add	edi, eax
	add	esp, 4
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edi

; 781  : 			}
; 782  : 		return (true);

	mov	al, 1
	pop	edi

; 783  : 		}

	ret	0
?_Buy@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Buy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABQBVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Where$ = 8						; size = 4
__Val$ = 12						; size = 4
?insert@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABQBVPathArgument@Json@@@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::insert, COMDAT
; _this$ = edi
; ___$ReturnUdt$ = ebx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ecx, DWORD PTR [edi+4]
	test	ecx, ecx
	mov	edx, DWORD PTR __Where$[esp-4]
	push	esi
	je	SHORT $L36030
	mov	eax, DWORD PTR [edi+8]
	sub	eax, ecx
	sar	eax, 2
	test	eax, eax
	jne	SHORT $L35969
$L36030:
	xor	esi, esi
	jmp	SHORT $L35970
$L35969:
	mov	esi, edx
	sub	esi, ecx
	sar	esi, 2
$L35970:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	eax, DWORD PTR __Val$[esp]
	push	edx
	push	edi
	mov	ecx, 1
	call	?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n

; 623  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+esi*4]
	mov	DWORD PTR [ebx], ecx
	mov	eax, ebx
	pop	esi

; 624  : 		}

	ret	8
?insert@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABQBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T36170	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T36172	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L36037
$T36171	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T36172
$T36167	DD	019930520H
	DD	02H
	DD	FLAT:$T36170
	DD	01H
	DD	FLAT:$T36171
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
tv204 = -24						; size = 4
__Cat$36158 = -24					; size = 1
__Cat$36121 = -24					; size = 1
__Ptr$13925 = -20					; size = 4
__$EHRec$ = -16						; size = 16
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve, COMDAT
; _this$ = edx
; __Count$ = ecx

; 428  : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 429  : 		if (max_size() < _Count)

	cmp	edi, 153391689				; 09249249H
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, edx
	jbe	SHORT $L13922

; 430  : 			_Xlen();	// result too long

	jmp	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
$L13922:

; 431  : 		else if (capacity() < _Count)

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $L36060
$L36059:
	mov	ecx, DWORD PTR [esi+12]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$L36060:
	cmp	eax, edi
	jae	$L13924

; 432  : 			{	// not enough room, reallocate
; 433  : 			pointer _Ptr = this->_Alval.allocate(_Count);

	imul	edi, 28					; 0000001cH
	push	edi
	mov	DWORD PTR tv204[ebp], edi
	call	??2@YAPAXI@Z				; operator new

; 434  : 
; 435  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 436  : 			_Ucopy(begin(), end(), _Ptr);

	mov	ebx, DWORD PTR __Cat$36121[ebp]
	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR [esi+4]
	push	ebx
	push	esi
	push	eax
	push	ecx
	push	edx
	mov	DWORD PTR __Ptr$13925[ebp], eax
	call	??$_Uninit_copy@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Viterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 440  : 			_CATCH_END
; 441  : 
; 442  : 			size_type _Size = size();

	mov	ecx, DWORD PTR [esi+4]
	add	esp, 24					; 00000018H
	test	ecx, ecx
	jne	SHORT $L36134
	xor	ebx, ebx
	jmp	SHORT $L36135
$L36134:
	mov	ebx, DWORD PTR [esi+8]
	sub	ebx, ecx
	mov	eax, -1840700269			; 92492493H
	imul	ebx
	add	edx, ebx
	sar	edx, 4
	mov	ebx, edx
	shr	ebx, 31					; 0000001fH
	add	ebx, edx
$L36135:

; 443  : 			if (_Myfirst != 0)

	test	ecx, ecx
	je	SHORT $L36162

; 444  : 				{	// destroy and deallocate old array
; 445  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR __Cat$36158[ebp]
	mov	edi, DWORD PTR [esi+8]
	push	eax
	mov	eax, ecx
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 446  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	mov	edi, DWORD PTR tv204[ebp]
	add	esp, 8
$L36162:

; 447  : 				}
; 448  : 
; 449  : 
; 450  : 			_Myend = _Ptr + _Count;

	mov	eax, DWORD PTR __Ptr$13925[ebp]

; 451  : 			_Mylast = _Ptr + _Size;

	imul	ebx, 28					; 0000001cH
	add	edi, eax
	add	ebx, eax
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+8], ebx

; 452  : 			_Myfirst = _Ptr;

	mov	DWORD PTR [esi+4], eax
$L13924:

; 453  : 			}
; 454  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$L36037:

; 437  : 			_CATCH_ALL
; 438  : 			this->_Alval.deallocate(_Ptr, _Count);

	mov	edx, DWORD PTR __Ptr$13925[ebp]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 439  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L36173:
$L36169:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z:
	mov	eax, OFFSET FLAT:$T36167
	jmp	___CxxFrameHandler
text$x	ENDS
?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
xdata$x	SEGMENT
$T36296	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T36298	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L36182
$T36297	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T36298
$T36292	DD	019930520H
	DD	02H
	DD	FLAT:$T36296
	DD	01H
	DD	FLAT:$T36297
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
__Cat$36285 = 8						; size = 1
_this$ = 8						; size = 4
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; __Right$ = ecx

; 329  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	mov	ebx, ecx

; 330  : 		if (_Buy(_Right.size()))

	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi
	mov	edi, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	jne	SHORT $L36200
	xor	esi, esi
	jmp	SHORT $L36201
$L36200:
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	xor	ecx, ecx
$L36201:
	cmp	esi, ecx
	mov	DWORD PTR [edi+4], ecx
	mov	DWORD PTR [edi+8], ecx
	mov	DWORD PTR [edi+12], ecx
	je	SHORT $L13831
	cmp	esi, 153391689				; 09249249H
	jbe	SHORT $L36230
	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
$L36299:
$L36230:
	imul	esi, 28					; 0000001cH
	push	esi
	call	??2@YAPAXI@Z				; operator new

; 331  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 332  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR __Cat$36285[ebp]
	push	edx
	add	esi, eax
	push	edi
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	mov	DWORD PTR [edi+12], esi
	mov	ecx, DWORD PTR [ebx+8]
	mov	ebx, DWORD PTR [ebx+4]
	push	eax
	push	ecx
	push	ebx
	call	??$_Uninit_copy@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@3@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@Vconst_iterator@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@0@0PAV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::const_iterator,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 24					; 00000018H
	mov	DWORD PTR [edi+8], eax
$L13831:

; 336  : 			_CATCH_END
; 337  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L36182:

; 333  : 			_CATCH_ALL
; 334  : 			_Tidy();

	mov	esi, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Tidy

; 335  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L36300:
$L36295:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET FLAT:$T36292
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >, COMDAT
; _this$ = eax

; 300  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 301  : 		}

	ret	0
??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z
_TEXT	SEGMENT
$T36428 = -8						; size = 1
__Num$ = -8						; size = 4
$T36364 = -4						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase, COMDAT
; _this$ = ecx
; __Keyval$ = eax

; 765  : 		{	// erase and count all that match _Keyval

	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	ebx, eax
	mov	edi, ecx

; 766  : 		_Pairii _Where = equal_range(_Keyval);

	push	ebx
	mov	eax, edi
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
	mov	esi, eax
	push	ebx
	mov	eax, edi
	call	?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound
	mov	ebx, eax

; 767  : 		size_type _Num = 0;

	mov	DWORD PTR __Num$[esp+20], 0

; 768  : 		_Distance(_Where.first, _Where.second, _Num);

	mov	eax, DWORD PTR $T36428[esp+20]
	push	eax
	push	ebx
	push	esi
	lea	edx, DWORD PTR __Num$[esp+32]
	call	??$_Distance2@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@I@std@@YAXViterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@0@0AAIUbidirectional_iterator_tag@0@@Z ; std::_Distance2<std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::iterator,unsigned int>
	add	esp, 12					; 0000000cH

; 769  : 		erase(_Where.first, _Where.second);

	push	ebx
	push	esi
	lea	ecx, DWORD PTR $T36364[esp+28]
	push	ecx
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase

; 770  : 		return (_Num);

	mov	eax, DWORD PTR __Num$[esp+20]
	pop	edi
	pop	esi
	pop	ebx

; 771  : 		}

	add	esp, 8
	ret	0
?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEIABVCZString@Value@Json@@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Cat$36473 = -4					; size = 1
$T36439 = -4						; size = 4
?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back, COMDAT
; _this$ = eax
; __Val$ = ecx

; 579  : 		{	// insert element at end

	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, eax

; 580  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [edi+4]
	test	ebx, ebx
	jne	SHORT $L36444
	xor	esi, esi
	jmp	SHORT $L36445
$L36444:
	mov	edx, DWORD PTR [edi+8]
	sub	edx, ebx
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$L36445:
	test	ebx, ebx
	je	SHORT $L13598
	mov	edx, DWORD PTR [edi+12]
	sub	edx, ebx
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jae	SHORT $L13598

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Cat$36473[esp+16]
	mov	esi, DWORD PTR [edi+8]
	push	eax
	push	1
	push	esi
	call	??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
	add	esp, 12					; 0000000cH
	add	esi, 36					; 00000024H
	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi
	pop	ebx

; 584  : 		}

	pop	ecx
	ret	0
$L13598:

; 582  : 		else
; 583  : 			insert(end(), _Val);

	mov	eax, DWORD PTR [edi+8]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR $T36439[esp+24]
	push	ecx
	call	?insert@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AViterator@12@V312@ABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::insert
	pop	edi
	pop	esi
	pop	ebx

; 584  : 		}

	pop	ecx
	ret	0
?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = eax

; 300  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 301  : 		}

	ret	0
??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z
_TEXT	SEGMENT
?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back, COMDAT
; _this$ = ecx
; __Val$ = eax

; 579  : 		{	// insert element at end

	push	esi
	push	edi

; 580  : 		if (size() < capacity())

	mov	edi, DWORD PTR [ecx+4]
	test	edi, edi
	jne	SHORT $L36561
	xor	esi, esi
	jmp	SHORT $L36562
$L36561:
	mov	esi, DWORD PTR [ecx+8]
	sub	esi, edi
	sar	esi, 2
$L36562:
	test	edi, edi
	je	SHORT $L13537
	mov	edx, DWORD PTR [ecx+12]
	sub	edx, edi
	sar	edx, 2
	cmp	esi, edx
	jae	SHORT $L13537

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
	add	edx, 4
	pop	edi
	mov	DWORD PTR [ecx+8], edx
	pop	esi

; 584  : 		}

	ret	0
$L13537:

; 582  : 		else
; 583  : 			insert(end(), _Val);

	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	ecx
	mov	ecx, 1
	call	?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n
	pop	edi
	pop	esi

; 584  : 		}

	ret	0
?push_back@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAEXABQBVPathArgument@Json@@@Z ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ PROC NEAR ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >, COMDAT
; _this$ = eax

; 300  : 		_Buy(0);

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx

; 301  : 		}

	ret	0
??0?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
_TEXT	ENDS
PUBLIC	?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z	; Json::Path::resolve
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
;	COMDAT ?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z
_TEXT	SEGMENT
?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z PROC NEAR	; Json::Path::resolve, COMDAT
; _this$ = edi
; _root$ = eax

; 1551 :    const Value *node = &root;
; 1552 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	mov	ecx, DWORD PTR [edi+8]
	push	esi
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $L13158
	npad	5
$L36811:

; 1553 :    {
; 1554 :       const PathArgument &arg = *it;
; 1555 :       if ( arg.kind_ == PathArgument::kindIndex )

	mov	ecx, DWORD PTR [esi+32]
	cmp	ecx, 1
	jne	SHORT $L13160

; 1556 :       {
; 1557 :          if ( !node->isArray()  ||  node->isValidIndex( arg.index_ ) )
; 1558 :          {
; 1559 :             // Error: unable to resolve path (array value expected at position...
; 1560 :          }
; 1561 :          node = &((*node)[arg.index_]);

	mov	ecx, DWORD PTR [esi+28]
	push	ecx
	push	eax
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]

; 1562 :       }
; 1563 :       else if ( arg.kind_ == PathArgument::kindKey )

	jmp	SHORT $L13157
$L13160:
	cmp	ecx, 2
	jne	SHORT $L13157

; 1564 :       {
; 1565 :          if ( !node->isObject() )
; 1566 :          {
; 1567 :             // Error: unable to resolve path (object value expected at position...)
; 1568 :          }
; 1569 :          node = &((*node)[arg.key_]);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L36980
	mov	ecx, DWORD PTR [esi+4]
	jmp	SHORT $L36981
$L36980:

; 1551 :    const Value *node = &root;
; 1552 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	lea	ecx, DWORD PTR [esi+4]

; 1564 :       {
; 1565 :          if ( !node->isObject() )
; 1566 :          {
; 1567 :             // Error: unable to resolve path (object value expected at position...)
; 1568 :          }
; 1569 :          node = &((*node)[arg.key_]);

$L36981:
	push	ecx
	push	eax
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
$L13157:
	mov	ecx, DWORD PTR [edi+8]
	add	esi, 36					; 00000024H
	cmp	esi, ecx
	jne	SHORT $L36811
$L13158:
	pop	esi

; 1570 :          if ( node == &Value::null )
; 1571 :          {
; 1572 :             // Error: unable to resolve path (object has no member named '' at position...)
; 1573 :          }
; 1574 :       }
; 1575 :    }
; 1576 :    return *node;
; 1577 : }

	ret	0
?resolve@Path@Json@@QBEABVValue@2@ABV32@@Z ENDP		; Json::Path::resolve
_TEXT	ENDS
PUBLIC	?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAVconst_iterator@54@W4Kind@PathArgument@2@@Z ; Json::Path::addPathInArg
; Function compile flags: /Ogtpy
;	COMDAT ?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAVconst_iterator@54@W4Kind@PathArgument@2@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
_kind$ = 12						; size = 4
?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAVconst_iterator@54@W4Kind@PathArgument@2@@Z PROC NEAR ; Json::Path::addPathInArg, COMDAT
; _in$ = ecx
; _itInArg$ = eax

; 1525 :    if ( itInArg == in.end() )

	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR [ecx+8]
	je	SHORT $L13063

; 1526 :    {
; 1527 :       // Error: missing argument %d
; 1528 :    }
; 1529 :    else if ( (*itInArg)->kind_ != kind )

	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+32]
	cmp	edx, DWORD PTR _kind$[esp-4]
	jne	SHORT $L13063

; 1530 :    {
; 1531 :       // Error: bad argument type
; 1532 :    }
; 1533 :    else
; 1534 :    {
; 1535 :       args_.push_back( **itInArg );

	mov	ecx, eax
	mov	eax, DWORD PTR _this$[esp-4]
	call	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
$L13063:

; 1536 :    }
; 1537 : }

	ret	8
?addPathInArg@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@AAVconst_iterator@54@W4Kind@PathArgument@2@@Z ENDP ; Json::Path::addPathInArg
_TEXT	ENDS
PUBLIC	??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::PathArgument::PathArgument
; Function compile flags: /Ogtpy
;	COMDAT ??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; Json::PathArgument::PathArgument, COMDAT
; _this$ = esi
; _key$ = eax

; 1452 : {

	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L37026
	mov	edx, DWORD PTR [eax+4]
	jmp	SHORT $L37027
$L37026:
	lea	edx, DWORD PTR [eax+4]
$L37027:
	mov	eax, edx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
$L37135:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $L37135
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	DWORD PTR [esi+32], 2

; 1453 : }

	mov	eax, esi
	pop	edi
	ret	0
??0PathArgument@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::PathArgument::PathArgument
_TEXT	ENDS
PUBLIC	??0PathArgument@Json@@QAE@PBD@Z			; Json::PathArgument::PathArgument
; Function compile flags: /Ogtpy
;	COMDAT ??0PathArgument@Json@@QAE@PBD@Z
_TEXT	SEGMENT
??0PathArgument@Json@@QAE@PBD@Z PROC NEAR		; Json::PathArgument::PathArgument, COMDAT
; _this$ = esi
; _key$ = edx

; 1445 : {

	mov	eax, edx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
$L37245:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $L37245
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	DWORD PTR [esi+32], 2

; 1446 : }

	mov	eax, esi
	pop	edi
	ret	0
??0PathArgument@Json@@QAE@PBD@Z ENDP			; Json::PathArgument::PathArgument
_TEXT	ENDS
PUBLIC	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
; Function compile flags: /Ogtpy
;	COMDAT ?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z
_TEXT	SEGMENT
$T37250 = -4						; size = 4
?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z PROC NEAR ; Json::Value::getComment, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; _placement$ = ecx

; 1269 : {

	push	ecx

; 1270 :    if ( hasComment(placement) )

	mov	eax, DWORD PTR [eax+12]
	push	ebx
	xor	ebx, ebx
	cmp	eax, ebx
	mov	DWORD PTR $T37250[esp+8], ebx
	je	SHORT $L12761
	mov	ecx, DWORD PTR [eax+ecx*4]
	cmp	ecx, ebx
	je	SHORT $L12761

; 1271 :       return comments_[placement].comment_;

	mov	eax, ecx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	BYTE PTR [esi+4], bl
	lea	edi, DWORD PTR [eax+1]
	npad	7
$L37471:
	mov	dl, BYTE PTR [eax]
	inc	eax
	cmp	dl, bl
	jne	SHORT $L37471
	sub	eax, edi
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 1272 :    return "";

	mov	eax, esi
	pop	ebx

; 1273 : }

	pop	ecx
	ret	0
$L12761:

; 1272 :    return "";

	push	ebx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	push	OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, esi
	pop	ebx

; 1273 : }

	pop	ecx
	ret	0
?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ENDP ; Json::Value::getComment
_TEXT	ENDS
PUBLIC	?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::isMember
; Function compile flags: /Ogtpy
;	COMDAT ?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; Json::Value::isMember, COMDAT
; _key$ = eax

; 1118 :    return isMember( key.c_str() );

	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L37488
	mov	eax, DWORD PTR [eax+4]
	jmp	SHORT $L37489
$L37488:
	add	eax, 4
$L37489:
	push	eax
	mov	eax, DWORD PTR _this$[esp]
	push	eax
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
	xor	ecx, ecx
	cmp	eax, OFFSET FLAT:?null@Value@Json@@2V12@B ; Json::Value::null
	setne	cl
	mov	al, cl

; 1119 : }

	ret	4
?isMember@Value@Json@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::isMember
_TEXT	ENDS
PUBLIC	?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Value::asString
; Function compile flags: /Ogtpy
;	COMDAT ?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T37503 = -4						; size = 4
?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC NEAR ; Json::Value::asString, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = esi

; 660  : {

	push	ecx

; 661  :    switch ( type_ )

	movsx	eax, BYTE PTR [edx+8]
	xor	ecx, ecx
	sub	eax, ecx
	mov	DWORD PTR $T37503[esp+4], ecx
	je	$L12198
	sub	eax, 4
	push	ebx
	push	edi
	je	SHORT $L12199
	dec	eax
	je	SHORT $L12200

; 669  :    case intValue:
; 670  :    case uintValue:
; 671  :    case realValue:
; 672  :    case arrayValue:
; 673  :    case objectValue:
; 674  :       JSON_ASSERT( "Type is not convertible to double" && false );
; 675  :    default:
; 676  :       JSON_ASSERT_UNREACHABLE;
; 677  :    }
; 678  :    return ""; // unreachable

	mov	DWORD PTR [esi+20], ecx
	push	ecx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+4], cl
	push	OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	ebx
	mov	eax, esi

; 679  : }

	pop	ecx
	ret	0
$L12200:

; 667  :    case booleanValue:
; 668  :       return value_.bool_ ? "true" : "false";

	cmp	BYTE PTR [edx], cl
	mov	edi, OFFSET FLAT:??_C@_04LOAJBDKD@true?$AA@
	jne	SHORT $L37501
	mov	edi, OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
$L37501:
	mov	eax, edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ecx
	mov	BYTE PTR [esi+4], cl
	lea	ebx, DWORD PTR [eax+1]
	npad	4
$L37927:
	mov	dl, BYTE PTR [eax]
	inc	eax
	cmp	dl, cl
	jne	SHORT $L37927
	sub	eax, ebx
	push	eax
	push	edi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	ebx
	mov	eax, esi

; 679  : }

	pop	ecx
	ret	0
$L12199:

; 665  :    case stringValue:
; 666  :       return value_.string_ ? value_.string_ : "";

	mov	edi, DWORD PTR [edx]
	cmp	edi, ecx
	jne	SHORT $L37499
	mov	edi, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
$L37499:
	mov	eax, edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ecx
	mov	BYTE PTR [esi+4], cl
	lea	ebx, DWORD PTR [eax+1]
$L37928:
	mov	dl, BYTE PTR [eax]
	inc	eax
	cmp	dl, cl
	jne	SHORT $L37928

; 667  :    case booleanValue:
; 668  :       return value_.bool_ ? "true" : "false";

	sub	eax, ebx
	push	eax
	push	edi
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	ebx
	mov	eax, esi

; 679  : }

	pop	ecx
	ret	0
$L12198:

; 662  :    {
; 663  :    case nullValue:
; 664  :       return "";

	mov	DWORD PTR [esi+20], ecx
	push	ecx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+4], cl
	push	OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 667  :    case booleanValue:
; 668  :       return value_.bool_ ? "true" : "false";

	mov	eax, esi

; 679  : }

	pop	ecx
	ret	0
?asString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Value::asString
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T42706	DD	0ffffffffH
	DD	FLAT:$L42236
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
$T42708	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L42233
$T42709	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L42235
$T42707	DD	01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T42708
	DD	03H
	DD	03H
	DD	04H
	DD	01H
	DD	FLAT:$T42709
$T42701	DD	019930520H
	DD	05H
	DD	FLAT:$T42706
	DD	02H
	DD	FLAT:$T42707
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Ptr$14928 = -56					; size = 4
tv496 = -52						; size = 4
__Newvec$14927 = -52					; size = 4
__Tmp$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
__Cat$42600 = 12					; size = 1
__Cat$42576 = 12					; size = 1
__Cat$42552 = 12					; size = 1
__Cat$42490 = 12					; size = 1
__Cat$42523 = 12					; size = 1
__Cat$42465 = 12					; size = 1
__Cat$42443 = 12					; size = 1
__Cat$42419 = 12					; size = 1
__Where$ = 12						; size = 4
tv525 = 16						; size = 4
tv511 = 16						; size = 4
__Count$ = 16						; size = 4
tv578 = 20						; size = 4
tv512 = 20						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n, COMDAT

; 809  : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	push	ebx
	mov	ebx, DWORD PTR _this$[ebp]
	push	esi
	mov	esi, DWORD PTR __Count$[ebp]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 810  : 		_Ty _Tmp = _Val;	// in case _Val is in sequence

	push	-1
	xor	edi, edi
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR __Val$[ebp]
	push	edi
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	mov	DWORD PTR __Tmp$[ebp+24], 15		; 0000000fH
	mov	DWORD PTR __Tmp$[ebp+20], edi
	mov	BYTE PTR __Tmp$[ebp+4], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	DWORD PTR __$EHRec$[ebp+12], edi

; 811  : 		size_type _Capacity = capacity();

	mov	edi, DWORD PTR [ebx+4]
	test	edi, edi
	jne	SHORT $L42335
	xor	ecx, ecx
	jmp	SHORT $L42336
$L42335:
	mov	ecx, DWORD PTR [ebx+12]
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$L42336:

; 812  : 
; 813  : 		if (_Count == 0)

	test	esi, esi
	je	$L14947

; 814  : 			;
; 815  : 		else if (max_size() - size() < _Count)

	test	edi, edi
	jne	SHORT $L42358
	xor	eax, eax
	jmp	SHORT $L42359
$L42358:
	mov	edx, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, edx
	mov	eax, -1840700269			; 92492493H
	imul	edi
	add	edx, edi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$L42359:
	mov	edx, 153391689				; 09249249H
	sub	edx, eax
	cmp	edx, esi
	jae	SHORT $L14923

; 816  : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IBEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Xlen
$L42710:
$L14923:

; 817  : 		else if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jne	SHORT $L42365
	xor	eax, eax
	jmp	SHORT $L42366
$L42365:
	mov	edx, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, edx
	mov	eax, -1840700269			; 92492493H
	imul	edi
	add	edx, edi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$L42366:
	add	eax, esi
	cmp	ecx, eax
	jae	$L14925

; 818  : 			{	// not enough room, reallocate
; 819  : 			_Capacity = max_size() - _Capacity / 2 < _Capacity
; 820  : 				? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%

	mov	eax, ecx
	shr	eax, 1
	mov	edx, 153391689				; 09249249H
	sub	edx, eax
	cmp	edx, ecx
	jae	SHORT $L42230
	xor	ecx, ecx
	jmp	SHORT $L42231
$L42230:
	add	ecx, eax
$L42231:

; 821  : 			if (_Capacity < size() + _Count)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	jne	SHORT $L42388
	xor	eax, eax
	jmp	SHORT $L42389
$L42388:
	mov	edx, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR [ebx+8]
	sub	edi, edx
	mov	eax, -1840700269			; 92492493H
	imul	edi
	add	edx, edi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$L42389:
	add	eax, esi
	cmp	ecx, eax
	jae	SHORT $L14926

; 822  : 				_Capacity = size() + _Count;

	mov	ecx, ebx
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	mov	ecx, eax
	add	ecx, esi
$L14926:

; 823  : 			pointer _Newvec = this->_Alval.allocate(_Capacity);

	imul	ecx, 28					; 0000001cH
	push	ecx
	mov	DWORD PTR tv511[ebp], ecx
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax

; 824  : 			pointer _Ptr = _Newvec;
; 825  : 
; 826  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 827  : 			_Ptr = _Ucopy(_Myfirst, _ITER_BASE(_Where),
; 828  : 				_Newvec);	// copy prefix

	mov	eax, DWORD PTR __Cat$42419[ebp]
	mov	edx, DWORD PTR __Where$[ebp]
	mov	ecx, DWORD PTR [ebx+4]
	push	eax
	push	ebx
	push	edi
	push	edx
	mov	DWORD PTR __Newvec$14927[ebp], edi
	mov	DWORD PTR __Ptr$14928[ebp], edi
	call	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 829  : 			_Ptr = _Ufill(_Ptr, _Count, _Tmp);	// add new stuff

	mov	ecx, DWORD PTR __Cat$42443[ebp]
	add	esp, 20					; 00000014H
	push	ecx
	push	ebx
	lea	edx, DWORD PTR __Tmp$[ebp]
	push	edx
	push	eax
	mov	ecx, esi
	mov	DWORD PTR __Ptr$14928[ebp], eax
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 830  : 			_Ucopy(_ITER_BASE(_Where), _Mylast, _Ptr);	// copy suffix

	mov	edx, DWORD PTR __Cat$42465[ebp]
	mov	ecx, DWORD PTR __Ptr$14928[ebp]
	mov	eax, esi
	imul	eax, 28					; 0000001cH
	add	esp, 16					; 00000010H
	push	edx
	add	ecx, eax
	mov	eax, DWORD PTR [ebx+8]
	push	ebx
	push	ecx
	mov	DWORD PTR __Ptr$14928[ebp], ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	push	eax
	call	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 835  : 			_CATCH_END
; 836  : 
; 837  : 			_Count += size();

	mov	eax, DWORD PTR [ebx+4]
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $L42500
$L42499:
	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, eax
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
$L42500:
	add	esi, eax

; 838  : 			if (_Myfirst != 0)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $L42527

; 839  : 				{	// destroy and deallocate old array
; 840  : 				_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR __Cat$42523[ebp]
	mov	edi, DWORD PTR [ebx+8]
	push	eax
	mov	eax, DWORD PTR [ebx+4]
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 841  : 				this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR [ebx+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	mov	edi, DWORD PTR __Newvec$14927[ebp]
	add	esp, 8
$L42527:

; 842  : 				}
; 843  : 			_Myend = _Newvec + _Capacity;

	mov	edx, DWORD PTR tv511[ebp]

; 844  : 			_Mylast = _Newvec + _Count;

	imul	esi, 28					; 0000001cH
	add	edx, edi
	add	esi, edi
	mov	DWORD PTR [ebx+12], edx
	mov	DWORD PTR [ebx+8], esi

; 845  : 			_Myfirst = _Newvec;

	mov	DWORD PTR [ebx+4], edi

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

	jmp	$L14947
$L42233:

; 831  : 			_CATCH_ALL
; 832  : 			_Destroy(_Newvec, _Ptr);

	mov	eax, DWORD PTR __Cat$42490[ebp]
	mov	esi, DWORD PTR __Newvec$14927[ebp]
	mov	edi, DWORD PTR __Ptr$14928[ebp]
	push	eax
	mov	eax, esi
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 833  : 			this->_Alval.deallocate(_Newvec, _Capacity);

	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 8

; 834  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L42711:
$L14925:

; 846  : 			}
; 847  : 		else if ((size_type)(_Mylast - _ITER_BASE(_Where)) < _Count)

	mov	ecx, DWORD PTR [ebx+8]
	mov	edi, DWORD PTR __Where$[ebp]
	mov	edx, ecx
	sub	edx, edi
	mov	DWORD PTR tv578[ebp], edx
	mov	eax, -1840700269			; 92492493H
	imul	edx
	add	edx, DWORD PTR tv578[ebp]
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi

; 848  : 			{	// new stuff spills off end
; 849  : 			_Ucopy(_ITER_BASE(_Where), _Mylast,
; 850  : 				_ITER_BASE(_Where) + _Count);	// copy suffix

	mov	edx, DWORD PTR __Cat$42552[ebp]
	push	edx
	mov	DWORD PTR tv496[ebp], ecx
	push	ebx
	jae	$L14938
	mov	eax, esi
	imul	eax, 28					; 0000001cH
	mov	DWORD PTR tv512[ebp], eax
	add	eax, edi
	push	eax
	push	ecx
	mov	ecx, edi
	call	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 851  : 
; 852  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 3

; 853  : 			_Ufill(_Mylast, _Count - (_Mylast - _ITER_BASE(_Where)),
; 854  : 				_Tmp);	// insert new stuff off end

	mov	ecx, DWORD PTR [ebx+8]
	sub	ecx, edi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	mov	ecx, DWORD PTR __Cat$42576[ebp]
	sar	edx, 4
	mov	eax, edx
	push	ecx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	sub	esi, eax
	mov	eax, DWORD PTR [ebx+8]
	push	ebx
	lea	edx, DWORD PTR __Tmp$[ebp]
	push	edx
	push	eax
	mov	ecx, esi
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 858  : 			_CATCH_END
; 859  : 
; 860  : 			_Mylast += _Count;

	mov	eax, DWORD PTR tv512[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR [ebx+8]
	add	ecx, eax

; 861  : 			fill(_ITER_BASE(_Where), _Mylast - _Count,
; 862  : 				_Tmp);	// insert up to old end

	mov	edi, ecx
	add	esp, 32					; 00000020H
	mov	DWORD PTR [ebx+8], ecx
	sub	edi, eax

; 863  : 			}
; 864  : 		else

	jmp	SHORT $L42705
$L42235:

; 855  : 			_CATCH_ALL
; 856  : 			_Destroy(_ITER_BASE(_Where) + _Count, _Mylast + _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __Cat$42600[ebp]
	imul	eax, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR [edx+8]
	push	ecx
	mov	ecx, DWORD PTR __Where$[ebp]
	add	edi, eax
	add	eax, ecx
	call	??$_Destroy_range@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 4

; 857  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L42712:
$L14938:

; 865  : 			{	// new stuff can all be assigned
; 866  : 			pointer _Oldend = _Mylast;
; 867  : 			_Mylast = _Ucopy(_Oldend - _Count, _Oldend,
; 868  : 				_Mylast);	// copy suffix

	imul	esi, 28					; 0000001cH
	mov	eax, ecx
	push	ecx
	sub	eax, esi
	push	ecx
	mov	ecx, eax
	mov	DWORD PTR tv525[ebp], eax
	call	??$_Uninit_copy@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >

; 869  : 			copy_backward(_ITER_BASE(_Where), _Oldend - _Count,
; 870  : 				_Oldend);	// copy hole

	mov	ecx, DWORD PTR tv496[ebp]
	mov	DWORD PTR [ebx+8], eax
	mov	eax, DWORD PTR tv525[ebp]
	add	esp, 16					; 00000010H
	mov	ebx, edi
	call	??$copy_backward@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAV12@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PAV10@00@Z ; std::copy_backward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>

; 871  : 			fill(_ITER_BASE(_Where), _ITER_BASE(_Where) + _Count,
; 872  : 				_Tmp);	// insert into hole

	add	edi, esi
$L42705:
	mov	eax, DWORD PTR __Where$[ebp]
	lea	ebx, DWORD PTR __Tmp$[ebp]
	call	??$fill@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0ABV10@@Z ; std::fill<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
$L14947:

; 873  : 			}
; 874  : 		}

	cmp	DWORD PTR __Tmp$[ebp+24], 16		; 00000010H
	jb	SHORT $L42690
	mov	eax, DWORD PTR __Tmp$[ebp+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L42690:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$L42704:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L42236:
	lea	ecx, DWORD PTR __Tmp$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
	mov	eax, OFFSET FLAT:$T42701
	jmp	___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n
; Function compile flags: /Ogtpy
;	COMDAT ?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv90 = 8						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert, COMDAT
; _this$ = edi

; 620  : 		{	// insert _Val at _Where

	push	ebx

; 621  : 		size_type _Off = size() == 0 ? 0 : _Where - begin();

	mov	ebx, DWORD PTR __Where$[esp]
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+4]
	push	esi
	mov	esi, DWORD PTR [edi+4]
	test	esi, esi
	je	SHORT $L42779
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR tv90[esp+8], eax
	jne	SHORT $L42718
$L42779:
	xor	esi, esi
	jmp	SHORT $L42719
$L42718:
	mov	ecx, ebx
	sub	ecx, esi
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$L42719:

; 622  : 		_Insert_n(_Where, (size_type)1, _Val);

	mov	ecx, DWORD PTR __Val$[esp+8]
	push	ecx
	push	1
	push	ebx
	push	edi
	call	?_Insert_n@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXViterator@12@IABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Insert_n

; 623  : 		return (begin() + _Off);

	imul	esi, 28					; 0000001cH
	add	esi, DWORD PTR [edi+4]
	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx

; 624  : 		}

	ret	12					; 0000000cH
?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T42785 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy, COMDAT
; _this$ = eax

; 1142 : 		{	// free all storage

	push	ecx
	push	edi
	mov	edi, eax

; 1143 : 		erase(begin(), end());

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T42785[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase

; 1144 : 		this->_Alptr.destroy(&_Left(_Myhead));
; 1145 : 		this->_Alptr.destroy(&_Parent(_Myhead));
; 1146 : 		this->_Alptr.destroy(&_Right(_Myhead));
; 1147 : 		this->_Alnod.deallocate(_Myhead, 1);

	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1148 : 		_Myhead = 0, _Mysize = 0;

	xor	eax, eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	pop	edi

; 1149 : 		}

	pop	ecx
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\vector
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__Cat$42884 = 8						; size = 1
$T42849 = 8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC NEAR ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = eax

; 579  : 		{	// insert element at end

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Val$[esp+4]
	push	esi
	push	edi
	mov	edi, eax

; 580  : 		if (size() < capacity())

	mov	ebx, DWORD PTR [edi+4]
	test	ebx, ebx
	jne	SHORT $L42855
	xor	esi, esi
	jmp	SHORT $L42856
$L42855:
	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
$L42856:
	test	ebx, ebx
	je	SHORT $L13975
	mov	ecx, DWORD PTR [edi+12]
	sub	ecx, ebx
	mov	eax, -1840700269			; 92492493H
	imul	ecx
	add	edx, ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	esi, eax
	jae	SHORT $L13975

; 581  : 			_Mylast = _Ufill(_Mylast, 1, _Val);

	mov	eax, DWORD PTR __Cat$42884[esp+12]
	mov	esi, DWORD PTR [edi+8]
	push	eax
	push	edi
	push	ebp
	push	esi
	mov	ecx, 1
	call	??$_Uninit_fill_n@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IV12@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@IABV10@AAV?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::basic_string<char,std::char_traits<char>,std::allocator<char> > *,unsigned int,std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	add	esp, 16					; 00000010H
	add	esi, 28					; 0000001cH
	mov	DWORD PTR [edi+8], esi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 584  : 		}

	ret	4
$L13975:

; 582  : 		else
; 583  : 			insert(end(), _Val);

	mov	eax, DWORD PTR [edi+8]
	push	ebp
	push	eax
	lea	ecx, DWORD PTR $T42849[esp+20]
	push	ecx
	call	?insert@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AViterator@12@V312@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::insert
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 584  : 		}

	ret	4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
_TEXT	ENDS
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T42973 = -4						; size = 4
??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT
; _this$ = eax

; 391  : 		{	// destroy tree

	push	ecx
	push	edi
	mov	edi, eax

; 392  : 		_Tidy();

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T42973[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	pop	edi

; 393  : 		}

	pop	ecx
	ret	0
??1?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::~_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\map
_TEXT	ENDS
;	COMDAT ??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ PROC NEAR ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = esi

; 102  : 		{	// construct empty map from defaults

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+41], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax
	mov	DWORD PTR [esi+8], 0

; 103  : 		}

	mov	eax, esi
	ret	0
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
PUBLIC	?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z ; Json::Path::makePath
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T44171	DD	0ffffffffH
	DD	FLAT:$L43169
	DD	0ffffffffH
	DD	FLAT:$L43170
	DD	01H
	DD	FLAT:$L43171
$T44157	DD	019930520H
	DD	03H
	DD	FLAT:$T44171
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
xdata$x	ENDS
;	COMDAT ?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
_TEXT	SEGMENT
$T43168 = -112						; size = 28
$T43166 = -84						; size = 36
$T43167 = -48						; size = 36
__$EHRec$ = -12						; size = 12
_itInArg$ = 8						; size = 4
_this$ = 8						; size = 4
_end$ = 12						; size = 4
_path$ = 12						; size = 4
__Cat$43534 = 16					; size = 1
_in$ = 16						; size = 4
?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z PROC NEAR ; Json::Path::makePath, COMDAT

; 1478 : {

	push	-1
	mov	eax, DWORD PTR fs:__except_list
	push	__ehhandler$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z
	push	eax
	mov	eax, DWORD PTR _path$[esp+8]
	mov	DWORD PTR fs:__except_list, esp

; 1479 :    const char *current = path.c_str();

	mov	ecx, DWORD PTR [eax+24]
	sub	esp, 100				; 00000064H
	cmp	ecx, 16					; 00000010H
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+112]
	push	esi
	push	edi
	jb	SHORT $L43183
	mov	esi, DWORD PTR [eax+4]
	jmp	SHORT $L43184
$L43183:
	lea	esi, DWORD PTR [eax+4]
$L43184:

; 1480 :    const char *end = current + path.length();

	mov	eax, DWORD PTR [eax+20]

; 1481 :    InArgs::const_iterator itInArg = in.begin();

	mov	edi, DWORD PTR _in$[esp+120]
	mov	ecx, DWORD PTR [edi+4]
	lea	edx, DWORD PTR [eax+esi]

; 1482 :    while ( current != end )

	cmp	esi, edx
	mov	DWORD PTR _end$[esp+120], edx
	mov	DWORD PTR _itInArg$[esp+120], ecx
	je	$L44163
	push	ebx
	xor	ebx, ebx
	jmp	SHORT $L12945
$L44167:
	mov	edi, DWORD PTR _in$[esp+124]
	mov	ecx, DWORD PTR _itInArg$[esp+124]
	npad	4
$L12945:

; 1483 :    {
; 1484 :       if ( *current == '[' )

	mov	al, BYTE PTR [esi]
	cmp	al, 91					; 0000005bH
	jne	$L12947

; 1485 :       {
; 1486 :          ++current;
; 1487 :          if ( *current == '%' )

	mov	al, BYTE PTR [esi+1]
	inc	esi
	cmp	al, 37					; 00000025H
	jne	SHORT $L12948

; 1488 :             addPathInArg( path, in, itInArg, PathArgument::kindIndex );

	cmp	ecx, DWORD PTR [edi+8]
	je	$L43653
	mov	ecx, DWORD PTR [ecx]
	cmp	DWORD PTR [ecx+32], 1
	jne	$L43653
	mov	eax, ebp
	call	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back

; 1489 :          else

	jmp	$L44170
$L12948:

; 1490 :          {
; 1491 :             Value::UInt index = 0;

	xor	eax, eax

; 1492 :             for ( ; current != end && *current >= '0'  &&  *current <= '9'; ++current )

	cmp	esi, edx
	je	SHORT $L12953
	npad	7
$L12951:
	mov	cl, BYTE PTR [esi]
	cmp	cl, 48					; 00000030H
	jl	SHORT $L12953
	cmp	cl, 57					; 00000039H
	jg	SHORT $L12953

; 1493 :                index = index * 10 + Value::UInt(*current - '0');

	movsx	ecx, cl
	inc	esi
	cmp	esi, edx
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [ecx+eax*2-48]
	jne	SHORT $L12951
$L12953:

; 1494 :             args_.push_back( index );

	mov	DWORD PTR $T43166[esp+152], 15		; 0000000fH
	mov	DWORD PTR $T43166[esp+148], ebx
	mov	BYTE PTR $T43166[esp+132], bl
	mov	DWORD PTR $T43166[esp+156], eax
	mov	DWORD PTR $T43166[esp+160], 1
	mov	DWORD PTR __$EHRec$[esp+136], ebx
	mov	edi, DWORD PTR [ebp+4]
	cmp	edi, ebx
	jne	SHORT $L43521
	xor	ecx, ecx
	jmp	SHORT $L43522
$L43521:
	mov	ecx, DWORD PTR [ebp+8]
	sub	ecx, edi
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 3
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
$L43522:
	cmp	edi, ebx
	je	SHORT $L44165
	mov	edx, DWORD PTR [ebp+12]
	sub	edx, edi
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 3
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	ecx, eax
	jae	SHORT $L44165
	mov	edx, DWORD PTR __Cat$43534[esp+124]
	mov	edi, DWORD PTR [ebp+8]
	push	edx
	push	1
	push	edi
	lea	ecx, DWORD PTR $T43166[esp+140]
	call	??$_Uninit_fill_n@PAVPathArgument@Json@@IV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@IABV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::PathArgument *,unsigned int,Json::PathArgument,std::allocator<Json::PathArgument> >
	add	esp, 12					; 0000000cH
	add	edi, 36					; 00000024H
	mov	DWORD PTR [ebp+8], edi
	jmp	SHORT $L43571
$L44165:
	mov	eax, DWORD PTR [ebp+8]
	push	1
	push	eax
	push	ebp
	lea	ecx, DWORD PTR $T43166[esp+140]
	call	?_Insert_n@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Insert_n
$L43571:
	mov	DWORD PTR __$EHRec$[esp+136], -1
	cmp	DWORD PTR $T43166[esp+152], 16		; 00000010H
	jb	SHORT $L43663
	mov	eax, DWORD PTR $T43166[esp+132]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L43663:
	mov	DWORD PTR $T43166[esp+152], 15		; 0000000fH
	mov	DWORD PTR $T43166[esp+148], ebx
	mov	BYTE PTR $T43166[esp+132], bl
$L44170:
	mov	edx, DWORD PTR _end$[esp+124]
$L43653:

; 1495 :          }
; 1496 :          if ( current == end  ||  *current++ != ']' )

	cmp	esi, edx
	je	$L44169
	inc	esi

; 1497 :             invalidPath( path, int(current - path.c_str()) );
; 1498 :       }
; 1499 :       else if ( *current == '%' )

	jmp	$L44150
$L12947:
	cmp	al, 37					; 00000025H
	jne	SHORT $L12958

; 1500 :       {
; 1501 :          addPathInArg( path, in, itInArg, PathArgument::kindKey );

	cmp	ecx, DWORD PTR [edi+8]
	je	SHORT $L43726
	mov	ecx, DWORD PTR [ecx]
	cmp	DWORD PTR [ecx+32], 2
	jne	SHORT $L43726
	mov	eax, ebp
	call	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
	mov	edx, DWORD PTR _end$[esp+124]
$L43726:

; 1502 :          ++current;

	inc	esi

; 1503 :       }
; 1504 :       else if ( *current == '.' )

	jmp	$L44150
$L12958:
	cmp	al, 46					; 0000002eH
	jne	SHORT $L12960

; 1505 :       {
; 1506 :          ++current;

	inc	esi

; 1507 :       }
; 1508 :       else

	jmp	$L44150
$L12960:

; 1509 :       {
; 1510 :          const char *beginName = current;
; 1511 :          while ( current != end  &&  !strchr( "[.", *current ) )

	cmp	esi, edx
	mov	edi, esi
	je	SHORT $L44166
$L12964:
	movsx	ecx, BYTE PTR [esi]
	push	ecx
	push	OFFSET FLAT:??_C@_02GLFAOOJA@?$FL?4?$AA@
	call	_strchr
	add	esp, 8
	test	eax, eax
	jne	SHORT $L44166
	mov	eax, DWORD PTR _end$[esp+124]

; 1512 :             ++current;

	inc	esi
	cmp	esi, eax
	jne	SHORT $L12964
$L44166:

; 1513 :          args_.push_back( std::string( beginName, current ) );

	cmp	edi, esi
	mov	DWORD PTR $T43168[esp+152], 15		; 0000000fH
	mov	DWORD PTR $T43168[esp+148], ebx
	mov	BYTE PTR $T43168[esp+132], bl
	je	SHORT $L43792
	mov	edx, esi
	sub	edx, edi
	push	edx
	push	edi
	lea	ecx, DWORD PTR $T43168[esp+136]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L43792:
	mov	DWORD PTR __$EHRec$[esp+136], 1
	cmp	DWORD PTR $T43168[esp+152], 16		; 00000010H
	mov	edx, DWORD PTR $T43168[esp+132]
	jae	SHORT $L43950
	lea	edx, DWORD PTR $T43168[esp+132]
$L43950:
	mov	eax, edx
	mov	DWORD PTR $T43167[esp+152], 15		; 0000000fH
	mov	DWORD PTR $T43167[esp+148], ebx
	mov	BYTE PTR $T43167[esp+132], bl
	lea	edi, DWORD PTR [eax+1]
$L44164:
	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, bl
	jne	SHORT $L44164
	sub	eax, edi
	push	eax
	push	edx
	lea	ecx, DWORD PTR $T43167[esp+136]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	DWORD PTR $T43167[esp+160], 2
	lea	ecx, DWORD PTR $T43167[esp+128]
	mov	eax, ebp
	mov	BYTE PTR __$EHRec$[esp+136], 2
	call	?push_back@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXABVPathArgument@Json@@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::push_back
	mov	eax, DWORD PTR $T43167[esp+152]
	mov	edi, 16					; 00000010H
	cmp	eax, edi
	jb	SHORT $L44076
	mov	eax, DWORD PTR $T43167[esp+132]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L44076:
	mov	DWORD PTR __$EHRec$[esp+136], -1
	cmp	DWORD PTR $T43168[esp+152], edi
	mov	DWORD PTR $T43167[esp+152], 15		; 0000000fH
	mov	DWORD PTR $T43167[esp+148], ebx
	mov	BYTE PTR $T43167[esp+132], bl
	jb	SHORT $L44140
	mov	ecx, DWORD PTR $T43168[esp+132]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L44140:
	mov	edx, DWORD PTR _end$[esp+124]
	mov	DWORD PTR $T43168[esp+152], 15		; 0000000fH
	mov	DWORD PTR $T43168[esp+148], ebx
	mov	BYTE PTR $T43168[esp+132], bl
$L44150:

; 1482 :    while ( current != end )

	cmp	esi, edx
	jne	$L44167
$L44169:
	pop	ebx
$L44163:

; 1514 :       }
; 1515 :    }
; 1516 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+124]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 112				; 00000070H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L43169:
	lea	esi, DWORD PTR $T43166[ebp]
	jmp	??1PathArgument@Json@@QAE@XZ
$L43170:
	lea	ecx, DWORD PTR $T43168[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L43171:
	lea	esi, DWORD PTR $T43167[ebp]
	jmp	??1PathArgument@Json@@QAE@XZ
__ehhandler$?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z:
	mov	eax, OFFSET FLAT:$T44157
	jmp	___CxxFrameHandler
text$x	ENDS
?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z ENDP ; Json::Path::makePath
PUBLIC	??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z ; Json::Path::Path
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T45642	DD	0ffffffffH
	DD	FLAT:$L44182
	DD	00H
	DD	FLAT:$L44183
$T45621	DD	019930520H
	DD	02H
	DD	FLAT:$T45642
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
xdata$x	ENDS
;	COMDAT ??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
_TEXT	SEGMENT
_in$ = -28						; size = 16
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_path$ = 12						; size = 4
$T44178 = 16						; size = 4
$T44177 = 16						; size = 4
_a1$ = 16						; size = 4
$T44181 = 20						; size = 4
$T44180 = 20						; size = 4
$T44179 = 20						; size = 4
_a2$ = 20						; size = 4
_a3$ = 24						; size = 4
_a4$ = 28						; size = 4
_a5$ = 32						; size = 4
??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z PROC NEAR ; Json::Path::Path, COMDAT

; 1464 : {

	push	-1
	push	__ehhandler$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+32]
	xor	ebx, ebx
	push	esi
	push	edi
	mov	DWORD PTR [ebp+4], ebx
	mov	DWORD PTR [ebp+8], ebx
	mov	DWORD PTR [ebp+12], ebx
	mov	DWORD PTR __$EHRec$[esp+52], ebx

; 1465 :    InArgs in;

	mov	DWORD PTR _in$[esp+48], ebx
	mov	DWORD PTR _in$[esp+52], ebx
	mov	DWORD PTR _in$[esp+56], ebx
	mov	BYTE PTR __$EHRec$[esp+52], 1

; 1466 :    in.push_back( &a1 );

	mov	eax, DWORD PTR _a1$[esp+40]
	mov	DWORD PTR $T44177[esp+40], eax
	xor	eax, eax
	push	eax
	lea	ecx, DWORD PTR _in$[esp+48]
	push	ecx
	lea	eax, DWORD PTR $T44177[esp+48]
	mov	ecx, 1
	call	?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n

; 1467 :    in.push_back( &a2 );

	mov	esi, DWORD PTR _in$[esp+48]
	cmp	esi, ebx
	mov	edx, DWORD PTR _a2$[esp+40]
	mov	eax, DWORD PTR _in$[esp+52]
	mov	DWORD PTR $T44178[esp+40], edx
	je	SHORT $L45638
	mov	ecx, DWORD PTR _in$[esp+56]
	mov	edx, eax
	mov	edi, ecx
	sub	edx, esi
	sub	edi, esi
	sar	edx, 2
	sar	edi, 2
	cmp	edx, edi
	jae	SHORT $L45638
	mov	edx, DWORD PTR _a2$[esp+40]
	mov	DWORD PTR [eax], edx
	add	eax, 4
	mov	DWORD PTR _in$[esp+52], eax
	jmp	SHORT $L44844
$L45638:
	push	eax
	lea	eax, DWORD PTR _in$[esp+48]
	push	eax
	lea	eax, DWORD PTR $T44178[esp+48]
	mov	ecx, 1
	call	?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n
	mov	ecx, DWORD PTR _in$[esp+56]
	mov	eax, DWORD PTR _in$[esp+52]
	mov	esi, DWORD PTR _in$[esp+48]
$L44844:

; 1468 :    in.push_back( &a3 );

	cmp	esi, ebx
	mov	edx, DWORD PTR _a3$[esp+40]
	mov	DWORD PTR $T44179[esp+40], edx
	je	SHORT $L45639
	mov	edx, eax
	mov	edi, ecx
	sub	edx, esi
	sub	edi, esi
	sar	edx, 2
	sar	edi, 2
	cmp	edx, edi
	jae	SHORT $L45639
	mov	edx, DWORD PTR _a3$[esp+40]
	mov	DWORD PTR [eax], edx
	add	eax, 4
	mov	DWORD PTR _in$[esp+52], eax
	jmp	SHORT $L45096
$L45639:
	push	eax
	lea	eax, DWORD PTR _in$[esp+48]
	push	eax
	lea	eax, DWORD PTR $T44179[esp+48]
	mov	ecx, 1
	call	?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n
	mov	ecx, DWORD PTR _in$[esp+56]
	mov	eax, DWORD PTR _in$[esp+52]
	mov	esi, DWORD PTR _in$[esp+48]
$L45096:

; 1469 :    in.push_back( &a4 );

	cmp	esi, ebx
	mov	edx, DWORD PTR _a4$[esp+40]
	mov	DWORD PTR $T44180[esp+40], edx
	je	SHORT $L45640
	mov	edx, eax
	mov	edi, ecx
	sub	edx, esi
	sub	edi, esi
	sar	edx, 2
	sar	edi, 2
	cmp	edx, edi
	jae	SHORT $L45640
	mov	edx, DWORD PTR _a4$[esp+40]
	mov	DWORD PTR [eax], edx
	add	eax, 4
	mov	DWORD PTR _in$[esp+52], eax
	jmp	SHORT $L45344
$L45640:
	push	eax
	lea	eax, DWORD PTR _in$[esp+48]
	push	eax
	lea	eax, DWORD PTR $T44180[esp+48]
	mov	ecx, 1
	call	?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n
	mov	ecx, DWORD PTR _in$[esp+56]
	mov	eax, DWORD PTR _in$[esp+52]
	mov	esi, DWORD PTR _in$[esp+48]
$L45344:

; 1470 :    in.push_back( &a5 );

	cmp	esi, ebx
	mov	edi, DWORD PTR _a5$[esp+40]
	mov	DWORD PTR $T44181[esp+40], edi
	je	SHORT $L45534
	mov	edx, eax
	sub	edx, esi
	sub	ecx, esi
	sar	edx, 2
	sar	ecx, 2
	cmp	edx, ecx
	jae	SHORT $L45534
	mov	DWORD PTR [eax], edi
	add	eax, 4
	mov	DWORD PTR _in$[esp+52], eax
	jmp	SHORT $L45597
$L45534:
	push	eax
	lea	ecx, DWORD PTR _in$[esp+48]
	push	ecx
	lea	eax, DWORD PTR $T44181[esp+48]
	mov	ecx, 1
	call	?_Insert_n@?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@IAEXViterator@12@IABQBVPathArgument@Json@@@Z ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::_Insert_n
	mov	esi, DWORD PTR _in$[esp+48]
$L45597:

; 1471 :    makePath( path, in );

	mov	eax, DWORD PTR _path$[esp+40]
	lea	edx, DWORD PTR _in$[esp+44]
	push	edx
	push	eax
	push	ebp
	call	?makePath@Path@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@4@@Z ; Json::Path::makePath

; 1472 : }

	cmp	esi, ebx
	je	SHORT $L45637
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L45637:
	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	pop	edi
	pop	esi
	mov	eax, ebp
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 28					; 0000001cH
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L44182:
	mov	ebx, DWORD PTR _this$[ebp-4]
	jmp	??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
$L44183:
	lea	esi, DWORD PTR _in$[ebp]
	jmp	??1?$vector@PBVPathArgument@Json@@V?$allocator@PBVPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >::~vector<Json::PathArgument const *,std::allocator<Json::PathArgument const *> >
__ehhandler$??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z:
	mov	eax, OFFSET FLAT:$T45621
	jmp	___CxxFrameHandler
text$x	ENDS
??0Path@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVPathArgument@1@1111@Z ENDP ; Json::Path::Path
PUBLIC	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T46503	DD	0ffffffffH
	DD	FLAT:$L45651
	DD	00H
	DD	FLAT:$L45652
$T46492	DD	019930520H
	DD	02H
	DD	FLAT:$T46503
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
xdata$x	ENDS
;	COMDAT ?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
_TEXT	SEGMENT
$T45654 = -60						; size = 4
$T45649 = -60						; size = 4
_members$ = -56						; size = 16
$T45650 = -40						; size = 28
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ PROC NEAR ; Json::Value::getMemberNames, COMDAT
; _this$ = ecx

; 1132 : {

	push	-1
	push	__ehhandler$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 48					; 00000030H
	push	ebx

; 1133 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1134 :    Members members;
; 1135 :    members.reserve( value_.map_->size() );
; 1136 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1137 :    ObjectValues::const_iterator it = value_.map_->begin();
; 1138 :    ObjectValues::const_iterator itEnd = value_.map_->end();
; 1139 :    for ( ; it != itEnd; ++it )

	xor	ebx, ebx
	push	ebp
	push	esi
	mov	DWORD PTR $T45654[esp+72], ebx
	push	edi
	mov	esi, ecx
	mov	DWORD PTR _members$[esp+80], ebx
	mov	DWORD PTR _members$[esp+84], ebx
	mov	DWORD PTR _members$[esp+88], ebx
	mov	DWORD PTR __$EHRec$[esp+84], ebx
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+8]
	lea	edx, DWORD PTR _members$[esp+76]
	call	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [ecx]
	mov	eax, ecx
	cmp	esi, eax
	mov	DWORD PTR $T45649[esp+76], eax
	je	$L12706
	npad	9
$L45868:

; 1140 :       members.push_back( std::string( (*it).first.c_str() ) );

	mov	edi, DWORD PTR [esi+16]
	mov	ebp, 15					; 0000000fH
	mov	eax, edi
	mov	DWORD PTR $T45650[esp+100], ebp
	mov	DWORD PTR $T45650[esp+96], ebx
	mov	BYTE PTR $T45650[esp+80], bl
	lea	edx, DWORD PTR [eax+1]
	npad	7
$L46500:
	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, bl
	jne	SHORT $L46500
	sub	eax, edx
	push	eax
	push	edi
	lea	ecx, DWORD PTR $T45650[esp+84]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T45650[esp+76]
	push	ecx
	lea	eax, DWORD PTR _members$[esp+80]
	mov	BYTE PTR __$EHRec$[esp+88], 1
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
	mov	BYTE PTR __$EHRec$[esp+84], bl
	cmp	DWORD PTR $T45650[esp+100], 16		; 00000010H
	jb	SHORT $L46091
	mov	edx, DWORD PTR $T45650[esp+80]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L46091:
	cmp	BYTE PTR [esi+41], bl
	mov	DWORD PTR $T45650[esp+100], ebp
	mov	DWORD PTR $T45650[esp+96], ebx
	mov	BYTE PTR $T45650[esp+80], bl
	jne	SHORT $L45874
	mov	eax, DWORD PTR [esi+8]
	cmp	BYTE PTR [eax+41], bl
	jne	SHORT $L46495
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+41], bl
	jne	SHORT $L45874

; 1133 :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 1134 :    Members members;
; 1135 :    members.reserve( value_.map_->size() );
; 1136 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1137 :    ObjectValues::const_iterator it = value_.map_->begin();
; 1138 :    ObjectValues::const_iterator itEnd = value_.map_->end();
; 1139 :    for ( ; it != itEnd; ++it )

$L45888:
	mov	esi, eax
	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+41], bl
	je	SHORT $L45888
	jmp	SHORT $L45874
$L46495:
	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+41], bl
	jne	SHORT $L45877
$L45876:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $L45877
	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+41], bl
	je	SHORT $L45876
$L45877:
	mov	esi, eax
$L45874:
	cmp	esi, DWORD PTR $T45649[esp+76]
	jne	$L45868
$L12706:

; 1141 : #else
; 1142 :    ValueInternalMap::IteratorState it;
; 1143 :    ValueInternalMap::IteratorState itEnd;
; 1144 :    value_.map_->makeBeginIterator( it );
; 1145 :    value_.map_->makeEndIterator( itEnd );
; 1146 :    for ( ; !ValueInternalMap::equals( it, itEnd ); ValueInternalMap::increment(it) )
; 1147 :       members.push_back( std::string( ValueInternalMap::key( it ) ) );
; 1148 : #endif
; 1149 :    return members;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+72]
	push	esi
	lea	ecx, DWORD PTR _members$[esp+80]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@ABV01@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	ebp, DWORD PTR _members$[esp+80]
	cmp	ebp, ebx
	je	SHORT $L46501
	mov	edi, DWORD PTR _members$[esp+84]
	cmp	ebp, edi
	je	SHORT $L46487
	lea	esi, DWORD PTR [ebp+24]
$L46485:
	cmp	DWORD PTR [esi], 16			; 00000010H
	jb	SHORT $L46464
	mov	eax, DWORD PTR [esi-20]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L46464:
	mov	DWORD PTR [esi], 15			; 0000000fH
	mov	DWORD PTR [esi-4], ebx
	mov	BYTE PTR [esi-20], bl
	add	esi, 28					; 0000001cH
	lea	ecx, DWORD PTR [esi-24]
	cmp	ecx, edi
	jne	SHORT $L46485
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+72]
$L46487:
	push	ebp
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L46501:

; 1150 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 60					; 0000003cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L45651:
	lea	esi, DWORD PTR _members$[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$L45652:
	lea	ecx, DWORD PTR $T45650[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ:
	mov	eax, OFFSET FLAT:$T46492
	jmp	___CxxFrameHandler
text$x	ENDS
?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ENDP ; Json::Value::getMemberNames
; Function compile flags: /Ogtpy
;	COMDAT ??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
_TEXT	SEGMENT
$T46609 = -4						; size = 4
??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ PROC NEAR ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = eax
	push	ecx
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [eax]
	push	eax
	push	ecx
	lea	eax, DWORD PTR $T46609[esp+16]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	xor	eax, eax
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], eax
	pop	edi
	pop	ecx
	ret	0
??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::~map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z PROC NEAR ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::`scalar deleting destructor', COMDAT
; _this$ = esi
	mov	eax, esi
	call	??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
	test	BYTE PTR ___flags$[esp-4], 1
	je	SHORT $L46637
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L46637:
	mov	eax, esi
	ret	4
??_G?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAEPAXI@Z ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::`scalar deleting destructor'
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1Value@Json@@QAE@XZ
_TEXT	SEGMENT
??1Value@Json@@QAE@XZ PROC NEAR				; Json::Value::~Value, COMDAT
; _this$ = ecx

; 452  : {

	push	esi
	mov	esi, ecx

; 453  :    switch ( type_ )

	movsx	eax, BYTE PTR [esi+8]
	cmp	eax, 4
	push	edi
	je	SHORT $L12081
	cmp	eax, 5
	jle	SHORT $L12082
	cmp	eax, 7
	jg	SHORT $L12082

; 464  :       break;
; 465  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 466  :    case arrayValue:
; 467  :    case objectValue:
; 468  :       delete value_.map_;

	mov	edi, DWORD PTR [esi]
	test	edi, edi
	je	SHORT $L12082
	mov	eax, edi
	call	??1?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ
	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 469  :       break;

	jmp	SHORT $L12082
$L12081:

; 454  :    {
; 455  :    case nullValue:
; 456  :    case intValue:
; 457  :    case uintValue:
; 458  :    case realValue:
; 459  :    case booleanValue:
; 460  :       break;
; 461  :    case stringValue:
; 462  :       if ( allocated_ )

	mov	eax, DWORD PTR [esi+8]
	test	ah, 1
	je	SHORT $L12082

; 463  :          valueAllocator()->releaseStringValue( value_.string_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+16]
$L12082:

; 470  : #else
; 471  :    case arrayValue:
; 472  :       arrayAllocator()->destructArray( value_.array_ );
; 473  :       break;
; 474  :    case objectValue:
; 475  :       mapAllocator()->destructMap( value_.map_ );
; 476  :       break;
; 477  : #endif
; 478  :    default:
; 479  :       JSON_ASSERT_UNREACHABLE;
; 480  :    }
; 481  : 
; 482  :    if ( comments_ )

	mov	esi, DWORD PTR [esi+12]
	test	esi, esi
	je	SHORT $L46647

; 483  :       delete[] comments_;

	mov	eax, DWORD PTR [esi-4]
	push	OFFSET FLAT:??1CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::~CommentInfo
	lea	edi, DWORD PTR [esi-4]
	push	eax
	push	4
	push	esi
	call	??_M@YGXPAXIHP6EX0@Z@Z
	push	edi
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L46647:
	pop	edi
	pop	esi

; 484  : }

	ret	0
??1Value@Json@@QAE@XZ ENDP				; Json::Value::~Value
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@W4ValueType@1@@Z		; Json::Value::Value
;	COMDAT xdata$x
xdata$x	SEGMENT
$T46679	DD	0ffffffffH
	DD	FLAT:$L46674
$T46676	DD	019930520H
	DD	01H
	DD	FLAT:$T46679
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0Value@Json@@QAE@W4ValueType@1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
$T46671 = 8						; size = 4
_type$ = 8						; size = 4
??0Value@Json@@QAE@W4ValueType@1@@Z PROC NEAR		; Json::Value::Value, COMDAT
; _this$ = edi

; 269  : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??0Value@Json@@QAE@W4ValueType@1@@Z
	push	eax
	mov	eax, DWORD PTR _type$[esp+8]
	mov	DWORD PTR fs:__except_list, esp
	mov	BYTE PTR [edi+8], al
	mov	edx, DWORD PTR [edi+8]
	and	edx, -257				; fffffeffH

; 270  :    switch ( type )

	dec	eax
	cmp	eax, 6
	push	esi
	mov	DWORD PTR [edi+8], edx
	mov	DWORD PTR [edi+12], 0
	ja	$L11999
	jmp	DWORD PTR $L46678[eax*4]
$L11990:

; 271  :    {
; 272  :    case nullValue:
; 273  :       break;
; 274  :    case intValue:
; 275  :    case uintValue:
; 276  :       value_.int_ = 0;

	mov	DWORD PTR [edi], 0

; 299  :       break;
; 300  :    default:
; 301  :       JSON_ASSERT_UNREACHABLE;
; 302  :    }
; 303  : }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
$L11991:

; 277  :       break;
; 278  :    case realValue:
; 279  :       value_.real_ = 0.0;

	fld	QWORD PTR __real@0000000000000000

; 299  :       break;
; 300  :    default:
; 301  :       JSON_ASSERT_UNREACHABLE;
; 302  :    }
; 303  : }

	mov	eax, edi
	fstp	QWORD PTR [edi]
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
$L11993:

; 280  :       break;
; 281  :    case stringValue:
; 282  :       value_.string_ = 0;
; 283  :       break;
; 284  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 285  :    case arrayValue:
; 286  :    case objectValue:
; 287  :       value_.map_ = new ObjectValues();

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T46671[esp+12], eax
	test	eax, eax
	mov	DWORD PTR __$EHRec$[esp+24], 0
	je	SHORT $L46672
	mov	esi, eax
	call	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
	mov	DWORD PTR [edi], eax

; 299  :       break;
; 300  :    default:
; 301  :       JSON_ASSERT_UNREACHABLE;
; 302  :    }
; 303  : }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
$L46672:

; 280  :       break;
; 281  :    case stringValue:
; 282  :       value_.string_ = 0;
; 283  :       break;
; 284  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 285  :    case arrayValue:
; 286  :    case objectValue:
; 287  :       value_.map_ = new ObjectValues();

	xor	eax, eax
	mov	DWORD PTR [edi], eax

; 299  :       break;
; 300  :    default:
; 301  :       JSON_ASSERT_UNREACHABLE;
; 302  :    }
; 303  : }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
$L11998:

; 288  :       break;
; 289  : #else
; 290  :    case arrayValue:
; 291  :       value_.array_ = arrayAllocator()->newArray();
; 292  :       break;
; 293  :    case objectValue:
; 294  :       value_.map_ = mapAllocator()->newMap();
; 295  :       break;
; 296  : #endif
; 297  :    case booleanValue:
; 298  :       value_.bool_ = false;

	mov	BYTE PTR [edi], 0
$L11999:

; 299  :       break;
; 300  :    default:
; 301  :       JSON_ASSERT_UNREACHABLE;
; 302  :    }
; 303  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	eax, edi
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
	npad	3
$L46678:
	DD	$L11990
	DD	$L11990
	DD	$L11991
	DD	$L11990
	DD	$L11998
	DD	$L11993
	DD	$L11993
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46674:
	mov	eax, DWORD PTR $T46671[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
__ehhandler$??0Value@Json@@QAE@W4ValueType@1@@Z:
	mov	eax, OFFSET FLAT:$T46676
	jmp	___CxxFrameHandler
text$x	ENDS
??0Value@Json@@QAE@W4ValueType@1@@Z ENDP		; Json::Value::Value
PUBLIC	?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ	; Json::ValueIteratorBase::key
;	COMDAT xdata$x
xdata$x	SEGMENT
$T46904	DD	0ffffffffH
	DD	FLAT:$L46687
	DD	00H
	DD	FLAT:$L46686
$T46899	DD	019930520H
	DD	02H
	DD	FLAT:$T46904
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_valueiterator.inl
xdata$x	ENDS
;	COMDAT ?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
_TEXT	SEGMENT
$T46688 = -24						; size = 4
_czstring$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ PROC NEAR	; Json::ValueIteratorBase::key, COMDAT

; 122  : {

	push	-1
	push	__ehhandler$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH

; 123  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 124  :    const Value::CZString czstring = (*current_).first;

	mov	eax, DWORD PTR _this$[esp+20]
	push	ebx
	push	ebp
	push	esi
	xor	ebx, ebx
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[esp+36]
	mov	DWORD PTR $T46688[esp+40], ebx
	mov	esi, DWORD PTR [eax]
	mov	eax, DWORD PTR [esi+20]
	add	esi, 16					; 00000010H
	cmp	eax, ebx
	je	SHORT $L46729
	cmp	DWORD PTR [esi], ebx
	je	SHORT $L46729
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, 1
	jne	SHORT $L46735
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, 1
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L46735:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	eax, DWORD PTR [esi]
	mov	edx, DWORD PTR [ecx]
	push	eax
	call	DWORD PTR [edx+4]
	mov	ebp, eax
	jmp	SHORT $L46901
$L46729:
	mov	ebp, DWORD PTR [esi]
$L46901:
	cmp	DWORD PTR [esi], ebx
	mov	DWORD PTR _czstring$[esp+40], ebp
	je	SHORT $L46731
	mov	eax, DWORD PTR [esi+4]
	xor	ecx, ecx
	cmp	eax, ebx
	setne	cl
	mov	esi, ecx
	jmp	SHORT $L46902
$L46731:
	mov	esi, DWORD PTR [esi+4]
$L46902:
	mov	DWORD PTR _czstring$[esp+44], esi

; 125  :    if ( czstring.c_str() )

	cmp	ebp, ebx
	mov	eax, 1
	mov	DWORD PTR __$EHRec$[esp+48], eax

; 126  :    {
; 127  :       if ( czstring.isStaticString() )
; 128  :          return Value( StaticString( czstring.c_str() ) );

	mov	DWORD PTR [edi+12], ebx
	je	$L11864
	cmp	esi, ebx
	mov	BYTE PTR [edi+8], 4
	jne	SHORT $L11865
	and	DWORD PTR [edi+8], -257			; fffffeffH
	mov	DWORD PTR [edi], ebp
	jmp	$L46903
$L11865:

; 129  :       return Value( czstring.c_str() );

	mov	edx, DWORD PTR [edi+8]
	mov	cl, BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, 256				; 00000100H
	test	cl, 1
	mov	DWORD PTR [edi+8], edx
	jne	SHORT $L46820
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, eax
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L46820:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [ecx]
	push	-1
	push	ebp
	call	DWORD PTR [edx+12]
	mov	DWORD PTR [edi], eax
	mov	eax, 1
	cmp	esi, eax
	mov	DWORD PTR $T46688[esp+40], eax
	mov	BYTE PTR __$EHRec$[esp+48], bl
	jne	SHORT $L46903
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, al
	jne	SHORT $L46853
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, eax
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L46853:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	eax, DWORD PTR [ecx]
	push	ebp
	call	DWORD PTR [eax+8]
	jmp	SHORT $L46903
$L11864:

; 130  :    }
; 131  :    return Value( czstring.index() );

	mov	BYTE PTR [edi+8], 1
	mov	DWORD PTR [edi], esi
$L46903:

; 132  : #else
; 133  :    if ( isArray_ )
; 134  :       return Value( ValueInternalArray::indexOf( iterator_.array_ ) );
; 135  :    bool isStatic;
; 136  :    const char *memberName = ValueInternalMap::key( iterator_.map_, isStatic );
; 137  :    if ( isStatic )
; 138  :       return Value( StaticString( memberName ) );
; 139  :    return Value( memberName );
; 140  : #endif
; 141  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 24					; 00000018H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L46686:
	lea	esi, DWORD PTR _czstring$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
$L46687:
	mov	eax, DWORD PTR $T46688[ebp]
	and	eax, 1
	je	$L46689
	and	DWORD PTR $T46688[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp-4]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L46689:
	ret	0
__ehhandler$?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ:
	mov	eax, OFFSET FLAT:$T46899
	jmp	___CxxFrameHandler
text$x	ENDS
?key@ValueIteratorBase@Json@@QBE?AVValue@2@XZ ENDP	; Json::ValueIteratorBase::key
PUBLIC	?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Value::toStyledString
;	COMDAT xdata$x
; File f:\libs\jsoncpp\trunk\src\lib_json\json_writer.cpp
xdata$x	SEGMENT
$T50387	DD	0ffffffffH
	DD	FLAT:$L50129
$T50383	DD	019930520H
	DD	01H
	DD	FLAT:$T50387
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
xdata$x	ENDS
;	COMDAT ?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T50131 = -72						; size = 4
_writer$ = -68						; size = 52
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC NEAR ; Json::Value::toStyledString, COMDAT
; ___$ReturnUdt$ = esi

; 1278 : {

	push	-1
	push	__ehhandler$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR __$ArrayPad$[esp+76], eax
	mov	DWORD PTR $T50131[esp+76], ebx

; 1279 :    StyledWriter writer;

	mov	DWORD PTR _writer$[esp+76], ebx
	mov	DWORD PTR _writer$[esp+80], ebx
	mov	DWORD PTR _writer$[esp+84], ebx
	mov	DWORD PTR _writer$[esp+112], 15		; 0000000fH
	mov	DWORD PTR _writer$[esp+108], ebx
	mov	BYTE PTR _writer$[esp+92], bl
	mov	DWORD PTR _writer$[esp+116], 74		; 0000004aH
	mov	DWORD PTR _writer$[esp+120], 3

; 1280 :    return writer.write( *this );

	mov	eax, DWORD PTR _this$[esp+72]
	push	eax
	push	esi
	lea	eax, DWORD PTR _writer$[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], ebx
	call	?write@StyledWriter@Json@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::StyledWriter::write
	cmp	DWORD PTR _writer$[esp+112], 16		; 00000010H
	jb	SHORT $L50359
	mov	ecx, DWORD PTR _writer$[esp+92]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L50359:
	mov	eax, DWORD PTR _writer$[esp+76]
	mov	DWORD PTR _writer$[esp+108], ebx
	mov	BYTE PTR _writer$[esp+92], bl
	cmp	eax, ebx
	mov	DWORD PTR _writer$[esp+112], 15		; 0000000fH
	pop	ebx
	je	SHORT $L50384
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$L50384:

; 1281 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+72]
	mov	eax, esi
	call	@__security_check_cookie@4
	add	esp, 72					; 00000048H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L50129:
	lea	esi, DWORD PTR _writer$[ebp]
	jmp	??1StyledWriter@Json@@QAE@XZ
__ehhandler$?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	eax, OFFSET FLAT:$T50383
	jmp	___CxxFrameHandler
text$x	ENDS
?toStyledString@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Value::toStyledString
;	COMDAT xdata$x
xdata$x	SEGMENT
$T50429	DD	0ffffffffH
	DD	FLAT:$L50393
$T50427	DD	019930520H
	DD	01H
	DD	FLAT:$T50429
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ PROC NEAR ; std::pair<Json::Value::CZString const ,Json::Value>::~pair<Json::Value::CZString const ,Json::Value>, COMDAT
	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	esi
	mov	esi, DWORD PTR _this$[esp+12]
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+24], 0
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	mov	DWORD PTR __$EHRec$[esp+24], -1
	cmp	DWORD PTR [esi], 0
	je	SHORT $L50425
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, 1
	cmp	ecx, eax
	jne	SHORT $L50425
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, al
	jne	SHORT $L50422
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, eax
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L50422:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+8]
$L50425:
	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L50393:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ:
	mov	eax, OFFSET FLAT:$T50427
	jmp	___CxxFrameHandler
text$x	ENDS
??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ ENDP ; std::pair<Json::Value::CZString const ,Json::Value>::~pair<Json::Value::CZString const ,Json::Value>
; Function compile flags: /Ogtpy
;	COMDAT ??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::~_Node, COMDAT
; _this$ = ecx
	add	ecx, 16					; 00000010H
	push	ecx
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	ret	0
??1_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::~_Node
_TEXT	ENDS
PUBLIC	??0Value@Json@@QAE@ABV01@@Z			; Json::Value::Value
;	COMDAT xdata$x
xdata$x	SEGMENT
$T50518	DD	0ffffffffH
	DD	FLAT:$L50494
$T50516	DD	019930520H
	DD	01H
	DD	FLAT:$T50518
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Larg$ = 8						; size = 4
$T50514 = 12						; size = 4
__Val$ = 12						; size = 4
__Carg$ = 16						; size = 1
??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z PROC NEAR ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::_Node, COMDAT
; _this$ = esi
; __Parg$ = ecx
; __Rarg$ = edx

; 40   : 			{	// construct a node with value

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
	push	eax
	mov	eax, DWORD PTR __Larg$[esp+8]
	mov	DWORD PTR fs:__except_list, esp
	push	ebp
	mov	ebp, DWORD PTR __Val$[esp+12]
	push	edi
	mov	DWORD PTR [esi], eax
	lea	edi, DWORD PTR [esi+16]
	mov	eax, ebp
	mov	DWORD PTR [esi+4], ecx
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR $T50514[esp+16], edi
	call	??0CZString@Value@Json@@QAE@ABV012@@Z	; Json::Value::CZString::CZString
	add	ebp, 8
	push	ebp
	lea	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	al, BYTE PTR __Carg$[esp+16]

; 41   : 			}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	BYTE PTR [esi+40], al
	pop	edi
	mov	BYTE PTR [esi+41], 0
	mov	eax, esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebp
	add	esp, 12					; 0000000cH
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L50494:
	mov	esi, DWORD PTR $T50514[ebp-4]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z:
	mov	eax, OFFSET FLAT:$T50516
	jmp	___CxxFrameHandler
text$x	ENDS
??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ENDP ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::_Node
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	SEGMENT
$T50549	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L50530
	DD	0ffffffffH
	DD	00H
$T50551	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L50529
$T50550	DD	00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:$T50551
$T50546	DD	019930520H
	DD	03H
	DD	FLAT:$T50549
	DD	01H
	DD	FLAT:$T50550
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xtree
xdata$x	ENDS
;	COMDAT ?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
_TEXT	SEGMENT
__Wherenode$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Larg$ = 8						; size = 4
__Parg$ = 12						; size = 4
__Rarg$ = 16						; size = 4
__Val$ = 20						; size = 4
__Carg$ = 24						; size = 1
?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode, COMDAT

; 1130 : 		{	// allocate a node with pointers, value, and color

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 1131 : 		_Nodeptr _Wherenode = this->_Alnod.allocate(1);

	push	48					; 00000030H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR __Wherenode$[ebp], esi

; 1132 : 		_TRY_BEGIN
; 1133 : 		new (_Wherenode) _Node(_Larg, _Parg, _Rarg, _Val, _Carg);

	test	esi, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	je	SHORT $L50526
	mov	eax, DWORD PTR __Carg$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR __Larg$[ebp]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	edx
	mov	edx, DWORD PTR __Rarg$[ebp]
	call	??0_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@PAU012@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ; std::_Tree_nod<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Node::_Node
$L50526:

; 1137 : 		_CATCH_END
; 1138 : 		return (_Wherenode);
; 1139 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L50529:

; 1134 : 		_CATCH_ALL
; 1135 : 		this->_Alnod.deallocate(_Wherenode, 1);

	mov	eax, DWORD PTR __Wherenode$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 1136 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L50552:
$L50548:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L50530:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z:
	mov	eax, OFFSET FLAT:$T50546
	jmp	___CxxFrameHandler
text$x	ENDS
?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
;	COMDAT xdata$x
xdata$x	SEGMENT
$T50587	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T50589	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L50558
$T50588	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T50589
$T50584	DD	019930520H
	DD	02H
	DD	FLAT:$T50587
	DD	01H
	DD	FLAT:$T50588
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Newroot$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Rootnode$ = 8						; size = 4
__Wherenode$ = 12					; size = 4
?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy, COMDAT
; _this$ = ecx

; 867  : 		{	// copy entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH
	push	ebx
	mov	ebx, ecx

; 868  : 		_Nodeptr _Newroot = _Myhead;	// point at nil node

	mov	eax, DWORD PTR [ebx+4]
	push	esi
	push	edi

; 869  : 
; 870  : 		if (!_Isnil(_Rootnode))

	mov	edi, DWORD PTR __Rootnode$[ebp]
	mov	DWORD PTR __Newroot$[ebp], eax
	mov	al, BYTE PTR [edi+41]
	test	al, al
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ebx
	jne	SHORT $L14843

; 871  : 			{	// copy a node, then any subtrees
; 872  : 			_Nodeptr _Pnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 873  : 				_Myval(_Rootnode), _Color(_Rootnode));

	mov	eax, DWORD PTR [ebx+4]
	xor	ecx, ecx
	mov	cl, BYTE PTR [edi+40]
	lea	edx, DWORD PTR [edi+16]
	push	ecx
	mov	ecx, DWORD PTR __Wherenode$[ebp]
	push	edx
	push	eax
	push	ecx
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode

; 874  : 			if (_Isnil(_Newroot))

	mov	edx, DWORD PTR __Newroot$[ebp]
	mov	esi, eax
	mov	al, BYTE PTR [edx+41]
	test	al, al
	je	SHORT $L14842

; 875  : 				_Newroot = _Pnode;	// memorize new root

	mov	DWORD PTR __Newroot$[ebp], esi
$L14842:

; 876  : 
; 877  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 878  : 			_Left(_Pnode) = _Copy(_Left(_Rootnode), _Pnode);

	mov	eax, DWORD PTR [edi]
	push	esi
	push	eax
	mov	ecx, ebx
	call	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
	mov	DWORD PTR [esi], eax

; 879  : 			_Right(_Pnode) = _Copy(_Right(_Rootnode), _Pnode);

	mov	ecx, DWORD PTR [edi+8]
	push	esi
	push	ecx
	mov	ecx, ebx
	call	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
	mov	DWORD PTR [esi+8], eax
$L14843:

; 883  : 			_CATCH_END
; 884  : 			}
; 885  : 
; 886  : 		return (_Newroot);	// return newly constructed tree
; 887  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	eax, DWORD PTR __Newroot$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$L50558:

; 880  : 			_CATCH_ALL
; 881  : 			_Erase(_Newroot);	// subtree copy failed, bail out

	mov	edx, DWORD PTR __Newroot$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	push	edx
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase

; 882  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L50590:
$L50586:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z:
	mov	eax, OFFSET FLAT:$T50584
	jmp	___CxxFrameHandler
text$x	ENDS
?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
;	COMDAT xdata$x
xdata$x	SEGMENT
$T51607	DD	0ffffffffH
	DD	FLAT:$L50597
	DD	00H
	DD	FLAT:$L50722
$T51600	DD	019930520H
	DD	02H
	DD	FLAT:$T51607
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT
$T50596 = -80						; size = 28
$T50595 = -52						; size = 40
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Newnode$ = 16						; size = 4
__Val$ = 16						; size = 4
?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert, COMDAT
; _this$ = ebx
; __Wherenode$ = ecx

; 911  : 		{	// add node with value next to _Wherenode, to left if _Addnode

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp

; 912  : 		if (max_size() - 1 <= _Mysize)

	mov	eax, DWORD PTR [ebx+8]
	sub	esp, 68					; 00000044H
	cmp	eax, 178956969				; 0aaaaaa9H
	push	esi
	push	edi
	mov	esi, ecx
	jb	SHORT $L14393

; 913  : 			_THROW(length_error, "map/set<T> too long");

	push	19					; 00000013H
	mov	esi, 15					; 0000000fH
	xor	edi, edi
	push	OFFSET FLAT:??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T50596[esp+96]
	mov	DWORD PTR $T50596[esp+120], esi
	mov	DWORD PTR $T50596[esp+116], edi
	mov	BYTE PTR $T50596[esp+100], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T50595[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], edi
	call	??0exception@@QAE@XZ			; exception::exception
	push	-1
	mov	BYTE PTR __$EHRec$[esp+100], 1
	push	edi
	lea	eax, DWORD PTR $T50596[esp+96]
	push	eax
	lea	ecx, DWORD PTR $T50595[esp+112]
	mov	DWORD PTR $T50595[esp+100], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	DWORD PTR $T50595[esp+136], esi
	mov	DWORD PTR $T50595[esp+132], edi
	mov	BYTE PTR $T50595[esp+116], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T50595[esp+92]
	mov	BYTE PTR __$EHRec$[esp+100], 0
	push	ecx
	mov	DWORD PTR $T50595[esp+96], OFFSET FLAT:??_7length_error@std@@6B@
	call	__CxxThrowException@8
$L51608:
$L14393:

; 914  : 		_Nodeptr _Newnode = _Buynode(_Myhead, _Wherenode, _Myhead,
; 915  : 			_Val, _Red);

	mov	edx, DWORD PTR __Val$[esp+84]
	mov	eax, DWORD PTR [ebx+4]
	push	0
	push	edx
	push	eax
	push	esi
	push	eax
	call	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@00ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@D@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode

; 916  : 
; 917  : 		++_Mysize;

	inc	DWORD PTR [ebx+8]

; 918  : 		if (_Wherenode == _Myhead)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	esi, ecx
	mov	edx, eax
	mov	DWORD PTR __Newnode$[esp+84], edx
	jne	SHORT $L14408

; 919  : 			{	// first node in tree, just set head values
; 920  : 			_Root() = _Newnode;

	mov	DWORD PTR [ecx+4], edx

; 921  : 			_Lmost() = _Newnode, _Rmost() = _Newnode;

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [eax], edx
	mov	ecx, DWORD PTR [ebx+4]

; 922  : 			}
; 923  : 		else if (_Addleft)

	jmp	SHORT $L51604
$L14408:
	mov	al, BYTE PTR __Addleft$[esp+84]
	test	al, al
	je	SHORT $L14410

; 924  : 			{	// add to left of _Wherenode
; 925  : 			_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi], edx

; 926  : 			if (_Wherenode == _Lmost())

	mov	ecx, DWORD PTR [ebx+4]
	cmp	esi, DWORD PTR [ecx]
	jne	SHORT $L14413

; 927  : 				_Lmost() = _Newnode;

	mov	DWORD PTR [ecx], edx

; 928  : 			}
; 929  : 		else

	jmp	SHORT $L14413
$L14410:

; 930  : 			{	// add to right of _Wherenode
; 931  : 			_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [esi+8], edx

; 932  : 			if (_Wherenode == _Rmost())

	mov	ecx, DWORD PTR [ebx+4]
	cmp	esi, DWORD PTR [ecx+8]
	jne	SHORT $L14413
$L51604:

; 933  : 				_Rmost() = _Newnode;

	mov	DWORD PTR [ecx+8], edx
$L14413:

; 934  : 			}
; 935  : 
; 936  : 		for (_Nodeptr _Pnode = _Newnode; _Color(_Parent(_Pnode)) == _Red; )

	mov	esi, DWORD PTR [edx+4]
	cmp	BYTE PTR [esi+40], 0
	lea	ecx, DWORD PTR [edx+4]
	mov	al, 1
	jne	$L14417
	push	ebp
$L14416:

; 937  : 			if (_Parent(_Pnode) == _Left(_Parent(_Parent(_Pnode))))

	mov	esi, DWORD PTR [ecx]
	mov	ebp, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [ebp]
	cmp	esi, edi
	jne	$L14418

; 938  : 				{	// fixup red-red in left subtree
; 939  : 				_Wherenode = _Right(_Parent(_Parent(_Pnode)));

	mov	edi, DWORD PTR [ebp+8]

; 940  : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edi+40], 0
	jne	SHORT $L14419
$L51606:

; 941  : 					{	// parent has two red children, blacken both
; 942  : 					_Color(_Parent(_Pnode)) = _Black;

	mov	edx, DWORD PTR [ecx]
	mov	BYTE PTR [edx+40], al

; 943  : 					_Color(_Wherenode) = _Black;

	mov	BYTE PTR [edi+40], al

; 944  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	edx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [edx+4]
	mov	BYTE PTR [edx+40], 0

; 945  : 					_Pnode = _Parent(_Parent(_Pnode));

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+4]

; 946  : 					}
; 947  : 				else

	jmp	$L51572
$L14419:

; 948  : 					{	// parent has red and black children
; 949  : 					if (_Pnode == _Right(_Parent(_Pnode)))

	cmp	edx, DWORD PTR [esi+8]
	jne	SHORT $L51081

; 950  : 						{	// rotate right child to left
; 951  : 						_Pnode = _Parent(_Pnode);

	mov	edx, esi

; 952  : 						_Lrotate(_Pnode);

	mov	esi, DWORD PTR [edx+8]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], ecx
	mov	ecx, DWORD PTR [esi]
	cmp	BYTE PTR [ecx+41], 0
	jne	SHORT $L51083
	mov	DWORD PTR [ecx+4], edx
$L51083:
	mov	edi, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], edi
	mov	edi, DWORD PTR [ebx+4]
	cmp	edx, DWORD PTR [edi+4]
	jne	SHORT $L51084
	mov	DWORD PTR [edi+4], esi
	jmp	SHORT $L51087
$L51084:
	mov	edi, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [edi]
	jne	SHORT $L51086
	mov	DWORD PTR [edi], esi
	jmp	SHORT $L51087
$L51086:
	mov	DWORD PTR [edi+8], esi
$L51087:
	mov	DWORD PTR [esi], edx
	mov	DWORD PTR [ecx], esi
$L51081:

; 953  : 						}
; 954  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	esi, DWORD PTR [ecx]
	mov	BYTE PTR [esi+40], al

; 955  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	esi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [esi+4]
	mov	BYTE PTR [esi+40], 0

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx]
	mov	edi, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], edi
	mov	edi, DWORD PTR [esi+8]
	cmp	BYTE PTR [edi+41], 0
	jne	SHORT $L51237
	mov	DWORD PTR [edi+4], ecx
$L51237:
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edi
	mov	edi, DWORD PTR [ebx+4]
	cmp	ecx, DWORD PTR [edi+4]
	jne	SHORT $L51238
	mov	DWORD PTR [edi+4], esi
	mov	DWORD PTR [esi+8], ecx

; 957  : 					}
; 958  : 				}
; 959  : 			else

	jmp	$L51605

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

$L51238:
	mov	edi, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edi+8]
	jne	SHORT $L51240
	mov	DWORD PTR [edi+8], esi
	mov	DWORD PTR [esi+8], ecx

; 957  : 					}
; 958  : 				}
; 959  : 			else

	jmp	$L51605

; 956  : 					_Rrotate(_Parent(_Parent(_Pnode)));

$L51240:
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [esi+8], ecx

; 957  : 					}
; 958  : 				}
; 959  : 			else

	jmp	$L51605
$L14418:

; 960  : 				{	// fixup red-red in right subtree
; 961  : 				_Wherenode = _Left(_Parent(_Parent(_Pnode)));
; 962  : 				if (_Color(_Wherenode) == _Red)

	cmp	BYTE PTR [edi+40], 0

; 963  : 					{	// parent has two red children, blacken both
; 964  : 					_Color(_Parent(_Pnode)) = _Black;
; 965  : 					_Color(_Wherenode) = _Black;
; 966  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;
; 967  : 					_Pnode = _Parent(_Parent(_Pnode));
; 968  : 					}
; 969  : 				else

	je	$L51606

; 970  : 					{	// parent has red and black children
; 971  : 					if (_Pnode == _Left(_Parent(_Pnode)))

	cmp	edx, DWORD PTR [esi]
	jne	SHORT $L51431

; 972  : 						{	// rotate left child to right
; 973  : 						_Pnode = _Parent(_Pnode);

	mov	edx, esi

; 974  : 						_Rrotate(_Pnode);

	mov	esi, DWORD PTR [edx]
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [esi+8]
	cmp	BYTE PTR [ecx+41], 0
	jne	SHORT $L51433
	mov	DWORD PTR [ecx+4], edx
$L51433:
	mov	edi, DWORD PTR [edx+4]
	lea	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], edi
	mov	edi, DWORD PTR [ebx+4]
	cmp	edx, DWORD PTR [edi+4]
	jne	SHORT $L51434
	mov	DWORD PTR [edi+4], esi
	jmp	SHORT $L51437
$L51434:
	mov	edi, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [edi+8]
	jne	SHORT $L51436
	mov	DWORD PTR [edi+8], esi
	jmp	SHORT $L51437
$L51436:
	mov	DWORD PTR [edi], esi
$L51437:
	mov	DWORD PTR [esi+8], edx
	mov	DWORD PTR [ecx], esi
$L51431:

; 975  : 						}
; 976  : 					_Color(_Parent(_Pnode)) = _Black;	// propagate red up

	mov	esi, DWORD PTR [ecx]
	mov	BYTE PTR [esi+40], al

; 977  : 					_Color(_Parent(_Parent(_Pnode))) = _Red;

	mov	esi, DWORD PTR [ecx]
	mov	esi, DWORD PTR [esi+4]
	mov	BYTE PTR [esi+40], 0

; 978  : 					_Lrotate(_Parent(_Parent(_Pnode)));

	mov	ecx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	esi, DWORD PTR [ecx+8]
	mov	edi, DWORD PTR [esi]
	mov	DWORD PTR [ecx+8], edi
	mov	edi, DWORD PTR [esi]
	cmp	BYTE PTR [edi+41], 0
	jne	SHORT $L51574
	mov	DWORD PTR [edi+4], ecx
$L51574:
	mov	edi, DWORD PTR [ecx+4]
	mov	DWORD PTR [esi+4], edi
	mov	edi, DWORD PTR [ebx+4]
	cmp	ecx, DWORD PTR [edi+4]
	jne	SHORT $L51575
	mov	DWORD PTR [edi+4], esi
	jmp	SHORT $L51578
$L51575:
	mov	edi, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [edi]
	jne	SHORT $L51577
	mov	DWORD PTR [edi], esi
	jmp	SHORT $L51578
$L51577:
	mov	DWORD PTR [edi+8], esi
$L51578:
	mov	DWORD PTR [esi], ecx
$L51605:
	mov	DWORD PTR [ecx+4], esi
$L51572:
	mov	esi, DWORD PTR [edx+4]
	cmp	BYTE PTR [esi+40], 0
	lea	ecx, DWORD PTR [edx+4]
	je	$L14416
	mov	edx, DWORD PTR __Newnode$[esp+88]
	pop	ebp
$L14417:

; 979  : 					}
; 980  : 				}
; 981  : 
; 982  : 		_Color(_Root()) = _Black;	// root is always black

	mov	ecx, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	BYTE PTR [ecx+40], al

; 983  : 		return (_TREE_ITERATOR(_Newnode));

	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+84]
	mov	DWORD PTR [ecx], edx
	mov	eax, ecx

; 984  : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 80					; 00000050H
	ret	12					; 0000000cH
$L51603:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L50597:
	lea	ecx, DWORD PTR $T50596[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L50722:
	lea	ecx, DWORD PTR $T50595[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z:
	mov	eax, OFFSET FLAT:$T51600
	jmp	___CxxFrameHandler
text$x	ENDS
?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
; Function compile flags: /Ogtpy
;	COMDAT ?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z
_TEXT	SEGMENT
?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy, COMDAT
; _this$ = ecx
; __Right$ = eax

; 854  : 		{	// copy entire tree from _Right

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 855  : 		_Root() = _Copy(_Right._Root(), _Myhead);

	mov	edi, DWORD PTR [esi+4]
	mov	ebx, eax
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [eax+4]
	push	edi
	push	ecx
	mov	ecx, esi
	call	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@PAU342@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
	mov	DWORD PTR [edi+4], eax

; 856  : 		_Mysize = _Right.size();

	mov	edx, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+8], edx

; 857  : 		if (!_Isnil(_Root()))

	mov	edx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edx+4]
	mov	cl, BYTE PTR [eax+41]
	test	cl, cl
	jne	SHORT $L14380

; 858  : 			{	// nonempty tree, look for new smallest and largest
; 859  : 			_Lmost() = _Min(_Root());

	mov	ecx, DWORD PTR [eax]
	mov	bl, BYTE PTR [ecx+41]
	test	bl, bl
	jne	SHORT $L51673
$L51672:
	mov	eax, ecx
	mov	ecx, DWORD PTR [eax]
	mov	bl, BYTE PTR [ecx+41]
	test	bl, bl
	je	SHORT $L51672
$L51673:
	mov	DWORD PTR [edx], eax

; 860  : 			_Rmost() = _Max(_Root());

	mov	esi, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [ecx+8]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	jne	SHORT $L51711
$L51710:
	mov	ecx, eax
	mov	eax, DWORD PTR [ecx+8]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl
	je	SHORT $L51710
$L51711:
	pop	edi
	mov	DWORD PTR [esi+8], ecx
	pop	esi
	pop	ebx

; 864  : 		}

	ret	0
$L14380:

; 861  : 			}
; 862  : 		else
; 863  : 			_Lmost() = _Myhead, _Rmost() = _Myhead;	// empty tree

	mov	DWORD PTR [edx], edx
	mov	esi, DWORD PTR [esi+4]
	pop	edi
	mov	DWORD PTR [esi+8], esi
	pop	esi
	pop	ebx

; 864  : 		}

	ret	0
?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT
__Addleft$ = -4						; size = 1
_this$ = 8						; size = 4
tv236 = 12						; size = 4
__Where$14342 = 12					; size = 4
___$ReturnUdt$ = 12					; size = 4
$T51753 = 16						; size = 4
$T51751 = 16						; size = 4
__Val$ = 16						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert, COMDAT

; 477  : 		{	// try to insert node with value _Val

	push	ecx

; 478  : 		_Nodeptr _Trynode = _Root();

	mov	edx, DWORD PTR _this$[esp]
	mov	eax, DWORD PTR [edx+4]
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR ___$ReturnUdt$[esp+8]
	push	esi
	push	edi
	mov	edi, DWORD PTR [eax+4]

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

	mov	cl, BYTE PTR [edi+41]
	test	cl, cl
	mov	ebx, eax
	mov	al, 1
	mov	BYTE PTR __Addleft$[esp+20], al
	jne	SHORT $L51891

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));

	mov	eax, DWORD PTR __Val$[esp+16]
	mov	ecx, DWORD PTR [eax]

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	DWORD PTR tv236[esp+16], ecx
	npad	4
$L14331:
	test	ecx, ecx
	mov	ebx, edi
	je	SHORT $L51792
	mov	esi, DWORD PTR [edi+16]
	mov	eax, ecx
	npad	5
$L51887:
	mov	dl, BYTE PTR [eax]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi]
	jne	SHORT $L51888

; 482  : 			{	// look for leaf to insert before (_Addleft) or after
; 483  : 			_Wherenode = _Trynode;
; 484  : 			_Addleft = this->comp(this->_Kfn(_Val), _Key(_Trynode));

	test	cl, cl
	je	SHORT $L51889
	mov	dl, BYTE PTR [eax+1]
	mov	cl, dl
	cmp	dl, BYTE PTR [esi+1]
	jne	SHORT $L51888
	add	eax, 2
	add	esi, 2
	test	cl, cl
	jne	SHORT $L51887
$L51889:
	mov	ecx, DWORD PTR tv236[esp+16]
	xor	eax, eax
	test	eax, eax
	jmp	SHORT $L51893
$L51888:
	mov	ecx, DWORD PTR tv236[esp+16]
	sbb	eax, eax
	sbb	eax, -1
	test	eax, eax
	jmp	SHORT $L51893
$L51792:
	mov	eax, DWORD PTR __Val$[esp+16]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [edi+20]
$L51893:
	setl	al

; 485  : 			_Trynode = _Addleft ? _Left(_Trynode) : _Right(_Trynode);

	test	al, al
	mov	BYTE PTR __Addleft$[esp+20], al
	je	SHORT $L51745
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $L51746
$L51745:
	mov	edi, DWORD PTR [edi+8]
$L51746:

; 479  : 		_Nodeptr _Wherenode = _Myhead;
; 480  : 		bool _Addleft = true;	// add to left of head if tree empty
; 481  : 		while (!_Isnil(_Trynode))

	mov	dl, BYTE PTR [edi+41]
	test	dl, dl
	je	SHORT $L14331
	mov	edx, DWORD PTR _this$[esp+16]
$L51891:

; 486  : 			}
; 487  : 
; 488  : 		if (this->_Multi)
; 489  : 			return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));
; 490  : 		else
; 491  : 			{	// insert only if unique
; 492  : 			iterator _Where = _TREE_ITERATOR(_Wherenode);
; 493  : 			if (!_Addleft)

	test	al, al
	mov	esi, ebx
	mov	DWORD PTR __Where$14342[esp+16], esi
	je	SHORT $L51854

; 494  : 				;	// need to test if insert after is okay
; 495  : 			else if (_Where == begin())

	mov	eax, DWORD PTR [edx+4]
	cmp	ebx, DWORD PTR [eax]
	jne	SHORT $L14347

; 496  : 				return (_Pairib(_Insert(true, _Wherenode, _Val), true));

	mov	ecx, DWORD PTR __Val$[esp+16]
	push	ecx
	push	1
	lea	eax, DWORD PTR $T51751[esp+24]
	mov	ecx, ebx
	push	eax
	mov	ebx, edx
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	ecx, DWORD PTR [eax]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], ecx
	mov	BYTE PTR [ebp+4], 1

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 504  : 			}
; 505  : 		}

	pop	ecx
	ret	12					; 0000000cH
$L14347:

; 497  : 			else
; 498  : 				--_Where;	// need to test if insert before is okay

	lea	edx, DWORD PTR __Where$14342[esp+16]
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec
	mov	esi, DWORD PTR __Where$14342[esp+16]
$L51854:

; 499  : 
; 500  : 			if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))

	mov	ecx, DWORD PTR __Val$[esp+16]
	lea	edx, DWORD PTR [esi+16]
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	je	SHORT $L14352

; 501  : 				return (_Pairib(_Insert(_Addleft, _Wherenode, _Val), true));

	mov	edx, DWORD PTR __Val$[esp+16]
	mov	eax, DWORD PTR __Addleft$[esp+20]
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T51753[esp+24]
	push	ecx
	mov	ecx, ebx
	mov	ebx, DWORD PTR _this$[esp+28]
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	mov	edx, DWORD PTR [eax]
	pop	edi
	pop	esi
	mov	DWORD PTR [ebp], edx
	mov	BYTE PTR [ebp+4], 1

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 504  : 			}
; 505  : 		}

	pop	ecx
	ret	12					; 0000000cH
$L14352:
	pop	edi

; 502  : 			else
; 503  : 				return (_Pairib(_Where, false));

	mov	DWORD PTR [ebp], esi
	pop	esi
	mov	BYTE PTR [ebp+4], 0
	mov	eax, ebp
	pop	ebp
	pop	ebx

; 504  : 			}
; 505  : 		}

	pop	ecx
	ret	12					; 0000000cH
?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z
_TEXT	SEGMENT
$T51904 = -8						; size = 8
__Next$ = 8						; size = 4
__Where$ = 8						; size = 4
?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert, COMDAT
; _this$ = eax
; ___$ReturnUdt$ = esi
; __Val$ = edi

; 509  : 		{	// try to insert node with value _Val using _Where as a hint

	sub	esp, 8
	push	ebx
	mov	ebx, eax

; 510  : 		iterator _Next;
; 511  : 
; 512  : 		if (size() == 0)

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	jne	SHORT $L13670

; 513  : 			return (_Insert(true, _Myhead, _Val));	// insert into empty tree

	mov	ecx, DWORD PTR [ebx+4]
	push	edi
	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, esi
	pop	ebx

; 580  : 		}

	add	esp, 8
	ret	4
$L13670:

; 514  : 		else if (this->_Multi)
; 515  : 			{	// insert even if duplicate
; 516  : 			if (_Where == begin())
; 517  : 				{	// insert at beginning if before first element
; 518  : 				if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val)))
; 519  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 520  : 				}
; 521  : 			else if (_Where == end())
; 522  : 				{	// insert at end if after last element
; 523  : 				if (!this->comp(this->_Kfn(_Val), _Key(_Rmost())))
; 524  : 					return (_Insert(false, _Rmost(), _Val));
; 525  : 				}
; 526  : 			else if (!this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 527  : 				&& !this->comp(this->_Kfn(_Val),
; 528  : 					_Key((--(_Next = _Where))._Mynode())))
; 529  : 				{	// insert before _Where
; 530  : 				if (_Isnil(_Right(_Next._Mynode())))
; 531  : 					return (_Insert(false, _Next._Mynode(), _Val));
; 532  : 				else
; 533  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 534  : 				}
; 535  : 			else if (!this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 536  : 				&& (++(_Next = _Where) == end()
; 537  : 					|| !this->comp(_Key(_Next._Mynode()),
; 538  : 						this->_Kfn(_Val))))
; 539  : 				{	// insert after _Where
; 540  : 				if (_Isnil(_Right(_Where._Mynode())))
; 541  : 					return (_Insert(false, _Where._Mynode(), _Val));
; 542  : 				else
; 543  : 					return (_Insert(true, _Next._Mynode(), _Val));
; 544  : 				}
; 545  : 			}
; 546  : 		else
; 547  : 			{	// insert only if unique
; 548  : 			if (_Where == begin())

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [eax]
	push	ebp
	mov	ebp, DWORD PTR __Where$[esp+12]
	cmp	ebp, ecx
	jne	SHORT $L13699

; 549  : 				{	// insert at beginning if before first element
; 550  : 				if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode())))

	lea	ecx, DWORD PTR [ebp+16]
	mov	edx, edi
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	je	$L13719

; 551  : 					return (_Insert(true, _Where._Mynode(), _Val));

	push	edi
$L13709:
	push	1
	push	esi
	mov	ecx, ebp
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	pop	ebp

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, esi
	pop	ebx

; 580  : 		}

	add	esp, 8
	ret	4
$L13699:

; 552  : 				}
; 553  : 			else if (_Where == end())

	cmp	ebp, eax
	jne	SHORT $L13704

; 554  : 				{	// insert at end if after last element
; 555  : 				if (this->comp(_Key(_Rmost()), this->_Kfn(_Val)))

	mov	ebp, DWORD PTR [eax+8]
	lea	edx, DWORD PTR [ebp+16]
	mov	ecx, edi
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	je	$L13719

; 556  : 					return (_Insert(false, _Rmost(), _Val));

	push	edi
$L52447:
	push	0
	push	esi
	mov	ecx, ebp
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	pop	ebp

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, esi
	pop	ebx

; 580  : 		}

	add	esp, 8
	ret	4
$L13704:

; 557  : 				}
; 558  : 			else if (this->comp(this->_Kfn(_Val), _Key(_Where._Mynode()))
; 559  : 				&& this->comp(_Key((--(_Next = _Where))._Mynode()),
; 560  : 					this->_Kfn(_Val)))

	lea	ecx, DWORD PTR [ebp+16]
	mov	edx, edi
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	je	SHORT $L13708
	lea	edx, DWORD PTR __Next$[esp+12]
	mov	DWORD PTR __Next$[esp+12], ebp
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec
	mov	edx, DWORD PTR __Next$[esp+12]
	add	edx, 16					; 00000010H
	mov	ecx, edi
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	je	SHORT $L13708

; 561  : 				{	// insert before _Where
; 562  : 				if (_Isnil(_Right(_Next._Mynode())))

	mov	ecx, DWORD PTR __Next$[esp+12]
	mov	eax, DWORD PTR [ecx+8]
	mov	dl, BYTE PTR [eax+41]
	test	dl, dl

; 563  : 					return (_Insert(false, _Next._Mynode(), _Val));

	push	edi
	je	SHORT $L13709
	push	0
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	pop	ebp

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, esi
	pop	ebx

; 580  : 		}

	add	esp, 8
	ret	4
$L13708:

; 564  : 				else
; 565  : 					return (_Insert(true, _Where._Mynode(), _Val));
; 566  : 				}
; 567  : 			else if (this->comp(_Key(_Where._Mynode()), this->_Kfn(_Val))
; 568  : 				&& (++(_Next = _Where) == end()
; 569  : 					|| this->comp(this->_Kfn(_Val),
; 570  : 						_Key(_Next._Mynode()))))

	mov	ecx, edi
	lea	edx, DWORD PTR [ebp+16]
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	je	SHORT $L13719
	lea	edx, DWORD PTR __Next$[esp+12]
	mov	DWORD PTR __Next$[esp+12], ebp
	call	?_Inc@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Inc
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR __Next$[esp+12]
	cmp	ecx, eax
	je	SHORT $L13716
	add	ecx, 16					; 00000010H
	mov	edx, edi
	call	??MCZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator<
	test	al, al
	je	SHORT $L13719
	mov	ecx, DWORD PTR __Next$[esp+12]
$L13716:

; 571  : 				{	// insert after _Where
; 572  : 				if (_Isnil(_Right(_Where._Mynode())))

	mov	edx, DWORD PTR [ebp+8]
	mov	al, BYTE PTR [edx+41]
	test	al, al

; 573  : 					return (_Insert(false, _Where._Mynode(), _Val));

	push	edi
	jne	$L52447

; 574  : 				else
; 575  : 					return (_Insert(true, _Next._Mynode(), _Val));

	push	1
	push	esi
	call	?_Insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAE?AViterator@12@_NPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Insert
	pop	ebp

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

	mov	eax, esi
	pop	ebx

; 580  : 		}

	add	esp, 8
	ret	4
$L13719:

; 576  : 				}
; 577  : 			}
; 578  : 
; 579  : 		return (insert(_Val).first);	// try usual insert if all else fails

	push	edi
	lea	eax, DWORD PTR $T51904[esp+20]
	push	eax
	push	ebx
	call	?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AU?$pair@Viterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@_N@2@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
	mov	ecx, DWORD PTR [eax]
	pop	ebp
	mov	DWORD PTR [esi], ecx
	mov	eax, esi
	pop	ebx

; 580  : 		}

	add	esp, 8
	ret	4
?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T52581	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
$T52583	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L52455
$T52582	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:$T52583
$T52578	DD	019930520H
	DD	02H
	DD	FLAT:$T52581
	DD	01H
	DD	FLAT:$T52582
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -16						; size = 16
_this$ = 8						; size = 4
__Right$ = 12						; size = 4
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z PROC NEAR ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >, COMDAT

; 380  : 		{	// construct tree by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, DWORD PTR _this$[ebp]
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp

; 381  : 		_Init();

	call	?_Buynode@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@XZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buynode
	mov	DWORD PTR [esi+4], eax
	mov	BYTE PTR [eax+41], 1
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+8], eax

; 382  : 		_TRY_BEGIN
; 383  : 		_Copy(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, esi
	mov	DWORD PTR [esi+8], 0
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	?_Copy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXABV12@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Copy

; 387  : 		_CATCH_END
; 388  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$L52455:

; 384  : 		_CATCH_ALL
; 385  : 		_Tidy();

	mov	eax, DWORD PTR _this$[ebp]
	call	?_Tidy@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tidy

; 386  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L52584:
$L52580:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET FLAT:$T52578
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
; Function compile flags: /Ogtpy
;	COMDAT ??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z PROC NEAR ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >, COMDAT
; _this$ = esi
; ___that$ = eax
	push	eax
	push	esi
	call	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	mov	eax, esi
	ret	0
??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@ABV01@@Z ENDP ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
_TEXT	ENDS
;	COMDAT xdata$x
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
xdata$x	SEGMENT
$T52677	DD	0ffffffffH
	DD	FLAT:$L52601
	DD	0ffffffffH
	DD	FLAT:$L52602
$T52669	DD	019930520H
	DD	02H
	DD	FLAT:$T52677
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0Value@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
$T52598 = -16						; size = 4
$T52594 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_other$ = 8						; size = 4
??0Value@Json@@QAE@ABV01@@Z PROC NEAR			; Json::Value::Value, COMDAT
; _this$ = ecx

; 403  : {

	push	-1
	push	__ehhandler$??0Value@Json@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _other$[esp+20]
	mov	al, BYTE PTR [ebp+8]
	push	esi
	push	edi
	mov	edi, ecx
	mov	BYTE PTR [edi+8], al

; 404  :    switch ( type_ )

	movsx	eax, al
	xor	ebx, ebx
	cmp	eax, 7
	mov	DWORD PTR [edi+12], ebx
	ja	SHORT $L52673
	jmp	DWORD PTR $L52676[eax*4]
$L12039:

; 405  :    {
; 406  :    case nullValue:
; 407  :    case intValue:
; 408  :    case uintValue:
; 409  :    case realValue:
; 410  :    case booleanValue:
; 411  :       value_ = other.value_;

	mov	ecx, DWORD PTR [ebp]
	mov	DWORD PTR [edi], ecx
	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR [edi+4], edx

; 412  :       break;

	jmp	SHORT $L52673
$L12040:

; 413  :    case stringValue:
; 414  :       if ( other.value_.string_ )

	cmp	DWORD PTR [ebp], ebx
	je	SHORT $L12041

; 415  :       {
; 416  :          value_.string_ = valueAllocator()->duplicateStringValue( other.value_.string_ );

	call	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ecx]
	push	-1
	push	edx
	call	DWORD PTR [eax+12]
	mov	DWORD PTR [edi], eax

; 417  :          allocated_ = true;

	or	DWORD PTR [edi+8], 256			; 00000100H

; 418  :       }
; 419  :       else

	jmp	SHORT $L52673
$L12041:

; 420  :          value_.string_ = 0;

	mov	DWORD PTR [edi], ebx

; 421  :       break;

	jmp	SHORT $L52673
$L12043:

; 422  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 423  :    case arrayValue:
; 424  :    case objectValue:
; 425  :       value_.map_ = new ObjectValues( *other.value_.map_ );

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T52594[esp+32], esi
	cmp	esi, ebx
	mov	DWORD PTR __$EHRec$[esp+40], ebx
	je	SHORT $L52595
	mov	eax, DWORD PTR [ebp]
	push	eax
	push	esi
	call	??0?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE@ABV01@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >
	jmp	SHORT $L52596
$L52595:
	xor	esi, esi
$L52596:
	mov	DWORD PTR __$EHRec$[esp+40], -1
	mov	DWORD PTR [edi], esi
$L52673:

; 426  :       break;
; 427  : #else
; 428  :    case arrayValue:
; 429  :       value_.array_ = arrayAllocator()->newArrayCopy( *other.value_.array_ );
; 430  :       break;
; 431  :    case objectValue:
; 432  :       value_.map_ = mapAllocator()->newMapCopy( *other.value_.map_ );
; 433  :       break;
; 434  : #endif
; 435  :    default:
; 436  :       JSON_ASSERT_UNREACHABLE;
; 437  :    }
; 438  :    if ( other.comments_ )

	cmp	DWORD PTR [ebp+12], ebx
	je	$L52672

; 439  :    {
; 440  :       comments_ = new CommentInfo[numberOfCommentPlacement];

	push	16					; 00000010H
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T52598[esp+32], eax
	cmp	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+40], 1
	je	SHORT $L52599
	push	OFFSET FLAT:??1CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::~CommentInfo
	push	OFFSET FLAT:??0CommentInfo@Value@Json@@QAE@XZ ; Json::Value::CommentInfo::CommentInfo
	push	3
	lea	esi, DWORD PTR [eax+4]
	push	4
	push	esi
	mov	DWORD PTR [eax], 3
	call	??_L@YGXPAXIHP6EX0@Z1@Z
	mov	DWORD PTR __$EHRec$[esp+40], -1
	mov	DWORD PTR [edi+12], esi
	jmp	SHORT $L12058
$L52599:
	xor	esi, esi
	mov	DWORD PTR __$EHRec$[esp+40], -1
	mov	DWORD PTR [edi+12], esi
	jmp	SHORT $L12058
$L52674:
	mov	ebp, DWORD PTR _other$[esp+28]
	npad	3
$L12058:

; 441  :       for ( int comment =0; comment < numberOfCommentPlacement; ++comment )
; 442  :       {
; 443  :          const CommentInfo &otherComment = other.comments_[comment];

	mov	eax, DWORD PTR [ebp+12]

; 444  :          if ( otherComment.comment_ )

	mov	ebp, DWORD PTR [eax+ebx]
	add	eax, ebx
	test	ebp, ebp
	je	$L12059

; 445  :             comments_[comment].setComment( otherComment.comment_ );

	mov	esi, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [esi+ebx]
	add	esi, ebx
	test	eax, eax
	je	SHORT $L52665
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, 1
	jne	SHORT $L52653
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, 1
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L52653:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+16]
$L52665:
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, 1
	jne	SHORT $L52662
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, 1
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L52662:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	eax, DWORD PTR [ecx]
	push	-1
	push	ebp
	call	DWORD PTR [eax+12]
	mov	DWORD PTR [esi], eax
$L12059:
	add	ebx, 4
	cmp	ebx, 12					; 0000000cH
	jl	$L52674
$L52672:

; 446  :       }
; 447  :    }
; 448  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
	npad	1
$L52676:
	DD	$L12039
	DD	$L12039
	DD	$L12039
	DD	$L12039
	DD	$L12040
	DD	$L12039
	DD	$L12043
	DD	$L12043
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L52601:
	mov	eax, DWORD PTR $T52594[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L52602:
	mov	eax, DWORD PTR $T52598[ebp]
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
	ret	0
__ehhandler$??0Value@Json@@QAE@ABV01@@Z:
	mov	eax, OFFSET FLAT:$T52669
	jmp	___CxxFrameHandler
text$x	ENDS
??0Value@Json@@QAE@ABV01@@Z ENDP			; Json::Value::Value
;	COMDAT xdata$x
xdata$x	SEGMENT
$T52726	DD	0ffffffffH
	DD	FLAT:$L52683
$T52724	DD	019930520H
	DD	01H
	DD	FLAT:$T52726
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z PROC NEAR ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>, COMDAT
; ___that$ = ecx
	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	push	edi
	mov	edi, DWORD PTR _this$[esp+16]
	je	SHORT $L52709
	cmp	DWORD PTR [esi], 0
	je	SHORT $L52709
	mov	cl, BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	mov	eax, 1
	test	cl, al
	jne	SHORT $L52720
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, eax
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L52720:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+4]
	jmp	SHORT $L52710
$L52709:
	mov	eax, DWORD PTR [esi]
$L52710:
	mov	DWORD PTR [edi], eax
	cmp	DWORD PTR [esi], 0
	je	SHORT $L52711
	mov	ecx, DWORD PTR [esi+4]
	xor	eax, eax
	test	ecx, ecx
	setne	al
	jmp	SHORT $L52712
$L52711:
	mov	eax, DWORD PTR [esi+4]
$L52712:
	mov	DWORD PTR [edi+4], eax
	add	esi, 8
	push	esi
	lea	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, edi
	pop	edi
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L52683:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z:
	mov	eax, OFFSET FLAT:$T52724
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABU01@@Z ENDP ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
;	COMDAT xdata$x
xdata$x	SEGMENT
$T52775	DD	0ffffffffH
	DD	FLAT:$L52732
$T52773	DD	019930520H
	DD	01H
	DD	FLAT:$T52775
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\utility
xdata$x	ENDS
;	COMDAT ??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Val2$ = 12						; size = 4
??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z PROC NEAR ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>, COMDAT
; __Val1$ = ecx

; 34   : 		{	// construct from specified values

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	push	edi
	mov	edi, DWORD PTR _this$[esp+16]
	je	SHORT $L52758
	cmp	DWORD PTR [esi], 0
	je	SHORT $L52758
	mov	cl, BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	mov	eax, 1
	test	cl, al
	jne	SHORT $L52764
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, eax
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L52764:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+4]
	jmp	SHORT $L52759
$L52758:
	mov	eax, DWORD PTR [esi]
$L52759:
	mov	DWORD PTR [edi], eax
	cmp	DWORD PTR [esi], 0
	je	SHORT $L52760
	mov	ecx, DWORD PTR [esi+4]
	xor	eax, eax
	test	ecx, ecx
	setne	al
	mov	esi, eax
	jmp	SHORT $L52761
$L52760:
	mov	esi, DWORD PTR [esi+4]
$L52761:
	mov	DWORD PTR [edi+4], esi
	mov	ecx, DWORD PTR __Val2$[esp+16]
	push	ecx
	lea	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value

; 35   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, edi
	pop	edi
	mov	DWORD PTR fs:__except_list, ecx
	pop	esi
	add	esp, 12					; 0000000cH
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L52732:
	mov	esi, DWORD PTR _this$[ebp-4]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z:
	mov	eax, OFFSET FLAT:$T52773
	jmp	___CxxFrameHandler
text$x	ENDS
??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z ENDP ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
PUBLIC	?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z	; Json::Path::resolve
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_value.cpp
;	COMDAT ?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z
_TEXT	SEGMENT
_itLast$52912 = 8					; size = 4
$T52783 = 8						; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
_defaultValue$ = 16					; size = 4
?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z PROC NEAR	; Json::Path::resolve, COMDAT
; _root$ = eax

; 1583 : {

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+4]
	push	esi
	mov	DWORD PTR $T52783[esp+8], 0
	push	edi

; 1584 :    const Value *node = &root;
; 1585 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	mov	edi, DWORD PTR [ebp+4]
	mov	esi, eax
	cmp	edi, DWORD PTR [ebp+8]
	je	$L13179
	npad	2
$L52796:

; 1586 :    {
; 1587 :       const PathArgument &arg = *it;
; 1588 :       if ( arg.kind_ == PathArgument::kindIndex )

	mov	eax, DWORD PTR [edi+32]
	cmp	eax, 1
	jne	SHORT $L13181

; 1589 :       {
; 1590 :          if ( !node->isArray()  ||  node->isValidIndex( arg.index_ ) )

	mov	al, BYTE PTR [esi+8]
	test	al, al
	je	SHORT $L52822
	cmp	al, 6
	jne	$L52969
$L52822:
	mov	ebx, DWORD PTR [edi+28]
	movsx	eax, al
	cmp	eax, 7
	ja	SHORT $L52974
	jmp	DWORD PTR $L52980[eax*4]
$L52910:
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $L52974
	mov	eax, DWORD PTR [eax+4]
	lea	edx, DWORD PTR _itLast$52912[esp+12]
	mov	DWORD PTR _itLast$52912[esp+12], eax
	call	?_Dec@const_iterator@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::const_iterator::_Dec
	mov	ecx, DWORD PTR _itLast$52912[esp+12]
	mov	eax, DWORD PTR [ecx+20]
	inc	eax
	jmp	SHORT $L52906
$L52913:
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+8]
$L52906:
	cmp	ebx, eax
	jb	SHORT $L52969
$L52974:

; 1592 :          node = &((*node)[arg.index_]);

	push	ebx
	push	esi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	esi, eax

; 1593 :       }
; 1594 :       else if ( arg.kind_ == PathArgument::kindKey )

	jmp	SHORT $L13178
$L13181:
	cmp	eax, 2
	jne	SHORT $L13178

; 1595 :       {
; 1596 :          if ( !node->isObject() )

	mov	al, BYTE PTR [esi+8]
	test	al, al
	je	SHORT $L52943
	cmp	al, 7
	jne	SHORT $L52970
$L52943:

; 1598 :          node = &((*node)[arg.key_]);

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $L52966
	mov	eax, DWORD PTR [edi+4]
	jmp	SHORT $L52967
$L52966:

; 1584 :    const Value *node = &root;
; 1585 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	lea	eax, DWORD PTR [edi+4]

; 1598 :          node = &((*node)[arg.key_]);

$L52967:
	push	eax
	push	esi
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]
	mov	esi, eax

; 1599 :          if ( node == &Value::null )

	cmp	esi, OFFSET FLAT:?null@Value@Json@@2V12@B ; Json::Value::null
	je	SHORT $L52971
$L13178:

; 1584 :    const Value *node = &root;
; 1585 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	mov	eax, DWORD PTR [ebp+8]
	add	edi, 36					; 00000024H
	cmp	edi, eax
	jne	$L52796
$L13179:

; 1601 :       }
; 1602 :    }
; 1603 :    return *node;

	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[esp+16]
	mov	ecx, esi
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1604 : }

	ret	12					; 0000000cH
$L52969:

; 1591 :             return defaultValue;

	mov	eax, DWORD PTR _defaultValue$[esp+12]

; 1601 :       }
; 1602 :    }
; 1603 :    return *node;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	eax
	mov	ecx, esi
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1604 : }

	ret	12					; 0000000cH
$L52970:

; 1597 :             return defaultValue;

	mov	ecx, DWORD PTR _defaultValue$[esp+12]

; 1601 :       }
; 1602 :    }
; 1603 :    return *node;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	ecx
	mov	ecx, esi
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1604 : }

	ret	12					; 0000000cH
$L52971:

; 1600 :             return defaultValue;

	mov	edx, DWORD PTR _defaultValue$[esp+12]

; 1601 :       }
; 1602 :    }
; 1603 :    return *node;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+12]
	push	edx
	mov	ecx, esi
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx

; 1604 : }

	ret	12					; 0000000cH
	npad	3
$L52980:
	DD	$L52974
	DD	$L52974
	DD	$L52974
	DD	$L52974
	DD	$L52974
	DD	$L52974
	DD	$L52910
	DD	$L52913
?resolve@Path@Json@@QBE?AVValue@2@ABV32@0@Z ENDP	; Json::Path::resolve
_TEXT	ENDS
PUBLIC	?get@Value@Json@@QBE?AV12@PBDABV12@@Z		; Json::Value::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@Value@Json@@QBE?AV12@PBDABV12@@Z
_TEXT	SEGMENT
$T52988 = -4						; size = 4
_defaultValue$ = 8					; size = 4
?get@Value@Json@@QBE?AV12@PBDABV12@@Z PROC NEAR		; Json::Value::get, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; _key$ = eax

; 1084 : {

	push	ecx

; 1085 :    const Value *value = &((*this)[key]);

	push	eax
	push	ecx
	mov	DWORD PTR $T52988[esp+12], 0
	call	??AValue@Json@@QBEABV01@PBD@Z		; Json::Value::operator[]

; 1086 :    return value == &null ? defaultValue : *value;

	cmp	eax, OFFSET FLAT:?null@Value@Json@@2V12@B ; Json::Value::null
	jne	SHORT $L52986
	mov	eax, DWORD PTR _defaultValue$[esp]
$L52986:
	push	eax
	mov	ecx, esi
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	eax, esi

; 1087 : }

	pop	ecx
	ret	4
?get@Value@Json@@QBE?AV12@PBDABV12@@Z ENDP		; Json::Value::get
_TEXT	ENDS
PUBLIC	?get@Value@Json@@QBE?AV12@IABV12@@Z		; Json::Value::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@Value@Json@@QBE?AV12@IABV12@@Z
_TEXT	SEGMENT
$T52997 = -4						; size = 4
_defaultValue$ = 8					; size = 4
?get@Value@Json@@QBE?AV12@IABV12@@Z PROC NEAR		; Json::Value::get, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = esi
; _index$ = eax

; 1005 : {

	push	ecx

; 1006 :    const Value *value = &((*this)[index]);

	push	eax
	push	ecx
	mov	DWORD PTR $T52997[esp+12], 0
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]

; 1007 :    return value == &null ? defaultValue : *value;

	cmp	eax, OFFSET FLAT:?null@Value@Json@@2V12@B ; Json::Value::null
	jne	SHORT $L52995
	mov	eax, DWORD PTR _defaultValue$[esp]
$L52995:
	push	eax
	mov	ecx, esi
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value
	mov	eax, esi

; 1008 : }

	pop	ecx
	ret	4
?get@Value@Json@@QBE?AV12@IABV12@@Z ENDP		; Json::Value::get
_TEXT	ENDS
PUBLIC	??4Value@Json@@QAEAAV01@ABV01@@Z		; Json::Value::operator=
; Function compile flags: /Ogtpy
;	COMDAT ??4Value@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_temp$ = -16						; size = 16
??4Value@Json@@QAEAAV01@ABV01@@Z PROC NEAR		; Json::Value::operator=, COMDAT
; _this$ = esi
; _other$ = eax

; 488  : {

	sub	esp, 16					; 00000010H
	push	edi

; 489  :    Value temp( other );

	push	eax
	lea	ecx, DWORD PTR _temp$[esp+24]
	call	??0Value@Json@@QAE@ABV01@@Z		; Json::Value::Value

; 490  :    swap( temp );

	movsx	eax, BYTE PTR [esi+8]
	mov	ecx, DWORD PTR _temp$[esp+28]
	mov	edi, DWORD PTR _temp$[esp+20]
	mov	edx, ecx
	xor	edx, eax
	mov	eax, DWORD PTR [esi]
	mov	BYTE PTR [esi+8], cl
	mov	DWORD PTR [esi], edi
	mov	edi, DWORD PTR _temp$[esp+24]
	and	edx, 255				; 000000ffH
	xor	ecx, edx
	mov	edx, DWORD PTR [esi+4]
	mov	DWORD PTR _temp$[esp+20], eax
	mov	DWORD PTR _temp$[esp+24], edx
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+4], edi
	mov	eax, edx
	shl	eax, 23					; 00000017H
	sar	eax, 31					; 0000001fH
	mov	edi, ecx
	shl	edi, 23					; 00000017H
	shl	eax, 8
	sar	edi, 23					; 00000017H
	xor	eax, ecx
	xor	edi, edx
	and	eax, 256				; 00000100H
	xor	ecx, eax
	and	edi, 256				; 00000100H
	xor	edi, edx
	mov	DWORD PTR _temp$[esp+28], ecx

; 491  :    return *this;

	lea	ecx, DWORD PTR _temp$[esp+20]
	mov	DWORD PTR [esi+8], edi
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	mov	eax, esi
	pop	edi

; 492  : }

	add	esp, 16					; 00000010H
	ret	0
??4Value@Json@@QAEAAV01@ABV01@@Z ENDP			; Json::Value::operator=
PUBLIC	?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ; Json::Value::get
; Function compile flags: /Ogtpy
;	COMDAT ?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z
_TEXT	SEGMENT
$T54875 = -4						; size = 4
_this$ = 8						; size = 4
_defaultValue$ = 12					; size = 4
?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z PROC NEAR ; Json::Value::get, COMDAT
; ___$ReturnUdt$ = ecx
; _key$ = eax

; 1093 : {

	push	ecx
	push	esi
	mov	esi, ecx

; 1094 :    return get( key.c_str(), defaultValue );

	cmp	DWORD PTR [eax+24], 16			; 00000010H
	mov	DWORD PTR $T54875[esp+8], 0
	jb	SHORT $L54889
	mov	ecx, DWORD PTR _defaultValue$[esp+4]
	mov	eax, DWORD PTR [eax+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+8]
	call	?get@Value@Json@@QBE?AV12@PBDABV12@@Z	; Json::Value::get
	mov	eax, esi
	pop	esi

; 1095 : }

	pop	ecx
	ret	8

; 1094 :    return get( key.c_str(), defaultValue );

$L54889:
	mov	ecx, DWORD PTR _defaultValue$[esp+4]
	push	ecx
	mov	ecx, DWORD PTR _this$[esp+8]
	add	eax, 4
	call	?get@Value@Json@@QBE?AV12@PBDABV12@@Z	; Json::Value::get
	mov	eax, esi
	pop	esi

; 1095 : }

	pop	ecx
	ret	8
?get@Value@Json@@QBE?AV12@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ENDP ; Json::Value::get
_TEXT	ENDS
PUBLIC	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z	; Json::Value::resolveReference
;	COMDAT xdata$x
xdata$x	SEGMENT
$T55116	DD	0ffffffffH
	DD	FLAT:$L54907
	DD	0ffffffffH
	DD	FLAT:$L54899
	DD	0ffffffffH
	DD	FLAT:$L54900
	DD	02H
	DD	FLAT:$L54901
$T55108	DD	019930520H
	DD	04H
	DD	FLAT:$T55116
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
_TEXT	SEGMENT
_actualKey$ = -52					; size = 8
$T54894 = -52						; size = 16
_defaultValue$ = -36					; size = 24
__$EHRec$ = -12						; size = 12
$T54910 = 8						; size = 4
$T54897 = 8						; size = 4
_this$ = 8						; size = 4
$T54957 = 12						; size = 4
_isStatic$ = 12						; size = 1
?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z PROC NEAR ; Json::Value::resolveReference, COMDAT
; _key$ = ecx

; 981  : {

	push	-1
	push	__ehhandler$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+56]

; 982  :    JSON_ASSERT( type_ == nullValue  ||  type_ == objectValue );
; 983  :    if ( type_ == nullValue )

	mov	al, BYTE PTR [ebp+8]
	test	al, al
	push	esi
	push	edi
	mov	ebx, ecx
	jne	SHORT $L55109

; 994  :    Value &value = (*it).second;
; 995  :    return value;

	mov	eax, DWORD PTR $T54894[esp+76]
	and	eax, -505				; fffffe07H
	or	eax, 7
	xor	esi, esi
	push	12					; 0000000cH
	mov	DWORD PTR $T54894[esp+80], eax
	mov	DWORD PTR $T54894[esp+84], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T54910[esp+64], eax
	cmp	eax, esi
	mov	DWORD PTR __$EHRec$[esp+76], esi
	je	SHORT $L54911
	mov	esi, eax
	call	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
	jmp	SHORT $L54912

; 984  :       *this = Value( objectValue );

$L54911:
	xor	eax, eax
$L54912:
	mov	DWORD PTR $T54894[esp+68], eax
	lea	eax, DWORD PTR $T54894[esp+68]
	mov	esi, ebp
	mov	DWORD PTR __$EHRec$[esp+76], 1
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T54894[esp+68]
	mov	DWORD PTR __$EHRec$[esp+76], -1
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L55109:

; 985  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 986  :    CZString actualKey( key, isStatic ? CZString::noDuplication 
; 987  :                                      : CZString::duplicateOnCopy );

	mov	al, BYTE PTR _isStatic$[esp+64]
	xor	ecx, ecx
	test	al, al
	setne	cl
	dec	ecx
	and	ecx, 2
	mov	esi, ecx
	cmp	esi, 1
	mov	DWORD PTR $T54957[esp+64], esi
	jne	SHORT $L54945
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, cl
	jne	SHORT $L54949
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, ecx
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L54949:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [ecx]
	push	ebx
	call	DWORD PTR [edx+4]
	mov	ebx, eax
$L54945:
	mov	DWORD PTR _actualKey$[esp+68], ebx
	mov	DWORD PTR _actualKey$[esp+72], esi
	mov	DWORD PTR __$EHRec$[esp+76], 2

; 988  :    ObjectValues::iterator it = value_.map_->lower_bound( actualKey );

	mov	edi, DWORD PTR [ebp]
	lea	eax, DWORD PTR _actualKey$[esp+68]
	push	eax
	mov	eax, edi
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
	mov	esi, eax

; 989  :    if ( it != value_.map_->end()  &&  (*it).first == actualKey )

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $L12380
	lea	edx, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR _actualKey$[esp+68]
	call	??8CZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator==
	test	al, al
	je	SHORT $L12380

; 990  :       return (*it).second;

	add	esi, 24					; 00000018H
	jmp	SHORT $L55115
$L12380:

; 991  : 
; 992  :    ObjectValues::value_type defaultValue( actualKey, null );

	push	OFFSET FLAT:?null@Value@Json@@2V12@B	; Json::Value::null
	lea	eax, DWORD PTR _defaultValue$[esp+72]
	push	eax
	lea	ecx, DWORD PTR _actualKey$[esp+76]
	call	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
	mov	BYTE PTR __$EHRec$[esp+76], 3

; 993  :    it = value_.map_->insert( it, defaultValue );

	mov	eax, DWORD PTR [ebp]
	push	esi
	lea	edi, DWORD PTR _defaultValue$[esp+72]
	lea	esi, DWORD PTR $T54897[esp+68]
	call	?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
	mov	eax, DWORD PTR [eax]

; 994  :    Value &value = (*it).second;
; 995  :    return value;

	lea	ecx, DWORD PTR _defaultValue$[esp+68]
	push	ecx
	lea	esi, DWORD PTR [eax+24]
	mov	BYTE PTR __$EHRec$[esp+80], 2
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
$L55115:
	test	ebx, ebx
	mov	DWORD PTR __$EHRec$[esp+76], -1
	je	SHORT $L55096
	mov	ecx, DWORD PTR $T54957[esp+64]
	mov	eax, 1
	cmp	ecx, eax
	jne	SHORT $L55096
	test	BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, al
	jne	SHORT $L55100
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, eax
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	call	_atexit
	add	esp, 4
$L55100:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [ecx]
	push	ebx
	call	DWORD PTR [edx+8]
$L55096:

; 996  : #else
; 997  :    return value_.map_->resolveReference( key, isStatic );
; 998  : #endif
; 999  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 52					; 00000034H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L54907:
	mov	eax, DWORD PTR $T54910[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L54899:
	lea	ecx, DWORD PTR $T54894[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L54900:
	lea	esi, DWORD PTR _actualKey$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
$L54901:
	lea	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	ret	0
__ehhandler$?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z:
	mov	eax, OFFSET FLAT:$T55108
	jmp	___CxxFrameHandler
text$x	ENDS
?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ENDP	; Json::Value::resolveReference
PUBLIC	??AValue@Json@@QAEAAV01@PBD@Z			; Json::Value::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??AValue@Json@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
??AValue@Json@@QAEAAV01@PBD@Z PROC NEAR			; Json::Value::operator[], COMDAT
; _this$ = eax
; _key$ = ecx

; 974  :    return resolveReference( key, false );

	push	0
	push	eax
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference

; 975  : }

	ret	0
??AValue@Json@@QAEAAV01@PBD@Z ENDP			; Json::Value::operator[]
_TEXT	ENDS
PUBLIC	??AValue@Json@@QAEAAV01@I@Z			; Json::Value::operator[]
;	COMDAT xdata$x
xdata$x	SEGMENT
$T55309	DD	0ffffffffH
	DD	FLAT:$L55138
	DD	0ffffffffH
	DD	FLAT:$L55130
	DD	0ffffffffH
	DD	FLAT:$L55131
	DD	02H
	DD	FLAT:$L55132
$T55307	DD	019930520H
	DD	04H
	DD	FLAT:$T55309
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??AValue@Json@@QAEAAV01@I@Z
_TEXT	SEGMENT
_key$ = -52						; size = 8
$T55125 = -52						; size = 16
_defaultValue$ = -36					; size = 24
__$EHRec$ = -12						; size = 12
$T55151 = 8						; size = 4
$T55128 = 8						; size = 4
_this$ = 8						; size = 4
_index$ = 12						; size = 4
??AValue@Json@@QAEAAV01@I@Z PROC NEAR			; Json::Value::operator[], COMDAT

; 933  : {

	push	-1
	mov	eax, DWORD PTR fs:__except_list
	push	__ehhandler$??AValue@Json@@QAEAAV01@I@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+56]

; 934  :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue );
; 935  :    if ( type_ == nullValue )

	mov	al, BYTE PTR [ebp+8]
	xor	ebx, ebx
	cmp	al, bl
	push	esi
	push	edi
	jne	SHORT $L12338

; 945  :    return (*it).second;

	mov	eax, DWORD PTR $T55125[esp+76]
	and	eax, -506				; fffffe06H
	or	eax, 6
	push	12					; 0000000cH
	mov	DWORD PTR $T55125[esp+80], eax
	mov	DWORD PTR $T55125[esp+84], ebx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T55151[esp+64], eax
	cmp	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+76], ebx
	je	SHORT $L55152
	mov	esi, eax
	call	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
	jmp	SHORT $L55153

; 936  :       *this = Value( arrayValue );

$L55152:
	xor	eax, eax
$L55153:
	mov	DWORD PTR $T55125[esp+68], eax
	lea	eax, DWORD PTR $T55125[esp+68]
	mov	esi, ebp
	mov	DWORD PTR __$EHRec$[esp+76], 1
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T55125[esp+68]
	mov	DWORD PTR __$EHRec$[esp+76], -1
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L12338:

; 937  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 938  :    CZString key( index );

	mov	ecx, DWORD PTR _index$[esp+64]
	mov	DWORD PTR _key$[esp+68], ebx
	mov	DWORD PTR _key$[esp+72], ecx
	mov	ebx, 2
	mov	DWORD PTR __$EHRec$[esp+76], ebx

; 939  :    ObjectValues::iterator it = value_.map_->lower_bound( key );

	mov	edi, DWORD PTR [ebp]
	lea	edx, DWORD PTR _key$[esp+68]
	push	edx
	mov	eax, edi
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
	mov	esi, eax

; 940  :    if ( it != value_.map_->end()  &&  (*it).first == key )

	cmp	esi, DWORD PTR [edi+4]
	je	SHORT $L12344
	lea	edx, DWORD PTR [esi+16]
	lea	ecx, DWORD PTR _key$[esp+68]
	call	??8CZString@Value@Json@@QBE_NABV012@@Z	; Json::Value::CZString::operator==
	test	al, al
	je	SHORT $L12344
	pop	edi

; 941  :       return (*it).second;

	lea	eax, DWORD PTR [esi+24]
	pop	esi
	pop	ebp
	pop	ebx

; 946  : #else
; 947  :    return value_.array_->resolveReference( index );
; 948  : #endif
; 949  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+52]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 52					; 00000034H
	ret	8
$L12344:

; 942  : 
; 943  :    ObjectValues::value_type defaultValue( key, null );

	push	OFFSET FLAT:?null@Value@Json@@2V12@B	; Json::Value::null
	lea	eax, DWORD PTR _defaultValue$[esp+72]
	push	eax
	lea	ecx, DWORD PTR _key$[esp+76]
	call	??0?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@ABVCZString@Value@Json@@ABV34@@Z ; std::pair<Json::Value::CZString const ,Json::Value>::pair<Json::Value::CZString const ,Json::Value>
	mov	BYTE PTR __$EHRec$[esp+76], 3

; 944  :    it = value_.map_->insert( it, defaultValue );

	mov	eax, DWORD PTR [ebp]
	push	esi
	lea	edi, DWORD PTR _defaultValue$[esp+72]
	lea	esi, DWORD PTR $T55128[esp+68]
	call	?insert@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@ABU?$pair@$$CBVCZString@Value@Json@@V23@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::insert
	mov	eax, DWORD PTR [eax]

; 945  :    return (*it).second;

	lea	ecx, DWORD PTR _defaultValue$[esp+68]
	push	ecx
	lea	esi, DWORD PTR [eax+24]
	mov	BYTE PTR __$EHRec$[esp+80], bl
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ

; 946  : #else
; 947  :    return value_.array_->resolveReference( index );
; 948  : #endif
; 949  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 52					; 00000034H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L55138:
	mov	eax, DWORD PTR $T55151[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L55130:
	lea	ecx, DWORD PTR $T55125[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L55131:
	lea	esi, DWORD PTR _key$[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
$L55132:
	lea	eax, DWORD PTR _defaultValue$[ebp]
	push	eax
	call	??1?$pair@$$CBVCZString@Value@Json@@V23@@std@@QAE@XZ
	ret	0
__ehhandler$??AValue@Json@@QAEAAV01@I@Z:
	mov	eax, OFFSET FLAT:$T55307
	jmp	___CxxFrameHandler
text$x	ENDS
??AValue@Json@@QAEAAV01@I@Z ENDP			; Json::Value::operator[]
PUBLIC	?resize@Value@Json@@QAEXI@Z			; Json::Value::resize
;	COMDAT xdata$x
xdata$x	SEGMENT
$T55560	DD	0ffffffffH
	DD	FLAT:$L55324
	DD	0ffffffffH
	DD	FLAT:$L55317
	DD	0ffffffffH
	DD	FLAT:$L55318
$T55555	DD	019930520H
	DD	03H
	DD	FLAT:$T55560
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ?resize@Value@Json@@QAEXI@Z
_TEXT	SEGMENT
$T55327 = -40						; size = 4
_oldSize$ = -40						; size = 4
$T55494 = -36						; size = 4
$T55316 = -32						; size = 8
$T55315 = -32						; size = 16
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?resize@Value@Json@@QAEXI@Z PROC NEAR			; Json::Value::resize, COMDAT
; _newSize$ = ecx

; 909  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	-1
	push	__ehhandler$?resize@Value@Json@@QAEXI@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi

; 910  :    JSON_ASSERT( type_ == nullValue  ||  type_ == arrayValue );
; 911  :    if ( type_ == nullValue )

	mov	edi, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [edi+8]
	test	al, al
	mov	ebx, ecx
	jne	SHORT $L12320

; 919  :    else
; 920  :    {
; 921  :       for ( UInt index = newSize; index < oldSize; ++index )

	mov	eax, DWORD PTR $T55315[esp+64]
	and	eax, -506				; fffffe06H
	or	eax, 6
	xor	esi, esi
	push	12					; 0000000cH
	mov	DWORD PTR $T55315[esp+68], eax
	mov	DWORD PTR $T55315[esp+72], esi
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T55327[esp+56], eax
	cmp	eax, esi
	mov	DWORD PTR __$EHRec$[esp+64], esi
	je	SHORT $L55328
	mov	esi, eax
	call	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
	jmp	SHORT $L55329

; 912  :       *this = Value( arrayValue );

$L55328:
	xor	eax, eax
$L55329:
	mov	DWORD PTR $T55315[esp+56], eax
	lea	eax, DWORD PTR $T55315[esp+56]
	mov	esi, edi
	mov	DWORD PTR __$EHRec$[esp+64], 1
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T55315[esp+56]
	mov	DWORD PTR __$EHRec$[esp+64], -1
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L12320:

; 913  : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 914  :    UInt oldSize = size();

	mov	ecx, edi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size

; 915  :    if ( newSize == 0 )

	test	ebx, ebx
	mov	DWORD PTR _oldSize$[esp+56], eax
	jne	SHORT $L12323

; 916  :       clear();

	movsx	eax, BYTE PTR [edi+8]
	cmp	eax, 6
	jl	$L12330
	cmp	eax, 7
	jg	$L12330
	mov	esi, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi+4]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	ecx, esi
	call	?_Erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IAEXPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Erase
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+4], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [eax], eax
	mov	esi, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], esi

; 923  :       assert( size() == newSize );
; 924  :    }
; 925  : #else
; 926  :    value_.array_->resize( newSize );
; 927  : #endif
; 928  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L12323:

; 917  :    else if ( newSize > oldSize )

	cmp	ebx, eax
	jbe	SHORT $L12325

; 918  :       (*this)[ newSize - 1 ];

	dec	ebx
	push	ebx
	push	edi
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]

; 923  :       assert( size() == newSize );
; 924  :    }
; 925  : #else
; 926  :    value_.array_->resize( newSize );
; 927  : #endif
; 928  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	mov	DWORD PTR fs:__except_list, ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$L12325:

; 919  :    else
; 920  :    {
; 921  :       for ( UInt index = newSize; index < oldSize; ++index )

	cmp	ebx, eax
	mov	esi, ebx
	jae	SHORT $L12330

; 922  :          value_.map_->erase( index );

	mov	DWORD PTR $T55316[esp+56], 0
	jmp	SHORT $L12328
$L55558:
	mov	edi, DWORD PTR _this$[ebp]
	npad	4
$L12328:
	mov	DWORD PTR $T55316[esp+60], esi
	mov	DWORD PTR __$EHRec$[esp+64], 2
	mov	edi, DWORD PTR [edi]
	lea	eax, DWORD PTR $T55316[esp+56]
	push	eax
	mov	eax, edi
	call	?_Ubound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Ubound
	lea	ecx, DWORD PTR $T55316[esp+56]
	mov	ebx, eax
	push	ecx
	mov	eax, edi
	call	?_Lbound@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@IBEPAU_Node@?$_Tree_nod@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Lbound
	push	ebx
	push	eax
	lea	edx, DWORD PTR $T55494[esp+64]
	push	edx
	call	?erase@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::erase
	mov	DWORD PTR __$EHRec$[esp+64], -1
	mov	eax, DWORD PTR _oldSize$[esp+56]
	inc	esi
	cmp	esi, eax
	jb	SHORT $L55558
$L12330:

; 923  :       assert( size() == newSize );
; 924  :    }
; 925  : #else
; 926  :    value_.array_->resize( newSize );
; 927  : #endif
; 928  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+56]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L55324:
	mov	eax, DWORD PTR $T55327[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L55317:
	lea	ecx, DWORD PTR $T55315[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L55318:
	lea	esi, DWORD PTR $T55316[ebp]
	jmp	??1CZString@Value@Json@@QAE@XZ		; Json::Value::CZString::~CZString
__ehhandler$?resize@Value@Json@@QAEXI@Z:
	mov	eax, OFFSET FLAT:$T55555
	jmp	___CxxFrameHandler
text$x	ENDS
?resize@Value@Json@@QAEXI@Z ENDP			; Json::Value::resize
PUBLIC	?append@Value@Json@@QAEAAV12@ABV12@@Z		; Json::Value::append
; Function compile flags: /Ogtpy
;	COMDAT ?append@Value@Json@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?append@Value@Json@@QAEAAV12@ABV12@@Z PROC NEAR		; Json::Value::append, COMDAT
; _this$ = eax

; 1076 : {

	push	esi
	mov	esi, eax

; 1077 :    return (*this)[size()] = value;

	mov	ecx, esi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	push	eax
	push	esi
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]
	mov	esi, eax
	mov	eax, DWORD PTR _value$[esp]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	pop	esi

; 1078 : }

	ret	4
?append@Value@Json@@QAEAAV12@ABV12@@Z ENDP		; Json::Value::append
_TEXT	ENDS
PUBLIC	??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z	; Json::Value::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z
_TEXT	SEGMENT
??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z PROC NEAR	; Json::Value::operator[], COMDAT
; _this$ = edx
; _key$ = eax

; 1054 :    return resolveReference( key, true );

	mov	ecx, DWORD PTR [eax]
	push	1
	push	edx
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference

; 1055 : }

	ret	0
??AValue@Json@@QAEAAV01@ABVStaticString@1@@Z ENDP	; Json::Value::operator[]
_TEXT	ENDS
PUBLIC	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
; Function compile flags: /Ogtpy
;	COMDAT ??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; Json::Value::operator[], COMDAT
; _key$ = eax

; 1041 :    return (*this)[ key.c_str() ];

	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L55586
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[esp-4]
	push	0
	push	eax
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference

; 1042 : }

	ret	4

; 1041 :    return (*this)[ key.c_str() ];

$L55586:
	lea	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR _this$[esp-4]
	push	0
	push	eax
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference

; 1042 : }

	ret	4
??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Value::operator[]
PUBLIC	?make@Path@Json@@QBEAAVValue@2@AAV32@@Z		; Json::Path::make
; Function compile flags: /Ogtpy
;	COMDAT ?make@Path@Json@@QBEAAVValue@2@AAV32@@Z
_TEXT	SEGMENT
?make@Path@Json@@QBEAAVValue@2@AAV32@@Z PROC NEAR	; Json::Path::make, COMDAT
; _this$ = edi
; _root$ = eax

; 1610 :    Value *node = &root;
; 1611 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	mov	ecx, DWORD PTR [edi+8]
	push	esi
	mov	esi, DWORD PTR [edi+4]
	cmp	esi, ecx
	je	SHORT $L13198
	npad	5
$L57926:

; 1612 :    {
; 1613 :       const PathArgument &arg = *it;
; 1614 :       if ( arg.kind_ == PathArgument::kindIndex )

	mov	ecx, DWORD PTR [esi+32]
	cmp	ecx, 1
	jne	SHORT $L13200

; 1615 :       {
; 1616 :          if ( !node->isArray() )
; 1617 :          {
; 1618 :             // Error: node is not an array at position ...
; 1619 :          }
; 1620 :          node = &((*node)[arg.index_]);

	mov	ecx, DWORD PTR [esi+28]
	push	ecx
	push	eax
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]

; 1621 :       }
; 1622 :       else if ( arg.kind_ == PathArgument::kindKey )

	jmp	SHORT $L13197
$L13200:
	cmp	ecx, 2
	jne	SHORT $L13197

; 1623 :       {
; 1624 :          if ( !node->isObject() )
; 1625 :          {
; 1626 :             // Error: node is not an object at position...
; 1627 :          }
; 1628 :          node = &((*node)[arg.key_]);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L57986
	mov	ecx, DWORD PTR [esi+4]
	jmp	SHORT $L57987
$L57986:

; 1610 :    Value *node = &root;
; 1611 :    for ( Args::const_iterator it = args_.begin(); it != args_.end(); ++it )

	lea	ecx, DWORD PTR [esi+4]

; 1623 :       {
; 1624 :          if ( !node->isObject() )
; 1625 :          {
; 1626 :             // Error: node is not an object at position...
; 1627 :          }
; 1628 :          node = &((*node)[arg.key_]);

$L57987:
	push	0
	push	eax
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference
$L13197:
	mov	ecx, DWORD PTR [edi+8]
	add	esi, 36					; 00000024H
	cmp	esi, ecx
	jne	SHORT $L57926
$L13198:
	pop	esi

; 1629 :       }
; 1630 :    }
; 1631 :    return *node;
; 1632 : }

	ret	0
?make@Path@Json@@QBEAAVValue@2@AAV32@@Z ENDP		; Json::Path::make
CRT$XCU	SEGMENT
_$S3	DD	FLAT:_$E1
; Function compile flags: /Ogtpy
CRT$XCU	ENDS
;	COMDAT _$E1
text$yc	SEGMENT
_$E1	PROC NEAR					; COMDAT

; 19   : const Value Value::null;

	push	edi
	push	0
	mov	edi, OFFSET FLAT:?null@Value@Json@@2V12@B
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	push	OFFSET FLAT:_$E2
	call	_atexit
	add	esp, 4
	pop	edi
	ret	0
_$E1	ENDP
text$yc	ENDS
CRT$XCU	SEGMENT
_$S7	DD	FLAT:_$E6
; Function compile flags: /Ogtpy
CRT$XCU	ENDS
;	COMDAT _$E6
text$yc	SEGMENT
_$E6	PROC NEAR					; COMDAT

; 107  : } dummyValueAllocatorInitializer;

	jmp	?valueAllocator@Json@@YAAAPAVValueAllocator@1@XZ ; Json::valueAllocator
_$E6	ENDP
; Function compile flags: /Ogtpy
text$yc	ENDS
;	COMDAT _$E5
text$yd	SEGMENT
_$E5	PROC NEAR					; COMDAT
	mov	ecx, OFFSET FLAT:?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A
	jmp	??1DefaultValueAllocator@Json@@UAE@XZ	; Json::DefaultValueAllocator::~DefaultValueAllocator
_$E5	ENDP
; Function compile flags: /Ogtpy
text$yd	ENDS
;	COMDAT _$E2
text$yd	SEGMENT
_$E2	PROC NEAR					; COMDAT
	mov	ecx, OFFSET FLAT:?null@Value@Json@@2V12@B
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
_$E2	ENDP
text$yd	ENDS
PUBLIC	?null@Value@Json@@2V12@B			; Json::Value::null
_dummyValueAllocatorInitializer DB 01H DUP (?)
	ALIGN	4

?null@Value@Json@@2V12@B DB 010H DUP (?)		; Json::Value::null
END
