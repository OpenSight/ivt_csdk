; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.3077 

	TITLE	.\json_reader.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03FFDNHNKN@rue?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04KCECFHEP@alse?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03KNPGGKC@ull?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_04JBAOJHKB@See?5?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?in@Json@@YA_NDDDDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?in@Json@@YA_NDDDDDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?containsNewLine@Json@@YA_NPBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0Reader@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readValue@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?skipSpaces@Reader@Json@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?match@Reader@Json@@AAE_NPBDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readCStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readCppStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readNumber@Reader@Json@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readString@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?currentValue@Reader@Json@@AAEAAVValue@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getNextChar@Reader@Json@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXViterator@12@IABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEAAPAVValue@Json@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Hiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Ziterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Giterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Aiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Yiterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Ziterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy_backward@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$copy@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@VErrorInfo@Reader@Json@@@std@@YAXViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0ABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GErrorInfo@Reader@Json@@QAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@VErrorInfo@Reader@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVValue@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT P‡]PÉa∞ˆh
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ÄÔˇˇÑÉaB∫®Ûb¸Éa…
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ZF-t‰hÑaP‰`∞ˆh(z7
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ~ÔˇˇåÑaZÏï∂êÉaÑÖax‰`∞ˆh(z7
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ¯Ña∞ˆh
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT h
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT cale::_Locimp
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT π
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT Z†rù∞ÅbÖaÄÜa∞ˆh
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ÙÜa∞ˆh
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT 	
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT áaÊD
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ing
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT locator<char> > const &>
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT tor<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::rebind<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _traits<char>,std::allocator<char> > >::rebind<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT <char,std::char_traits<char>,std::allocator<char> > >
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 	
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT tÔˇˇTçaBÚ¡»»˘b¸äaƒåa∞ˆh
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT utex
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ËÂ`∞ˆh`ça
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ∞ˆh(z7
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT @¯ƒÑÙéa
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT Z(˛£Låb\éaÏèa∞ˆh
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT _traits<unsigned short> >
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ËÊ`∞ˆhºêa
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT hëaB†8@¸b‰ëae
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ZÇ¨|íbtëa\ía∞ˆh
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ambuf<unsigned short,std::char_traits<unsigned short> >
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT HÙa
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT »Ûa@VD‘Ûa
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT os
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ∞ˆh
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT streambuf<char,std::char_traits<char> >
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 8˜a
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ::_Locinfo
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT WÔˇˇà˝aB|øpc ˝aÄÍ`∞ˆhê¸a
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT UÔˇˇ
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ÒD
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT B"|ø∏˝a
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT |Î`∞ˆh@ˇa
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT &
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT @¯ÙHº˛aD
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ë](ˇaÛD
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ºÎ`∞ˆhD
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT @¯¸Ñ¿ˇa†„bºÎ`∞ˆh∏
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT bZ¿Õ.¸πb‹
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT (cåb`
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT S
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT HÔˇˇ‰bB4∏Ñ1c¥‰b‡Ï`∞ˆh†„b
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ÍbxÎb∞ˆh
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT r<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT &
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT A¶J{∞6c‘Ïb)
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT 
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
;	COMDAT B†`Ä$9cÌb
rdata$r	SEGMENT DWORD USE32 PUBLIC 'CONST'
rdata$r	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC

PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ ; `string'
PUBLIC	??_C@_03FFDNHNKN@rue?$AA@			; `string'
PUBLIC	??_C@_04KCECFHEP@alse?$AA@			; `string'
PUBLIC	??_C@_03KNPGGKC@ull?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ ; `string'
PUBLIC	??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ ; `string'
PUBLIC	??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ ; `string'
PUBLIC	??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ ; `string'
PUBLIC	??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ ; `string'
PUBLIC	??_C@_01GEODFPGF@?8?$AA@			; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf?$AA@			; `string'
PUBLIC	??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_02KAOAMBHJ@?$CK?5?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@	; `string'
PUBLIC	??_C@_04JBAOJHKB@See?5?$AA@			; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
PUBLIC	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	??1ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::~ErrorInfo
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
PUBLIC	?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
PUBLIC	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
PUBLIC	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
PUBLIC	??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
PUBLIC	?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
PUBLIC	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
PUBLIC	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
PUBLIC	??Dconst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator*
PUBLIC	??Econst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator++
PUBLIC	??9const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV012@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator!=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
PUBLIC	?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
PUBLIC	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
PUBLIC	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
PUBLIC	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
PUBLIC	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
PUBLIC	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
PUBLIC	??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
PUBLIC	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate
PUBLIC	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
PUBLIC	??0const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBV12@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::const_iterator
PUBLIC	??8const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV012@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator==
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AViterator@12@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
PUBLIC	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
PUBLIC	??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@XZ	; std::allocator<Json::Value *>::allocator<Json::Value *>
PUBLIC	?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::deallocate
PUBLIC	?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::allocate
PUBLIC	?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z ; std::allocator<Json::Value *>::construct
PUBLIC	?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy
PUBLIC	?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::deallocate
PUBLIC	?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::allocator<Json::Value * *>::destroy
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
PUBLIC	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
PUBLIC	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
PUBLIC	?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXViterator@12@IABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert_n
PUBLIC	?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
PUBLIC	??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
PUBLIC	?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::deallocate
PUBLIC	?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
PUBLIC	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate
PUBLIC	?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo *>::destroy
PUBLIC	??Diterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator*
PUBLIC	??Giterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV012@H@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator-
PUBLIC	??Hiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV012@H@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator+
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
PUBLIC	?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
PUBLIC	??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::_Deque_map<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
PUBLIC	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate
PUBLIC	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
PUBLIC	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
PUBLIC	?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy
PUBLIC	?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ; std::allocator<Json::Reader::ErrorInfo>::max_size
PUBLIC	??0iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBV12@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::iterator
PUBLIC	??Ziterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV012@H@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator-=
PUBLIC	??Dconst_iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::const_iterator::operator*
PUBLIC	??0iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::iterator
PUBLIC	??0iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBV12@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::iterator
PUBLIC	??Yiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@H@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator+=
PUBLIC	??Giterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV012@H@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator-
PUBLIC	??Giterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator-
PUBLIC	??Aiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator[]
PUBLIC	?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ; std::allocator<Json::Value *>::max_size
PUBLIC	??0const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::const_iterator
PUBLIC	??Gconst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV012@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator-
PUBLIC	??Yiterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV012@H@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator+=
PUBLIC	??0const_iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBV12@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::const_iterator::const_iterator
PUBLIC	??Diterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator*
PUBLIC	??Ziterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@H@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator-=
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ; std::_Uninitialized_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ; std::_Destroy_range<Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo>
PUBLIC	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
PUBLIC	??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@@Z ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@@Z ; std::_Uninitialized_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z ; std::_Destroy_range<Json::Value * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ; std::_Allocate<Json::Value *>
PUBLIC	??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z ; std::_Construct<Json::Value *,Json::Value *>
PUBLIC	??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z ; std::_Destroy<Json::Value *>
PUBLIC	??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z ; std::_Destroy<Json::Value * *>
PUBLIC	??$copy_backward@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00@Z ; std::copy_backward<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
PUBLIC	??$copy@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00@Z ; std::copy<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
PUBLIC	??$fill@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@VErrorInfo@Reader@Json@@@std@@YAXViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0ABVErrorInfo@Reader@Json@@@Z ; std::fill<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,Json::Reader::ErrorInfo>
PUBLIC	??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
PUBLIC	??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo *>
PUBLIC	??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z ; std::_Destroy<Json::Reader::ErrorInfo *>
PUBLIC	??$_Allocate@D@std@@YAPADIPAD@Z			; std::_Allocate<char>
PUBLIC	??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
PUBLIC	??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ; std::_Allocate<Json::Value * *>
PUBLIC	??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z ; std::_Destroy<Json::Reader::ErrorInfo>
PUBLIC	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z	; Json::Reader::ErrorInfo::operator=
PUBLIC	??_GErrorInfo@Reader@Json@@QAEPAXI@Z		; Json::Reader::ErrorInfo::`scalar deleting destructor'
PUBLIC	??Eiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator++
PUBLIC	??$_Ptr_cat@VErrorInfo@Reader@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo>
PUBLIC	??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
PUBLIC	??$_Uninit_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::Reader::ErrorInfo *,unsigned int,Json::Reader::ErrorInfo *>
PUBLIC	??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Ptr_cat@PAVValue@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value *>
PUBLIC	??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * *,Json::Value * *>
PUBLIC	??$_Uninit_fill_n@PAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::Value * *,unsigned int,Json::Value * *>
PUBLIC	??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<Json::Value * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Ptr_cat@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ; std::_Ptr_cat<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
PUBLIC	??$_Copy_backward_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
PUBLIC	??$_Copy_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
PUBLIC	??Fiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator--
PUBLIC	??$fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ; std::fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
PUBLIC	??$fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ; std::fill_n<Json::Value * * *,unsigned int,Json::Value * *>
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@A@exception@@8			; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVexception@@@8				; exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	??_R1A@?0A@A@logic_error@std@@8			; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_R1A@?0A@A@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	??0exception@@QAE@ABV0@@Z:NEAR			; exception::exception
EXTRN	??0exception@@QAE@XZ:NEAR			; exception::exception
EXTRN	??1exception@@UAE@XZ:NEAR			; exception::~exception
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
EXTRN	_memmove:NEAR
EXTRN	_sscanf:NEAR
EXTRN	?_Xlen@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xlen
EXTRN	?_Xran@_String_base@std@@QBEXXZ:NEAR		; std::_String_base::_Xran
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:NEAR		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:NEAR		; std::length_error::`vector deleting destructor'
EXTRN	_sprintf:NEAR
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
CONST	SEGMENT
??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ DB 'Syntax err'
	DB	'or: value, object or array expected.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFDNHNKN@rue?$AA@
CONST	SEGMENT
??_C@_03FFDNHNKN@rue?$AA@ DB 'rue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCECFHEP@alse?$AA@
CONST	SEGMENT
??_C@_04KCECFHEP@alse?$AA@ DB 'alse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03KNPGGKC@ull?$AA@
CONST	SEGMENT
??_C@_03KNPGGKC@ull?$AA@ DB 'ull', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
CONST	SEGMENT
??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ DB 'Missing '
	DB	''':'' after object member name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
CONST	SEGMENT
??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ DB 'Mi'
	DB	'ssing '','' or ''}'' in object declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
CONST	SEGMENT
??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ DB 'Missin'
	DB	'g ''}'' or object member name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
CONST	SEGMENT
??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ DB 'Mi'
	DB	'ssing '','' or '']'' in array declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
CONST	SEGMENT
??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ DB ''' is not a number.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8?$AA@
CONST	SEGMENT
??_C@_01GEODFPGF@?8?$AA@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf?$AA@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf?$AA@ DB '%lf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ DB 'Empty esc'
	DB	'ape sequence in string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ DB 'Bad escape '
	DB	'sequence in string', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: four digits expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: hexadecimal digit expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ DB 'Line %d, Column '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5?$AA@
CONST	SEGMENT
??_C@_02KAOAMBHJ@?$CK?5?$AA@ DB '* ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
CONST	SEGMENT
??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@ DB ' for detail.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBAOJHKB@See?5?$AA@
CONST	SEGMENT
??_C@_04JBAOJHKB@See?5?$AA@ DB 'See ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT
??_R0?AVexception@@@8 DD FLAT:??_7type_info@@6B@	; exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@@', 00H
_DATA	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@@QAE@ABV0@@Z
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_R1A@?0A@A@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@A@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@A@exception@@8
rdata$r	SEGMENT
??_R1A@?0A@A@exception@@8 DD FLAT:??_R0?AVexception@@@8	; exception::`RTTI Base Class Descriptor at (0,-1,0,0)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	00H
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@A@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@A@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@A@exception@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z
_TEXT	SEGMENT
??$fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z PROC NEAR ; std::fill_n<Json::Value * * *,unsigned int,Json::Value * *>, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

	test	ecx, ecx
	jbe	SHORT $L15281
	push	esi
$L15279:

; 1161 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	dec	ecx
	jne	SHORT $L15279
	pop	esi
$L15281:

; 1162 : 	}

	ret	0
??$fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ENDP ; std::fill_n<Json::Value * * *,unsigned int,Json::Value * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z
_TEXT	SEGMENT
??$fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z PROC NEAR ; std::fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 1160 : 	for (; 0 < _Count; --_Count, ++_First)

	test	ecx, ecx
	jbe	SHORT $L15277
	push	esi
$L15275:

; 1161 : 		*_First = _Val;

	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	dec	ecx
	jne	SHORT $L15275
	pop	esi
$L15277:

; 1162 : 	}

	ret	0
??$fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ENDP ; std::fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??Fiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Fiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator--, COMDAT
; _this$ = eax

; 270  : 			--this->_Myoff;

	dec	DWORD PTR [eax+4]

; 271  : 			return (*this);
; 272  : 			}

	ret	0
??Fiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator--
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z PROC NEAR ; std::_Ptr_cat<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>, COMDAT

; 211  : 	{	// return pointer category from arbitrary arguments

	push	ecx

; 212  : 	_Nonscalar_ptr_iterator_tag _Cat;
; 213  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 214  : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ENDP ; std::_Ptr_cat<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<Json::Value * *,std::allocator<Json::Value * *> >, COMDAT

; 234  : 	}

	ret	0
??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<Json::Value * *,std::allocator<Json::Value * *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Uninit_fill_n@PAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<Json::Value * *,unsigned int,Json::Value * *>, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 237  : 	fill_n(_First, _Count, _Val);

	test	ecx, ecx
	jbe	SHORT $L18844
	push	esi
$L18842:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	dec	ecx
	jne	SHORT $L18842
	pop	esi
$L18844:

; 238  : 	}

	ret	0
??$_Uninit_fill_n@PAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Json::Value * *,unsigned int,Json::Value * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<Json::Value * *,Json::Value * *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 106  : 	size_t _Count = (size_t)(_Last - _First);

	sub	eax, ecx
	push	esi
	sar	eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Dest$[esp]
	push	esi
	push	ecx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi

; 109  : 	}

	ret	0
??$_Uninit_copy@PAPAVValue@Json@@PAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::Value * *,Json::Value * *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVValue@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@PAVValue@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z PROC NEAR ; std::_Ptr_cat<Json::Value *>, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

	push	ecx

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 221  : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@PAVValue@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAPAVValue@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Value *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Destroy_range<Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 234  : 	}

	ret	0
??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Uninit_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_fill_n<Json::Reader::ErrorInfo *,unsigned int,Json::Reader::ErrorInfo *>, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 237  : 	fill_n(_First, _Count, _Val);

	test	ecx, ecx
	jbe	SHORT $L18866
	push	esi
$L18864:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	dec	ecx
	jne	SHORT $L18864
	pop	esi
$L18866:

; 238  : 	}

	ret	0
??$_Uninit_fill_n@PAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Json::Reader::ErrorInfo *,unsigned int,Json::Reader::ErrorInfo *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>, COMDAT
; __First$ = ecx
; __Last$ = eax

; 106  : 	size_t _Count = (size_t)(_Last - _First);

	sub	eax, ecx
	push	esi
	sar	eax, 2

; 107  : 	return ((_Ty2 *)memmove(&*_Dest, &*_First,
; 108  : 		_Count * sizeof (*_First)) + _Count);	// NB: non-overlapping move

	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Dest$[esp]
	push	esi
	push	ecx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi

; 109  : 	}

	ret	0
??$_Uninit_copy@PAVErrorInfo@Reader@Json@@PAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@VErrorInfo@Reader@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
??$_Ptr_cat@VErrorInfo@Reader@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z PROC NEAR ; std::_Ptr_cat<Json::Reader::ErrorInfo>, COMDAT

; 218  : 	{	// return pointer category from pointer to pointer arguments

	push	ecx

; 219  : 	_Scalar_ptr_iterator_tag _Cat;
; 220  : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[esp+4]

; 221  : 	}

	pop	ecx
	ret	0
??$_Ptr_cat@VErrorInfo@Reader@Json@@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVErrorInfo@Reader@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Reader::ErrorInfo>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??Eiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Eiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator++, COMDAT
; _this$ = eax

; 257  : 			++this->_Myoff;

	inc	DWORD PTR [eax+4]

; 258  : 			return (*this);
; 259  : 			}

	ret	0
??Eiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator++
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z
_TEXT	SEGMENT
??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z PROC NEAR ; std::_Allocate<Json::Value * *>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	ret	0
??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ENDP ; std::_Allocate<Json::Value * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC NEAR ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

	ret	0
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@D@std@@YAPADIPAD@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@D@std@@YAPADIPAD@Z PROC NEAR		; std::_Allocate<char>, COMDAT

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	ret	0
??$_Allocate@D@std@@YAPADIPAD@Z ENDP			; std::_Allocate<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z PROC NEAR ; std::_Destroy<Json::Reader::ErrorInfo *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

	ret	0
??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Destroy<Json::Reader::ErrorInfo *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z
_TEXT	SEGMENT
??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z PROC NEAR ; std::_Allocate<Json::Reader::ErrorInfo *>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	ret	0
??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ENDP ; std::_Allocate<Json::Reader::ErrorInfo *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC NEAR ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>, COMDAT
; _this$ = eax

; 121  : 		{	// construct from a related allocator (do nothing)
; 122  : 		}

	ret	0
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z PROC NEAR ; std::_Destroy<Json::Value * *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

	ret	0
??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z ENDP ; std::_Destroy<Json::Value * *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z PROC NEAR ; std::_Destroy<Json::Value *>, COMDAT

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);
; 50   : 	}

	ret	0
??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z ENDP ; std::_Destroy<Json::Value *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z
_TEXT	SEGMENT
??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z PROC NEAR ; std::_Allocate<Json::Value *>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	ret	0
??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ENDP ; std::_Allocate<Json::Value *>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z PROC NEAR ; std::_Destroy_range<Json::Value * *,std::allocator<Json::Value * *> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

	ret	0
??$_Destroy_range@PAPAVValue@Json@@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z ENDP ; std::_Destroy_range<Json::Value * *,std::allocator<Json::Value * *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@@Z
_TEXT	SEGMENT
??$_Uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

	test	ecx, ecx
	jbe	SHORT $L18940
	push	esi
$L18938:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	dec	ecx
	jne	SHORT $L18938
	pop	esi
$L18940:

; 258  : 	}

	ret	0
??$_Uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@@Z ENDP ; std::_Uninitialized_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >, COMDAT
; __First$ = ecx
; __Last$ = eax

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

	sub	eax, ecx
	push	esi
	sar	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Dest$[esp]
	push	esi
	push	ecx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi

; 129  : 	}

	ret	0
??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z
_TEXT	SEGMENT
??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z PROC NEAR ; std::_Allocate<Json::Reader::ErrorInfo>, COMDAT
; __Count$ = eax

; 34   : 	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));

	imul	eax, 44					; 0000002cH
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 35   : 	}

	ret	0
??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ENDP ; std::_Allocate<Json::Reader::ErrorInfo>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT
??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z PROC NEAR ; std::_Destroy_range<Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 217  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
; 218  : 	}

	ret	0
??$_Destroy_range@PAVErrorInfo@Reader@Json@@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ENDP ; std::_Destroy_range<Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT
??$_Uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z PROC NEAR ; std::_Uninitialized_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT
; __First$ = eax
; __Count$ = ecx
; __Val$ = edx

; 256  : 	_Uninit_fill_n(_First, _Count, _Val, _Al,
; 257  : 		_Ptr_cat(_First, _First));

	test	ecx, ecx
	jbe	SHORT $L18992
	push	esi
$L18990:
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [eax], esi
	add	eax, 4
	dec	ecx
	jne	SHORT $L18990
	pop	esi
$L18992:

; 258  : 	}

	ret	0
??$_Uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ENDP ; std::_Uninitialized_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z PROC NEAR ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT
; __First$ = ecx
; __Last$ = eax

; 127  : 	return (_Uninit_copy(_First, _Last, _Dest, _Al,
; 128  : 		_Ptr_cat(_First, _Dest)));

	sub	eax, ecx
	push	esi
	sar	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR __Dest$[esp]
	push	esi
	push	ecx
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
	add	eax, esi
	pop	esi

; 129  : 	}

	ret	0
??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT
??0const_iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBV12@@Z PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Off$ = edx
; __Pdeque$ = ecx

; 102  : 			{	// construct with offset _Off in *_Pdeque
; 103  : 			_Mycont = _Pdeque;

	mov	DWORD PTR [eax], ecx

; 104  : 			_Myoff = _Off;

	mov	DWORD PTR [eax+4], edx

; 105  : 			}

	ret	0
??0const_iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBV12@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Yiterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
??Yiterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator+=, COMDAT
; _this$ = eax
; __Off$ = ecx

; 283  : 			this->_Myoff += _Off;

	add	DWORD PTR [eax+4], ecx

; 284  : 			return (*this);
; 285  : 			}

	ret	0
??Yiterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV012@@Z
_TEXT	SEGMENT
??Gconst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV012@@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator-, COMDAT
; _this$ = edx
; __Right$ = eax

; 172  : 			return (_Right._Myoff <= _Myoff ? _Myoff - _Right._Myoff
; 173  : 				: -(difference_type)(_Right._Myoff - _Myoff));

	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, ecx

; 174  : 			}

	ret	0
??Gconst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABV012@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::const_iterator, COMDAT
; _this$ = eax

; 96   : 			{	// construct with null deque pointer
; 97   : 			_Mycont = 0;

	mov	DWORD PTR [eax], 0

; 98   : 			_Myoff = 0;

	mov	DWORD PTR [eax+4], 0

; 99   : 			}

	ret	0
??0const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ PROC NEAR ; std::allocator<Json::Value *>::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 1073741823				; 3fffffffH

; 159  : 		}

	ret	0
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ENDP	; std::allocator<Json::Value *>::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??Giterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z
_TEXT	SEGMENT
$T19030 = -8						; size = 8
??Giterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator-, COMDAT
; _this$ = eax
; __Right$ = edx

; 305  : 			{	// return difference of iterators

	sub	esp, 8

; 306  : 			return ((const_iterator)*this - _Right);

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T19030[esp+8], ecx
	mov	ecx, DWORD PTR [edx+4]
	sub	eax, ecx

; 307  : 			}

	add	esp, 8
	ret	0
??Giterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEHABVconst_iterator@12@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Yiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
??Yiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator+=, COMDAT
; _this$ = eax
; __Off$ = ecx

; 283  : 			this->_Myoff += _Off;

	add	DWORD PTR [eax+4], ecx

; 284  : 			return (*this);
; 285  : 			}

	ret	0
??Yiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::iterator, COMDAT
; _this$ = eax

; 236  : 		iterator()

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0

; 237  : 			{	// construct with null deque pointer
; 238  : 			}

	ret	0
??0iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::const_iterator::operator*, COMDAT
; _this$ = edx

; 109  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	ecx, DWORD PTR [edx+4]

; 110  : 			size_type _Off = _Myoff - _Block * _DEQUESIZ;
; 111  : 			if (_Mycont->_Mapsize <= _Block)

	mov	edx, DWORD PTR [edx]
	mov	eax, ecx
	shr	eax, 2
	push	esi
	lea	esi, DWORD PTR [eax*4]
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L14667

; 112  : 				_Block -= _Mycont->_Mapsize;

	sub	eax, esi
$L14667:

; 113  : 			return ((_Mycont->_Map)[_Block][_Off]);

	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ecx*4]
	pop	esi

; 114  : 			}

	ret	0
??Dconst_iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEABQAVValue@Json@@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::const_iterator::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Ziterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
??Ziterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator-=, COMDAT
; _this$ = eax
; __Off$ = ecx

; 295  : 			return (*this += -_Off);

	sub	DWORD PTR [eax+4], ecx

; 296  : 			}

	ret	0
??Ziterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator-=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT
??0iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBV12@@Z PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::iterator, COMDAT
; _this$ = eax
; __Off$ = edx
; __Pdeque$ = ecx

; 242  : 			{	// construct with offset _Off in *_Pdeque

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 243  : 			}

	ret	0
??0iterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@IPBV12@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ PROC NEAR ; std::allocator<Json::Reader::ErrorInfo>::max_size, COMDAT

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

	mov	eax, 97612893				; 05d1745dH

; 159  : 		}

	ret	0
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z PROC NEAR ; std::allocator<Json::Value * *>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 138  : 		}

	ret	0
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	ret	0
??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Json::Value *>::allocator<Json::Value *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z PROC NEAR ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::_Deque_map<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = eax

; 22   : 		}

	ret	4
??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::_Deque_map<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size, COMDAT

; 497  : 		return (this->_Alval.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 498  : 		}

	ret	0
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC NEAR		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 157  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
; 158  : 		return (0 < _Count ? _Count : 1);

	or	eax, -1

; 159  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC NEAR	; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 137  : 		return (_Allocate(_Count, (pointer)0));

	mov	eax, DWORD PTR __Count$[esp-4]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 138  : 		}

	ret	4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??Hiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
??Hiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator+, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax
; __Off$ = esi

; 289  : 			iterator _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]

; 290  : 			return (_Tmp += _Off);

	add	ecx, esi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 291  : 			}

	ret	0
??Hiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator+
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Giterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
??Giterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator-, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax
; __Off$ = esi

; 300  : 			iterator _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]

; 301  : 			return (_Tmp -= _Off);

	sub	ecx, esi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 302  : 			}

	ret	0
??Giterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
??Diterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEAAPAVValue@Json@@XZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator*, COMDAT
; _this$ = edx

; 247  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx]
	mov	eax, ecx
	shr	eax, 2
	push	esi
	lea	esi, DWORD PTR [eax*4]
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L19128
	sub	eax, esi
$L19128:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ecx*4]
	pop	esi

; 248  : 			}

	ret	0
??Diterator@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEAAPAVValue@Json@@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::iterator::operator*
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z PROC NEAR ; std::allocator<Json::Reader::ErrorInfo *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

	ret	0
?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z PROC NEAR ; std::allocator<Json::Reader::ErrorInfo *>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 138  : 		}

	ret	0
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z PROC NEAR ; std::allocator<Json::Reader::ErrorInfo *>::deallocate, COMDAT
; __Ptr$ = eax

; 132  : 		operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 133  : 		}

	ret	0
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z PROC NEAR ; std::allocator<Json::Reader::ErrorInfo>::deallocate, COMDAT
; __Ptr$ = eax

; 132  : 		operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 133  : 		}

	ret	0
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z PROC NEAR ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = eax

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	ret	0
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC NEAR ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = eax

; 22   : 		}

	ret	4
??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty, COMDAT
; _this$ = ecx

; 502  : 		return (_Mysize == 0);

	mov	edx, DWORD PTR [ecx+16]
	xor	eax, eax
	test	edx, edx
	sete	al

; 503  : 		}

	ret	0
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT

; 497  : 		return (this->_Alval.max_size());

	mov	eax, 97612893				; 05d1745dH

; 498  : 		}

	ret	0
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z PROC NEAR ; std::allocator<Json::Value * *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

	ret	0
?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value * *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z PROC NEAR ; std::allocator<Json::Value * *>::deallocate, COMDAT
; __Ptr$ = eax

; 132  : 		operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 133  : 		}

	ret	0
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z PROC NEAR ; std::allocator<Json::Value *>::destroy, COMDAT

; 152  : 		_Destroy(_Ptr);
; 153  : 		}

	ret	0
?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value *>::destroy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z PROC NEAR ; std::allocator<Json::Value *>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

	lea	ecx, DWORD PTR [eax*4]
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 138  : 		}

	ret	0
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z PROC NEAR ; std::allocator<Json::Value *>::deallocate, COMDAT
; __Ptr$ = eax

; 132  : 		operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 133  : 		}

	ret	0
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::deallocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ PROC NEAR	; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	ret	0
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ ENDP		; std::allocator<Json::Value *>::allocator<Json::Value *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z PROC NEAR ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = eax

; 41   : 		}

	ret	4
??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 449  : 		return (iterator(_Myoff + _Mysize, this));

	mov	ecx, DWORD PTR [edx+16]
	add	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 450  : 		}

	ret	0
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC NEAR	; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 132  : 		operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[esp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx

; 133  : 		}

	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $L19235
	mov	eax, DWORD PTR [ecx+4]

; 1533 : 		}

	ret	0
$L19235:

; 1532 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 1533 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 1494 : 		{	// test if _Ptr points inside string

	push	esi

; 1495 : 		if (_Ptr < _Myptr() || _Myptr() + _Mysize <= _Ptr)

	mov	esi, DWORD PTR [ecx+24]
	cmp	esi, 16					; 00000010H
	push	edi
	lea	eax, DWORD PTR [ecx+4]
	jb	SHORT $L19244
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $L19245
$L19244:
	mov	edx, eax
$L19245:
	mov	edi, DWORD PTR __Ptr$[esp+4]
	cmp	edi, edx
	jb	SHORT $L14303
	cmp	esi, 16					; 00000010H
	jb	SHORT $L19252
	mov	eax, DWORD PTR [eax]
$L19252:
	mov	ecx, DWORD PTR [ecx+20]
	add	ecx, eax
	cmp	ecx, edi
	jbe	SHORT $L14303
	pop	edi

; 1497 : 		else
; 1498 : 			return (true);

	mov	al, 1
	pop	esi

; 1499 : 		}

	ret	4
$L14303:
	pop	edi

; 1496 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 1499 : 		}

	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1114 : 		size_type _Num = _Mybase::_Alval.max_size();
; 1115 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1116 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??8const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator==, COMDAT
; _this$ = ecx
; __Right$ = eax

; 183  : 			return (_Mycont == _Right._Mycont && _Myoff == _Right._Myoff);

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $L19270
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L19270
	mov	eax, 1

; 184  : 			}

	ret	0
$L19270:

; 183  : 			return (_Mycont == _Right._Mycont && _Myoff == _Right._Myoff);

	xor	eax, eax

; 184  : 			}

	ret	0
??8const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator==
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT
??0const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBV12@@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::const_iterator, COMDAT
; _this$ = eax
; __Off$ = edx
; __Pdeque$ = ecx

; 102  : 			{	// construct with offset _Off in *_Pdeque
; 103  : 			_Mycont = _Pdeque;

	mov	DWORD PTR [eax], ecx

; 104  : 			_Myoff = _Off;

	mov	DWORD PTR [eax+4], edx

; 105  : 			}

	ret	0
??0const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBV12@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::const_iterator
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z PROC NEAR ; std::allocator<Json::Reader::ErrorInfo>::allocate, COMDAT
; __Count$ = eax

; 137  : 		return (_Allocate(_Count, (pointer)0));

	imul	eax, 44					; 0000002cH
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 138  : 		}

	ret	0
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocate
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ PROC NEAR ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = eax

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	ret	0
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC NEAR ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = eax

; 41   : 		}

	ret	4
??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back, COMDAT
; _this$ = ecx

; 546  : 		return (*(end() - 1));

	mov	eax, DWORD PTR [ecx+16]
	push	esi
	add	eax, DWORD PTR [ecx+12]
	dec	eax
	mov	edx, ecx
	mov	ecx, eax
	shr	eax, 2
	lea	esi, DWORD PTR [eax*4]
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L19352
	sub	eax, esi
$L19352:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ecx*4]
	pop	esi

; 547  : 		}

	ret	0
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty, COMDAT
; _this$ = ecx

; 502  : 		return (_Mysize == 0);

	mov	edx, DWORD PTR [ecx+16]
	xor	eax, eax
	test	edx, edx
	sete	al

; 503  : 		}

	ret	0
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = eax

; 327  : 		{	// construct empty deque

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 328  : 		}

	ret	0
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC NEAR		; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 115  : 	allocator(const allocator<_Ty>&)

	mov	eax, ecx

; 116  : 		{	// construct by copying (do nothing)
; 117  : 		}

	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC NEAR			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 111  : 	allocator()

	mov	eax, ecx

; 112  : 		{	// construct default allocator (do nothing)
; 113  : 		}

	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 1
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z PROC NEAR ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >, COMDAT
; _this$ = ecx

; 34   : 		{	// construct allocator from _Al

	mov	eax, ecx

; 35   : 		}

	ret	4
??0?$_String_val@DV?$allocator@D@std@@@std@@IAE@V?$allocator@D@1@@Z ENDP ; std::_String_val<char,std::allocator<char> >::_String_val<char,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr, COMDAT
; _this$ = ecx

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	jb	SHORT $L19408
	mov	eax, DWORD PTR [ecx+4]

; 1538 : 		}

	ret	0
$L19408:

; 1537 : 		return (_BUF_SIZE <= _Myres ? _Bx._Ptr : _Bx._Buf);

	lea	eax, DWORD PTR [ecx+4]

; 1538 : 		}

	ret	0
?_Myptr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Myptr
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
??9const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV012@@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator!=, COMDAT
; _this$ = ecx
; __Right$ = eax

; 188  : 			return (!(*this == _Right));

	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR [eax]
	jne	SHORT $L19418
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $L19418
	mov	eax, 1
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 189  : 			}

	ret	0

; 188  : 			return (!(*this == _Right));

$L19418:
	xor	eax, eax
	xor	edx, edx
	test	al, al
	sete	dl
	mov	al, dl

; 189  : 			}

	ret	0
??9const_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NABV012@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator!=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT
??Econst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator++, COMDAT
; _this$ = eax

; 123  : 			++_Myoff;

	inc	DWORD PTR [eax+4]

; 124  : 			return (*this);
; 125  : 			}

	ret	0
??Econst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator++
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Dconst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
??Dconst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator*, COMDAT
; _this$ = edx

; 109  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	ecx, DWORD PTR [edx+4]

; 110  : 			size_type _Off = _Myoff - _Block * _DEQUESIZ;
; 111  : 			if (_Mycont->_Mapsize <= _Block)

	mov	edx, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [edx+8]
	mov	eax, ecx
	sub	eax, ecx
	cmp	esi, ecx
	ja	SHORT $L13727

; 112  : 				_Block -= _Mycont->_Mapsize;

	sub	ecx, esi
$L13727:

; 113  : 			return ((_Mycont->_Map)[_Block][_Off]);

	mov	edx, DWORD PTR [edx+4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [edx+ecx*4]
	pop	esi

; 114  : 			}

	ret	0
??Dconst_iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::const_iterator::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size, COMDAT
; _this$ = eax

; 492  : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+16]

; 493  : 		}

	ret	0
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 454  : 		return (const_iterator(_Myoff + _Mysize, this));

	mov	ecx, DWORD PTR [edx+16]
	add	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 455  : 		}

	ret	0
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ
_TEXT	SEGMENT
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 444  : 		return (const_iterator(_Myoff, this));

	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 445  : 		}

	ret	0
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AVconst_iterator@12@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = eax

; 327  : 		{	// construct empty deque

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 328  : 		}

	ret	0
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stack
_TEXT	ENDS
;	COMDAT ?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC NEAR ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top, COMDAT
; _this$ = ecx

; 43   : 		return (c.back());

	mov	eax, DWORD PTR [ecx+16]
	push	esi
	add	eax, DWORD PTR [ecx+12]
	dec	eax
	mov	edx, ecx
	mov	ecx, eax
	shr	eax, 2
	lea	esi, DWORD PTR [eax*4]
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L19552
	sub	eax, esi
$L19552:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	lea	eax, DWORD PTR [eax+ecx*4]
	pop	esi

; 44   : 		}

	ret	0
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ PROC NEAR ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty, COMDAT
; _this$ = ecx

; 33   : 		return (c.empty());

	mov	edx, DWORD PTR [ecx+16]
	xor	eax, eax
	test	edx, edx
	sete	al

; 34   : 		}

	ret	0
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1148 : 		return (_Mysize == 0);

	mov	edx, DWORD PTR [ecx+20]
	xor	eax, eax
	test	edx, edx
	sete	al

; 1149 : 		}

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1109 : 		return (_Mysize);

	mov	eax, DWORD PTR [ecx+20]

; 1110 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = eax

; 1104 : 		return (_Mysize);

	mov	eax, DWORD PTR [eax+20]

; 1105 : 		}

	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = eax

; 1094 : 		return (_Myptr());

	cmp	DWORD PTR [eax+24], 16			; 00000010H
	jb	SHORT $L19577
	mov	eax, DWORD PTR [eax+4]

; 1095 : 		}

	ret	0

; 1094 : 		return (_Myptr());

$L19577:
	add	eax, 4

; 1095 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z
_TEXT	SEGMENT
_column$ = 8						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z PROC NEAR ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ebx
; _location$ = eax
; _line$ = ecx

; 660  : {

	push	esi
	push	edi
	mov	edi, eax

; 661  :    Location current = begin_;

	mov	eax, DWORD PTR [ebx+68]

; 662  :    Location lastLineStart = current;
; 663  :    line = 0;
; 664  :    while ( current < location  &&  current != end_ )

	cmp	eax, edi
	mov	esi, eax
	mov	DWORD PTR [ecx], 0
	jae	SHORT $L13229
$L13228:
	cmp	eax, DWORD PTR [ebx+72]
	je	SHORT $L13229

; 665  :    {
; 666  :       Char c = *current++;

	mov	dl, BYTE PTR [eax]
	inc	eax

; 667  :       if ( c == '\r' )

	cmp	dl, 13					; 0000000dH
	jne	SHORT $L13231

; 668  :       {
; 669  :          if ( *current == '\n' )

	cmp	BYTE PTR [eax], 10			; 0000000aH
	jne	SHORT $L13232

; 670  :             ++current;

	inc	eax

; 671  :          lastLineStart = current;
; 672  :          ++line;
; 673  :       }
; 674  :       else if ( c == '\n' )

	jmp	SHORT $L13232
$L13231:
	cmp	dl, 10					; 0000000aH
	jne	SHORT $L13234
$L13232:

; 675  :       {
; 676  :          lastLineStart = current;
; 677  :          ++line;

	mov	edx, DWORD PTR [ecx]
	inc	edx
	mov	esi, eax
	mov	DWORD PTR [ecx], edx
$L13234:

; 662  :    Location lastLineStart = current;
; 663  :    line = 0;
; 664  :    while ( current < location  &&  current != end_ )

	cmp	eax, edi
	jb	SHORT $L13228
$L13229:

; 678  :       }
; 679  :    }
; 680  :    // column & line start at 1
; 681  :    column = int(location - lastLineStart) + 1;

	mov	eax, DWORD PTR _column$[esp+4]
	sub	edi, esi
	inc	edi
	mov	DWORD PTR [eax], edi

; 682  :    ++line;

	mov	eax, DWORD PTR [ecx]
	inc	eax
	pop	edi
	mov	DWORD PTR [ecx], eax
	pop	esi

; 683  : }

	ret	4
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
PUBLIC	?getNextChar@Reader@Json@@AAEDXZ		; Json::Reader::getNextChar
; Function compile flags: /Ogtpy
;	COMDAT ?getNextChar@Reader@Json@@AAEDXZ
_TEXT	SEGMENT
?getNextChar@Reader@Json@@AAEDXZ PROC NEAR		; Json::Reader::getNextChar, COMDAT
; _this$ = edx

; 650  :    if ( current_ == end_ )

	mov	ecx, DWORD PTR [edx+76]
	cmp	ecx, DWORD PTR [edx+72]
	jne	SHORT $L13218

; 651  :       return 0;

	xor	al, al

; 653  : }

	ret	0
$L13218:

; 652  :    return *current_++;

	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx+76], ecx

; 653  : }

	ret	0
?getNextChar@Reader@Json@@AAEDXZ ENDP			; Json::Reader::getNextChar
_TEXT	ENDS
PUBLIC	?currentValue@Reader@Json@@AAEAAVValue@2@XZ	; Json::Reader::currentValue
; Function compile flags: /Ogtpy
;	COMDAT ?currentValue@Reader@Json@@AAEAAVValue@2@XZ
_TEXT	SEGMENT
?currentValue@Reader@Json@@AAEAAVValue@2@XZ PROC NEAR	; Json::Reader::currentValue, COMDAT
; _this$ = ecx

; 643  :    return *(nodes_.top());

	mov	eax, DWORD PTR [ecx+16]
	push	esi
	add	eax, DWORD PTR [ecx+12]
	dec	eax
	mov	edx, ecx
	mov	ecx, eax
	shr	eax, 2
	lea	esi, DWORD PTR [eax*4]
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L19686
	sub	eax, esi
$L19686:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4]
	pop	esi

; 644  : }

	ret	0
?currentValue@Reader@Json@@AAEAAVValue@2@XZ ENDP	; Json::Reader::currentValue
_TEXT	ENDS
PUBLIC	?readString@Reader@Json@@AAE_NXZ		; Json::Reader::readString
; Function compile flags: /Ogtpy
;	COMDAT ?readString@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readString@Reader@Json@@AAE_NXZ PROC NEAR		; Json::Reader::readString, COMDAT
; _this$ = edx

; 346  :    Char c = 0;
; 347  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [edx+76]
	push	esi
	mov	esi, DWORD PTR [edx+72]
	xor	cl, cl
	cmp	eax, esi
	je	SHORT $L19702
	npad	3
$L12972:

; 348  :    {
; 349  :       c = getNextChar();

	mov	eax, DWORD PTR [edx+76]
	cmp	eax, esi
	jne	SHORT $L19696
	xor	cl, cl
	jmp	SHORT $L12976
$L19696:
	mov	cl, BYTE PTR [eax]
	inc	eax

; 350  :       if ( c == '\\' )

	cmp	cl, 92					; 0000005cH
	mov	DWORD PTR [edx+76], eax
	jne	SHORT $L12974

; 351  :          getNextChar();

	cmp	eax, esi
	je	SHORT $L12976
	inc	eax
	mov	DWORD PTR [edx+76], eax

; 352  :       else if ( c == '"' )

	jmp	SHORT $L12976
$L12974:
	cmp	cl, 34					; 00000022H
	je	SHORT $L19703
$L12976:

; 346  :    Char c = 0;
; 347  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [edx+76]
	cmp	eax, DWORD PTR [edx+72]
	jne	SHORT $L12972
$L19703:
$L19702:

; 353  :          break;
; 354  :    }
; 355  :    return c == '"';

	xor	eax, eax
	cmp	cl, 34					; 00000022H
	sete	al
	pop	esi

; 356  : }

	ret	0
?readString@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readString
_TEXT	ENDS
PUBLIC	?readCppStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCppStyleComment
; Function compile flags: /Ogtpy
;	COMDAT ?readCppStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readCppStyleComment@Reader@Json@@AAE_NXZ PROC NEAR	; Json::Reader::readCppStyleComment, COMDAT
; _this$ = edx

; 321  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [edx+76]
	push	esi
	mov	esi, DWORD PTR [edx+72]
	cmp	eax, esi
	je	SHORT $L19717
	npad	5
$L12954:

; 322  :    {
; 323  :       Char c = getNextChar();

	mov	eax, DWORD PTR [edx+76]
	cmp	eax, esi
	je	SHORT $L19714
	mov	cl, BYTE PTR [eax]
	inc	eax

; 324  :       if (  c == '\r'  ||  c == '\n' )

	cmp	cl, 13					; 0000000dH
	mov	DWORD PTR [edx+76], eax
	je	SHORT $L19717
	cmp	cl, 10					; 0000000aH
	je	SHORT $L19717
$L19714:

; 321  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [edx+76]
	cmp	eax, DWORD PTR [edx+72]
	jne	SHORT $L12954
$L19717:

; 325  :          break;
; 326  :    }
; 327  :    return true;

	mov	al, 1
	pop	esi

; 328  : }

	ret	0
?readCppStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCppStyleComment
_TEXT	ENDS
PUBLIC	?readCStyleComment@Reader@Json@@AAE_NXZ		; Json::Reader::readCStyleComment
; Function compile flags: /Ogtpy
;	COMDAT ?readCStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readCStyleComment@Reader@Json@@AAE_NXZ PROC NEAR	; Json::Reader::readCStyleComment, COMDAT
; _this$ = ecx

; 308  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [ecx+76]
	push	esi
	mov	esi, DWORD PTR [ecx+72]
	cmp	eax, esi
	je	SHORT $L19731
	npad	5
$L12946:

; 309  :    {
; 310  :       Char c = getNextChar();

	mov	eax, DWORD PTR [ecx+76]
	cmp	eax, esi
	je	SHORT $L12949
	mov	dl, BYTE PTR [eax]
	inc	eax

; 311  :       if ( c == '*'  &&  *current_ == '/' )

	cmp	dl, 42					; 0000002aH
	mov	DWORD PTR [ecx+76], eax
	jne	SHORT $L12949
	cmp	BYTE PTR [eax], 47			; 0000002fH
	je	SHORT $L19731
$L12949:

; 308  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [ecx+76]
	cmp	eax, DWORD PTR [ecx+72]
	jne	SHORT $L12946
$L19731:

; 312  :          break;
; 313  :    }
; 314  :    return getNextChar() == '/';

	mov	eax, DWORD PTR [ecx+76]
	cmp	eax, esi
	pop	esi
	jne	SHORT $L19728
	xor	dl, dl
	xor	eax, eax
	cmp	dl, 47					; 0000002fH
	sete	al

; 315  : }

	ret	0

; 312  :          break;
; 313  :    }
; 314  :    return getNextChar() == '/';

$L19728:
	mov	dl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [ecx+76], eax
	xor	eax, eax
	cmp	dl, 47					; 0000002fH
	sete	al

; 315  : }

	ret	0
?readCStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCStyleComment
_TEXT	ENDS
PUBLIC	?match@Reader@Json@@AAE_NPBDH@Z			; Json::Reader::match
; Function compile flags: /Ogtpy
;	COMDAT ?match@Reader@Json@@AAE_NPBDH@Z
_TEXT	SEGMENT
_pattern$ = 8						; size = 4
?match@Reader@Json@@AAE_NPBDH@Z PROC NEAR		; Json::Reader::match, COMDAT
; _this$ = edi
; _patternLength$ = esi

; 246  :    if ( end_ - current_ < patternLength )

	mov	ecx, DWORD PTR [edi+76]
	mov	eax, DWORD PTR [edi+72]
	sub	eax, ecx
	cmp	eax, esi
	push	ebp
	mov	ebp, DWORD PTR _pattern$[esp]
	jge	SHORT $L12824

; 247  :       return false;

	xor	al, al
	pop	ebp

; 254  : }

	ret	4
$L12824:

; 248  :    int index = patternLength;
; 249  :    while ( index-- )

	test	esi, esi
	push	ebx
	mov	eax, esi
	je	SHORT $L19737
	npad	2
$L12827:

; 250  :       if ( current_[index] != pattern[index] )

	mov	dl, BYTE PTR [ecx+eax-1]
	mov	bl, BYTE PTR [eax+ebp-1]
	dec	eax
	cmp	dl, bl
	jne	SHORT $L19736

; 248  :    int index = patternLength;
; 249  :    while ( index-- )

	test	eax, eax
	jne	SHORT $L12827
$L19737:

; 252  :    current_ += patternLength;

	add	ecx, esi
	pop	ebx
	mov	DWORD PTR [edi+76], ecx

; 253  :    return true;

	mov	al, 1
	pop	ebp

; 254  : }

	ret	4
$L19736:
	pop	ebx

; 251  :          return false;

	xor	al, al
	pop	ebp

; 254  : }

	ret	4
?match@Reader@Json@@AAE_NPBDH@Z ENDP			; Json::Reader::match
_TEXT	ENDS
PUBLIC	?skipSpaces@Reader@Json@@AAEXXZ			; Json::Reader::skipSpaces
; Function compile flags: /Ogtpy
;	COMDAT ?skipSpaces@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
?skipSpaces@Reader@Json@@AAEXXZ PROC NEAR		; Json::Reader::skipSpaces, COMDAT
; _this$ = edx

; 231  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [edx+76]
	cmp	eax, DWORD PTR [edx+72]
	je	SHORT $L12816
$L12813:

; 232  :    {
; 233  :       Char c = *current_;

	mov	ecx, DWORD PTR [edx+76]
	mov	al, BYTE PTR [ecx]

; 234  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

	cmp	al, 32					; 00000020H
	je	SHORT $L12817
	cmp	al, 9
	je	SHORT $L12817
	cmp	al, 13					; 0000000dH
	je	SHORT $L12817
	cmp	al, 10					; 0000000aH
	jne	SHORT $L12816
$L12817:

; 235  :          ++current_;

	inc	ecx
	mov	DWORD PTR [edx+76], ecx
	cmp	ecx, DWORD PTR [edx+72]
	jne	SHORT $L12813
$L12816:

; 236  :       else
; 237  :          break;
; 238  :    }
; 239  : }

	ret	0
?skipSpaces@Reader@Json@@AAEXXZ ENDP			; Json::Reader::skipSpaces
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?containsNewLine@Json@@YA_NPBD0@Z
_TEXT	SEGMENT
?containsNewLine@Json@@YA_NPBD0@Z PROC NEAR		; Json::containsNewLine, COMDAT
; _begin$ = ecx
; _end$ = edx

; 30   :    for ( ;begin < end; ++begin )

	cmp	ecx, edx
	jae	SHORT $L12709
$L12707:

; 31   :       if ( *begin == '\n'  ||  *begin == '\r' )

	mov	al, BYTE PTR [ecx]
	cmp	al, 10					; 0000000aH
	je	SHORT $L19747
	cmp	al, 13					; 0000000dH
	je	SHORT $L19747
	inc	ecx
	cmp	ecx, edx
	jb	SHORT $L12707
$L12709:

; 33   :    return false;

	xor	al, al

; 34   : }

	ret	0
$L19747:

; 32   :          return true;

	mov	al, 1

; 34   : }

	ret	0
?containsNewLine@Json@@YA_NPBD0@Z ENDP			; Json::containsNewLine
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?in@Json@@YA_NDDDDDD@Z
_TEXT	SEGMENT
_c2$ = 8						; size = 1
_c3$ = 12						; size = 1
_c4$ = 16						; size = 1
_c5$ = 20						; size = 1
?in@Json@@YA_NDDDDDD@Z PROC NEAR			; Json::in, COMDAT
; _c$ = eax
; _c1$ = ecx

; 22   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

	cmp	al, cl
	je	SHORT $L19752
	cmp	al, BYTE PTR _c2$[esp-4]
	je	SHORT $L19752
	cmp	al, BYTE PTR _c3$[esp-4]
	je	SHORT $L19752
	cmp	al, BYTE PTR _c4$[esp-4]
	je	SHORT $L19752
	cmp	al, BYTE PTR _c5$[esp-4]
	je	SHORT $L19752
	xor	eax, eax

; 23   : }

	ret	0
$L19752:

; 22   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

	mov	eax, 1

; 23   : }

	ret	0
?in@Json@@YA_NDDDDDD@Z ENDP				; Json::in
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?in@Json@@YA_NDDDDD@Z
_TEXT	SEGMENT
_c2$ = 8						; size = 1
_c3$ = 12						; size = 1
_c4$ = 16						; size = 1
?in@Json@@YA_NDDDDD@Z PROC NEAR				; Json::in, COMDAT
; _c$ = eax
; _c1$ = ecx

; 16   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

	cmp	al, cl
	je	SHORT $L19757
	cmp	al, BYTE PTR _c2$[esp-4]
	je	SHORT $L19757
	cmp	al, BYTE PTR _c3$[esp-4]
	je	SHORT $L19757
	cmp	al, BYTE PTR _c4$[esp-4]
	je	SHORT $L19757
	xor	eax, eax

; 17   : }

	ret	0
$L19757:

; 16   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

	mov	eax, 1

; 17   : }

	ret	0
?in@Json@@YA_NDDDDD@Z ENDP				; Json::in
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@logic_error@std@@UBEPBDXZ PROC NEAR		; std::logic_error::what, COMDAT
; _this$ = ecx

; 27   : 		return (_Str.c_str());

	cmp	DWORD PTR [ecx+36], 16			; 00000010H
	jb	SHORT $L19773
	mov	eax, DWORD PTR [ecx+16]

; 28   : 		}

	ret	0

; 27   : 		return (_Str.c_str());

$L19773:
	lea	eax, DWORD PTR [ecx+16]

; 28   : 		}

	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT
; __First$ = edx
; __Count$ = ecx
; __Ch$ = eax

; 375  : 		return ((_Elem *)::memset(_First, _Ch, _Count));

	movsx	eax, al
	push	ebx
	mov	bl, al
	mov	bh, bl
	push	esi
	push	edi
	mov	edi, edx
	mov	edx, ecx
	mov	esi, edi
	shr	ecx, 2
	mov	eax, ebx
	shl	eax, 16					; 00000010H
	mov	ax, bx
	rep stosd
	mov	ecx, edx
	and	ecx, 3
	rep stosb
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 376  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::move, COMDAT

; 370  : 		return ((_Elem *)::memmove(_First1, _First2, _Count));

	jmp	_memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC NEAR	; std::char_traits<char>::copy, COMDAT

; 358  : 		return ((_Elem *)::memcpy(_First1, _First2, _Count));

	mov	ecx, DWORD PTR __Count$[esp-4]
	push	esi
	mov	esi, DWORD PTR __First2$[esp]
	push	edi
	mov	edi, DWORD PTR __First1$[esp+4]
	mov	eax, ecx
	mov	edx, edi
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb
	pop	edi
	mov	eax, edx
	pop	esi

; 359  : 		}

	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC NEAR		; std::char_traits<char>::length, COMDAT

; 352  : 		return (::strlen(_First));

	mov	eax, DWORD PTR __First$[esp-4]
	lea	edx, DWORD PTR [eax+1]
$L19790:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $L19790
	sub	eax, edx

; 353  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC NEAR	; std::char_traits<char>::assign, COMDAT

; 331  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[esp-4]
	mov	cl, BYTE PTR [eax]
	mov	edx, DWORD PTR __Left$[esp-4]
	mov	BYTE PTR [edx], cl

; 332  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC NEAR					; operator delete, COMDAT

; 69   : 	}

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC NEAR				; operator new, COMDAT
; __Where$ = eax

; 64   : 	return (_Where);
; 65   : 	}

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
;	COMDAT ??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z
_TEXT	SEGMENT
??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z PROC NEAR ; std::_Construct<Json::Value *,Json::Value *>, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

	test	eax, eax
	je	SHORT $L21171
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$L21171:

; 43   : 	}

	ret	0
??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z ENDP ; std::_Construct<Json::Value *,Json::Value *>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??Ziterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@H@Z
_TEXT	SEGMENT
??Ziterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@H@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator-=, COMDAT
; _this$ = eax
; __Off$ = ecx

; 295  : 			return (*this += -_Off);

	sub	DWORD PTR [eax+4], ecx

; 296  : 			}

	ret	0
??Ziterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV012@H@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator-=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Diterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
??Diterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator*, COMDAT
; _this$ = edx

; 247  : 			return ((reference)**(const_iterator *)this);

	mov	ecx, DWORD PTR [edx+4]
	mov	edx, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [edx+8]
	mov	eax, ecx
	sub	eax, ecx
	cmp	esi, ecx
	ja	SHORT $L21189
	sub	ecx, esi
$L21189:
	mov	edx, DWORD PTR [edx+4]
	imul	eax, 44					; 0000002cH
	add	eax, DWORD PTR [edx+ecx*4]
	pop	esi

; 248  : 			}

	ret	0
??Diterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator*
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Aiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@H@Z
_TEXT	SEGMENT
??Aiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@H@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator[], COMDAT
; _this$ = eax
; __Off$ = edx

; 311  : 			return (*(*this + _Off));

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	add	eax, edx
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, eax
	ja	SHORT $L21218
	mov	ecx, DWORD PTR [ecx+4]
	sub	eax, edx
	mov	eax, DWORD PTR [ecx+eax*4]

; 312  : 			}

	ret	0
$L21218:

; 311  : 			return (*(*this + _Off));

	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]

; 312  : 			}

	ret	0
??Aiterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator[]
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Giterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV012@H@Z
_TEXT	SEGMENT
??Giterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV012@H@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator-, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax
; __Off$ = esi

; 300  : 			iterator _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]

; 301  : 			return (_Tmp -= _Off);

	sub	ecx, esi
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 302  : 			}

	ret	0
??Giterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV012@H@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::operator-
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBV12@@Z
_TEXT	SEGMENT
??0iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBV12@@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::iterator, COMDAT
; _this$ = eax
; __Off$ = edx
; __Pdeque$ = ecx

; 242  : 			{	// construct with offset _Off in *_Pdeque

	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 243  : 			}

	ret	0
??0iterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@IPBV12@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator::iterator
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = eax

; 449  : 		return (iterator(_Myoff + _Mysize, this));

	mov	ecx, DWORD PTR [edx+16]
	add	ecx, DWORD PTR [edx+12]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 450  : 		}

	ret	0
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@XZ
_TEXT	SEGMENT
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx
; ___$ReturnUdt$ = eax

; 439  : 		return (iterator(_Myoff, this));

	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx

; 440  : 		}

	ret	0
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z
_TEXT	SEGMENT
?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z PROC NEAR ; std::allocator<Json::Value *>::construct, COMDAT
; __Ptr$ = eax
; __Val$ = ecx

; 147  : 		_Construct(_Ptr, _Val);

	test	eax, eax
	je	SHORT $L21272
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$L21272:

; 148  : 		}

	ret	0
?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z ENDP ; std::allocator<Json::Value *>::construct
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back, COMDAT
; _this$ = ecx

; 599  : 		if (!empty())

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	je	SHORT $L14118

; 600  : 			{	// something to erase, do it
; 601  : 			size_type _Newoff = _Mysize + _Myoff - 1;
; 602  : 			size_type _Block = _Newoff / _DEQUESIZ;
; 603  : 			if (_Mapsize <= _Block)
; 604  : 				_Block -= _Mapsize;
; 605  : 			this->_Alval.destroy(_Map[_Block] + _Newoff % _DEQUESIZ);
; 606  : 			if (--_Mysize == 0)

	dec	eax
	mov	DWORD PTR [ecx+16], eax
	jne	SHORT $L14118

; 607  : 				_Myoff = 0;

	mov	DWORD PTR [ecx+12], 0
$L14118:

; 608  : 			}
; 609  : 		}

	ret	0
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

	cmp	DWORD PTR [ecx+24], 16			; 00000010H
	mov	eax, DWORD PTR __Newsize$[esp-4]
	mov	DWORD PTR [ecx+20], eax
	jb	SHORT $L21291
	mov	ecx, DWORD PTR [ecx+4]
	mov	BYTE PTR [ecx+eax], 0

; 1476 : 		}

	ret	4

; 1475 : 		_Traits::assign(_Myptr()[_Mysize = _Newsize], _Elem());

$L21291:
	mov	BYTE PTR [ecx+eax+4], 0

; 1476 : 		}

	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stack
_TEXT	ENDS
;	COMDAT ?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC NEAR ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop, COMDAT
; _this$ = ecx

; 58   : 		c.pop_back();

	mov	eax, DWORD PTR [ecx+16]
	test	eax, eax
	je	SHORT $L21309
	dec	eax
	mov	DWORD PTR [ecx+16], eax
	jne	SHORT $L21309
	mov	DWORD PTR [ecx+12], 0
$L21309:

; 59   : 		}

	ret	0
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
_TEXT	ENDS
PUBLIC	?readNumber@Reader@Json@@AAEXXZ			; Json::Reader::readNumber
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
;	COMDAT ?readNumber@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
?readNumber@Reader@Json@@AAEXXZ PROC NEAR		; Json::Reader::readNumber, COMDAT
; _this$ = edx

; 334  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [edx+76]
	cmp	eax, DWORD PTR [edx+72]
	je	SHORT $L21327
$L12963:

; 335  :    {
; 336  :       if ( !(*current_ >= '0'  &&  *current_ <= '9')  &&
; 337  :            !in( *current_, '.', 'e', 'E', '+', '-' ) )

	mov	ecx, DWORD PTR [edx+76]
	mov	al, BYTE PTR [ecx]
	cmp	al, 48					; 00000030H
	jl	SHORT $L12966
	cmp	al, 57					; 00000039H
	jle	SHORT $L21321
$L12966:
	cmp	al, 46					; 0000002eH
	je	SHORT $L21321
	cmp	al, 101					; 00000065H
	je	SHORT $L21321
	cmp	al, 69					; 00000045H
	je	SHORT $L21321
	cmp	al, 43					; 0000002bH
	je	SHORT $L21321
	cmp	al, 45					; 0000002dH
	jne	SHORT $L21327
$L21321:

; 338  :          break;
; 339  :       ++current_;

	inc	ecx
	mov	DWORD PTR [edx+76], ecx
	cmp	ecx, DWORD PTR [edx+72]
	jne	SHORT $L12963
$L21327:

; 340  :    }
; 341  : }

	ret	0
?readNumber@Reader@Json@@AAEXXZ ENDP			; Json::Reader::readNumber
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 792  : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp

; 793  : 		if (_Mysize < _Off)

	mov	ebp, DWORD PTR __Off$[esp]
	push	esi
	mov	esi, ecx
	cmp	DWORD PTR [esi+20], ebp
	push	edi
	jae	SHORT $L14283

; 794  : 			_String_base::_Xran();	// _Off off end

	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L14283:

; 795  : 		if (_Mysize - _Off < _Count)

	mov	eax, DWORD PTR [esi+20]
	mov	edi, DWORD PTR __Count$[esp+8]
	sub	eax, ebp
	cmp	eax, edi
	jae	SHORT $L14284

; 796  : 			_Count = _Mysize - _Off;	// trim _Count

	mov	edi, eax
$L14284:

; 797  : 		if (0 < _Count)

	test	edi, edi
	jbe	SHORT $L22684

; 798  : 			{	// move elements down
; 799  : 			_Traits::move(_Myptr() + _Off, _Myptr() + _Off + _Count,
; 800  : 				_Mysize - _Off - _Count);

	mov	ecx, DWORD PTR [esi+24]
	cmp	ecx, 16					; 00000010H
	push	ebx
	lea	ebx, DWORD PTR [esi+4]
	jb	SHORT $L22649
	mov	edx, DWORD PTR [ebx]
	jmp	SHORT $L22650
$L22649:
	mov	edx, ebx
$L22650:
	cmp	ecx, 16					; 00000010H
	jb	SHORT $L22656
	mov	ecx, DWORD PTR [ebx]
	jmp	SHORT $L22657
$L22656:
	mov	ecx, ebx
$L22657:
	sub	eax, edi

; 803  : 			}
; 804  : 		return (*this);

	add	edx, ebp
	push	eax
	add	edx, edi
	push	edx
	add	ecx, ebp
	push	ecx
	call	_memmove
	mov	eax, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [esi+24]
	sub	eax, edi
	add	esp, 12					; 0000000cH
	cmp	ecx, 16					; 00000010H
	mov	DWORD PTR [esi+20], eax
	jb	SHORT $L22679

; 801  : 			size_type _Newsize = _Mysize - _Count;
; 802  : 			_Eos(_Newsize);

	mov	ebx, DWORD PTR [ebx]
$L22679:
	mov	BYTE PTR [ebx+eax], 0
	pop	ebx
$L22684:
	pop	edi

; 803  : 			}
; 804  : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebp

; 805  : 		}

	ret	8
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy, COMDAT
; _this$ = esi

; 951  : 		while (!empty())

	mov	eax, DWORD PTR [esi+16]
	push	ebx
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $L14123
	npad	6
$L14122:

; 952  : 			pop_back();

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, ebx
	je	SHORT $L22703
	dec	eax
	cmp	eax, ebx
	mov	DWORD PTR [esi+16], eax
	jne	SHORT $L22703
	mov	DWORD PTR [esi+12], ebx
$L22703:
	cmp	DWORD PTR [esi+16], ebx
	jne	SHORT $L14122
$L14123:
	push	edi

; 953  : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	mov	edi, DWORD PTR [esi+8]
	cmp	edi, ebx
	jbe	SHORT $L14127
	npad	1
$L14126:

; 954  : 			{	// free storage for a block and destroy pointer
; 955  : 			if (*(_Map + --_Count) != 0)

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+edi*4-4]
	dec	edi
	cmp	eax, ebx
	je	SHORT $L22705

; 956  : 				this->_Alval.deallocate(*(_Map + _Count), _DEQUESIZ);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L22705:

; 953  : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	cmp	edi, ebx
	ja	SHORT $L14126
$L14127:

; 957  : 			this->_Almap.destroy(_Map + _Count);
; 958  : 			}
; 959  : 
; 960  : 		if (_Map)

	mov	eax, DWORD PTR [esi+4]
	cmp	eax, ebx
	pop	edi
	je	SHORT $L22716

; 961  : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for map

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L22716:

; 962  : 		_Mapsize = 0;

	mov	DWORD PTR [esi+8], ebx

; 963  : 		_Map = 0;

	mov	DWORD PTR [esi+4], ebx
	pop	ebx

; 964  : 		}

	ret	0
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 1510 : 		if (!_Built)

	mov	al, BYTE PTR __Built$[esp-4]
	test	al, al
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR __Newsize$[esp+4]
	mov	ebx, ecx
	je	SHORT $L22725

; 1511 : 			;
; 1512 : 		else if (_BUF_SIZE <= _Myres)

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	jb	SHORT $L22725

; 1513 : 			{	// copy any leftovers to small buffer and deallocate
; 1514 : 			_Elem *_Ptr = _Bx._Ptr;
; 1515 : 			if (0 < _Newsize)

	test	ebp, ebp
	mov	eax, DWORD PTR [ebx+4]
	push	edi
	lea	edi, DWORD PTR [ebx+4]
	jbe	SHORT $L22721
	push	esi

; 1516 : 				_Traits::copy(_Bx._Buf, _Ptr, _Newsize);

	mov	ecx, ebp
	mov	edx, ecx
	shr	ecx, 2
	mov	esi, eax
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb
	pop	esi
$L22721:

; 1517 : 			_Mybase::_Alval.deallocate(_Ptr, _Myres + 1);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$L22725:

; 1518 : 			}
; 1519 : 		_Myres = _BUF_SIZE - 1;
; 1520 : 		_Eos(_Newsize);

	mov	DWORD PTR [ebx+20], ebp
	mov	DWORD PTR [ebx+24], 15			; 0000000fH
	mov	BYTE PTR [ebx+ebp+4], 0
	pop	ebp
	pop	ebx

; 1521 : 		}

	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = esi

; 414  : 		_Tidy();

	jmp	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stack
_TEXT	ENDS
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC NEAR ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = eax

; 23   : 		{	// construct with empty container

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx

; 24   : 		}

	ret	0
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 456  : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 457  : 		_Tidy(true);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L22842
	mov	eax, DWORD PTR [esi+4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L22842:
	xor	eax, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], eax
	mov	BYTE PTR [esi+4], al
	pop	esi

; 458  : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = eax

; 312  : 		_Tidy();

	xor	ecx, ecx
	mov	DWORD PTR [eax+24], 15			; 0000000fH
	mov	DWORD PTR [eax+20], ecx
	mov	BYTE PTR [eax+4], cl

; 313  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??1ErrorInfo@Reader@Json@@QAE@XZ PROC NEAR		; Json::Reader::ErrorInfo::~ErrorInfo, COMDAT
; _this$ = esi
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $L22985
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L22985:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	ret	0
??1ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::~ErrorInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??0ErrorInfo@Reader@Json@@QAE@XZ PROC NEAR		; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = eax
	xor	ecx, ecx
	mov	DWORD PTR [eax+36], 15			; 0000000fH
	mov	DWORD PTR [eax+32], ecx
	mov	BYTE PTR [eax+16], cl
	ret	0
??0ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::ErrorInfo
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC NEAR ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = esi
	jmp	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
??1logic_error@std@@UAE@XZ PROC NEAR			; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 23   : 		{}	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $L23175
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L23175:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@@UAE@XZ			; exception::~exception
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??_GErrorInfo@Reader@Json@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z PROC NEAR		; Json::Reader::ErrorInfo::`scalar deleting destructor', COMDAT
; _this$ = eax
	push	esi
	mov	esi, eax
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L24572
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L24572:
	mov	eax, esi
	pop	esi
	ret	4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z ENDP		; Json::Reader::ErrorInfo::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z PROC NEAR ; std::_Destroy<Json::Reader::ErrorInfo>, COMDAT
; __Ptr$ = esi

; 49   : 	_DESTRUCTOR(_Ty, _Ptr);

	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Destroy<Json::Reader::ErrorInfo>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC NEAR ; std::allocator<Json::Reader::ErrorInfo>::destroy, COMDAT
; __Ptr$ = esi

; 152  : 		_Destroy(_Ptr);

	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::destroy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front, COMDAT
; _this$ = edi

; 571  : 		if (!empty())

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $L14647

; 572  : 			{	// something to erase, do it
; 573  : 			size_type _Block = _Myoff / _DEQUESIZ;
; 574  : 			this->_Alval.destroy(_Map[_Block] + _Myoff % _DEQUESIZ);

	mov	eax, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR [ecx+eax*4]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ

; 575  : 			if (_Mapsize * _DEQUESIZ <= ++_Myoff)

	mov	edx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+8]
	inc	edx
	mov	eax, edx
	cmp	ecx, eax
	mov	DWORD PTR [edi+12], edx
	pop	esi
	ja	SHORT $L14646

; 576  : 				_Myoff = 0;

	mov	DWORD PTR [edi+12], 0
$L14646:

; 577  : 			if (--_Mysize == 0)

	dec	DWORD PTR [edi+16]
	jne	SHORT $L14647

; 578  : 				_Myoff = 0;

	mov	DWORD PTR [edi+12], 0
$L14647:

; 579  : 			}
; 580  : 		}

	ret	0
?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back, COMDAT
; _this$ = edi

; 599  : 		if (!empty())

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $L14423

; 600  : 			{	// something to erase, do it
; 601  : 			size_type _Newoff = _Mysize + _Myoff - 1;
; 602  : 			size_type _Block = _Newoff / _DEQUESIZ;

	mov	ecx, DWORD PTR [edi+12]
	lea	eax, DWORD PTR [eax+ecx-1]

; 603  : 			if (_Mapsize <= _Block)

	mov	ecx, DWORD PTR [edi+8]
	cmp	ecx, eax
	ja	SHORT $L14422

; 604  : 				_Block -= _Mapsize;

	sub	eax, ecx
$L14422:

; 605  : 			this->_Alval.destroy(_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	edx, DWORD PTR [edi+4]
	push	esi
	mov	esi, DWORD PTR [edx+eax*4]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ

; 606  : 			if (--_Mysize == 0)

	mov	eax, DWORD PTR [edi+16]
	dec	eax
	pop	esi
	mov	DWORD PTR [edi+16], eax
	jne	SHORT $L14423

; 607  : 				_Myoff = 0;

	mov	DWORD PTR [edi+12], 0
$L14423:

; 608  : 			}
; 609  : 		}

	ret	0
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T24846	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
$T24848	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L24649
$T24849	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L24647
$T24847	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T24848
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:$T24849
$T24841	DD	019930520H
	DD	04H
	DD	FLAT:$T24846
	DD	02H
	DD	FLAT:$T24847
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	ENDS
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
_TEXT	SEGMENT
__Newres$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ptr$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 1444 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 12					; 0000000cH

; 1445 : 		size_type _Newres = _Newsize | _ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	push	ebx
	push	esi
	mov	ebx, eax
	or	ebx, 15					; 0000000fH

; 1446 : 		if (max_size() < _Newres)

	cmp	ebx, -2					; fffffffeH
	push	edi
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], esi
	jbe	SHORT $L14293

; 1447 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	ebx, eax

; 1448 : 		else if (_Newres / 3 < _Myres / 2

	jmp	SHORT $L14295
$L14293:

; 1449 : 			&& _Myres <= max_size() - _Myres / 2)

	mov	edi, DWORD PTR [esi+24]
	mov	eax, -1431655765			; aaaaaaabH
	mul	ebx
	mov	ecx, edi
	shr	ecx, 1
	shr	edx, 1
	cmp	edx, ecx
	jae	SHORT $L14295
	mov	eax, -2					; fffffffeH
	sub	eax, ecx
	cmp	edi, eax
	ja	SHORT $L14295

; 1450 : 			_Newres = _Myres + _Myres / 2;	// grow exponentially if possible

	lea	ebx, DWORD PTR [ecx+edi]
$L14295:

; 1451 : 		_Elem *_Ptr;
; 1452 : 
; 1453 : 		_TRY_BEGIN
; 1454 : 			_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	lea	ecx, DWORD PTR [ebx+1]
	push	ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], edx
	jmp	SHORT $L14297
$L24647:

; 1455 : 		_CATCH_ALL
; 1456 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax

; 1457 : 			_TRY_BEGIN
; 1458 : 				_Ptr = _Mybase::_Alval.allocate(_Newres + 1);

	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	??2@YAPAXI@Z				; operator new
	mov	DWORD PTR __Ptr$[ebp], eax
	add	esp, 4

; 1462 : 			_CATCH_END
; 1463 : 		_CATCH_END

	mov	eax, $L24842
	ret	0
$L24842:
	mov	ebx, DWORD PTR __Newres$[ebp]
	mov	esi, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Ptr$[ebp]
$L14297:

; 1464 : 
; 1465 : 		if (0 < _Oldlen)

	mov	ecx, DWORD PTR __Oldlen$[ebp]
	test	ecx, ecx
	jbe	SHORT $L24766

; 1466 : 			_Traits::copy(_Ptr, _Myptr(), _Oldlen);	// copy existing elements

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L24762
	mov	esi, DWORD PTR [esi+4]
	jmp	SHORT $L24763
$L24762:
	add	esi, 4
$L24763:
	mov	eax, ecx
	shr	ecx, 2
	mov	edi, edx
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb
	mov	esi, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Oldlen$[ebp]
$L24766:

; 1467 : 		_Tidy(true);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L24803
	mov	ecx, DWORD PTR [esi+4]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR __Oldlen$[ebp]
	add	esp, 4
$L24803:

; 1468 : 		_Bx._Ptr = _Ptr;
; 1469 : 		_Myres = _Newres;
; 1470 : 		_Eos(_Oldlen);

	cmp	ebx, 16					; 00000010H
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax], 0
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [esi+24], ebx
	mov	DWORD PTR [esi+20], ecx
	jb	SHORT $L24835
	mov	eax, edx
$L24835:

; 1471 : 		}

	pop	edi
	mov	BYTE PTR [eax+ecx], 0
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
$L24649:

; 1459 : 			_CATCH_ALL
; 1460 : 			_Tidy(true);	// failed again, discard storage and reraise

	mov	esi, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L24742
	mov	edx, DWORD PTR [esi+4]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L24742:

; 1461 : 			_RERAISE;

	push	0
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	push	0
	mov	BYTE PTR [esi+4], 0
	call	__CxxThrowException@8
$L24850:
$L24845:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z:
	mov	eax, OFFSET FLAT:$T24841
	jmp	___CxxFrameHandler
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
;	COMDAT ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy, COMDAT
; _this$ = edi

; 951  : 		while (!empty())

	mov	eax, DWORD PTR [edi+16]
	push	ebx
	xor	ebx, ebx
	cmp	eax, ebx
	push	esi
	je	SHORT $L14226
	npad	5
$L14225:

; 952  : 			pop_back();

	mov	eax, DWORD PTR [edi+16]
	cmp	eax, ebx
	je	SHORT $L24886
	mov	ecx, DWORD PTR [edi+12]
	lea	eax, DWORD PTR [eax+ecx-1]
	mov	ecx, DWORD PTR [edi+8]
	cmp	ecx, eax
	ja	SHORT $L24885
	sub	eax, ecx
$L24885:
	mov	edx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [edx+eax*4]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	dec	DWORD PTR [edi+16]
	jne	SHORT $L24886
	mov	DWORD PTR [edi+12], ebx
$L24886:
	cmp	DWORD PTR [edi+16], ebx
	jne	SHORT $L14225
$L14226:

; 953  : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	mov	esi, DWORD PTR [edi+8]
	cmp	esi, ebx
	jbe	SHORT $L14230
$L14229:

; 954  : 			{	// free storage for a block and destroy pointer
; 955  : 			if (*(_Map + --_Count) != 0)

	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+esi*4-4]
	dec	esi
	cmp	eax, ebx
	je	SHORT $L24898

; 956  : 				this->_Alval.deallocate(*(_Map + _Count), _DEQUESIZ);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L24898:

; 953  : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	cmp	esi, ebx
	ja	SHORT $L14229
$L14230:

; 957  : 			this->_Almap.destroy(_Map + _Count);
; 958  : 			}
; 959  : 
; 960  : 		if (_Map)

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, ebx
	je	SHORT $L24909

; 961  : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for map

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L24909:
	pop	esi

; 962  : 		_Mapsize = 0;

	mov	DWORD PTR [edi+8], ebx

; 963  : 		_Map = 0;

	mov	DWORD PTR [edi+4], ebx
	pop	ebx

; 964  : 		}

	ret	0
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 1480 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	push	esi

; 1481 : 		if (max_size() < _Newsize)

	mov	esi, DWORD PTR __Newsize$[esp+4]
	cmp	esi, -2					; fffffffeH
	mov	ebp, ecx
	jbe	SHORT $L13844

; 1482 : 			_String_base::_Xlen();	// result too long

	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L13844:

; 1483 : 		if (_Myres < _Newsize)

	mov	eax, DWORD PTR [ebp+24]
	cmp	eax, esi
	jae	SHORT $L13845

; 1484 : 			_Copy(_Newsize, _Mysize);	// reallocate to grow

	mov	eax, DWORD PTR [ebp+20]
	push	eax
	push	esi
	mov	ecx, ebp
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, esi
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebp

; 1491 : 		}

	ret	8
$L13845:

; 1485 : 		else if (_Trim && _Newsize < _BUF_SIZE)

	mov	cl, BYTE PTR __Trim$[esp+4]
	test	cl, cl
	je	SHORT $L13847
	cmp	esi, 16					; 00000010H
	jae	SHORT $L13847
	push	ebx

; 1486 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 1487 : 				_Newsize < _Mysize ? _Newsize : _Mysize);

	mov	ebx, DWORD PTR [ebp+20]
	cmp	esi, ebx
	jae	SHORT $L24914
	mov	ebx, esi
$L24914:
	cmp	eax, 16					; 00000010H
	jb	SHORT $L24969
	test	ebx, ebx
	mov	eax, DWORD PTR [ebp+4]
	push	edi
	lea	edi, DWORD PTR [ebp+4]
	jbe	SHORT $L24966
	mov	ecx, ebx
	mov	edx, ecx
	shr	ecx, 2
	mov	esi, eax
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb
	mov	esi, DWORD PTR __Newsize$[esp+12]
$L24966:
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
$L24969:
	mov	DWORD PTR [ebp+20], ebx

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	mov	DWORD PTR [ebp+24], 15			; 0000000fH
	mov	BYTE PTR [ebx+ebp+4], 0
	cmp	eax, esi
	pop	ebx
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebp

; 1491 : 		}

	ret	8
$L13847:

; 1488 : 		else if (_Newsize == 0)

	test	esi, esi
	jne	SHORT $L25004

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [ebp+20], esi
	jb	SHORT $L25001
	mov	ebp, DWORD PTR [ebp+4]

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, esi
	sbb	eax, eax
	pop	esi
	mov	BYTE PTR [ebp], 0
	neg	eax
	pop	ebp

; 1491 : 		}

	ret	8

; 1489 : 			_Eos(0);	// new size is zero, just null terminate

$L25001:
	add	ebp, 4
	mov	BYTE PTR [ebp], 0
$L25004:

; 1490 : 		return (0 < _Newsize);	// return true only if more work to do

	xor	eax, eax
	cmp	eax, esi
	sbb	eax, eax
	pop	esi
	neg	eax
	pop	ebp

; 1491 : 		}

	ret	8
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 590  : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebx
	push	ebp
	push	esi

; 591  : 		if (_Right.size() < _Roff)

	mov	esi, DWORD PTR __Roff$[esp+8]
	push	edi
	mov	edi, DWORD PTR __Right$[esp+12]
	cmp	DWORD PTR [edi+20], esi
	mov	ebx, ecx
	jae	SHORT $L13789

; 592  : 			_String_base::_Xran();	// _Roff off end

	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L13789:

; 593  : 		size_type _Num = _Right.size() - _Roff;

	mov	ebp, DWORD PTR [edi+20]

; 594  : 		if (_Count < _Num)

	mov	eax, DWORD PTR __Count$[esp+12]
	sub	ebp, esi
	cmp	eax, ebp
	jae	SHORT $L13791

; 595  : 			_Num = _Count;	// trim _Num to size

	mov	ebp, eax
$L13791:

; 596  : 
; 597  : 		if (this == &_Right)

	cmp	ebx, edi
	jne	SHORT $L13792

; 598  : 			erase((size_type)(_Roff + _Num)), erase(0, _Roff);	// substring

	push	-1
	add	ebp, esi
	push	ebp
	mov	ecx, ebx
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	push	esi
	push	0
	mov	ecx, ebx
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi
	pop	esi
	pop	ebp

; 603  : 			}
; 604  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 605  : 		}

	ret	12					; 0000000cH
$L13792:

; 599  : 		else if (_Grow(_Num))

	cmp	ebp, -2					; fffffffeH
	jbe	SHORT $L25153
	mov	ecx, ebx
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L25153:
	mov	eax, DWORD PTR [ebx+24]
	cmp	eax, ebp
	jae	SHORT $L25155
	mov	eax, DWORD PTR [ebx+20]
	push	eax
	push	ebp
	mov	ecx, ebx
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	ebp, ebp
$L25204:
	jbe	SHORT $L25203

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

	mov	ecx, DWORD PTR [edi+24]
	mov	eax, 16					; 00000010H
	cmp	ecx, eax
	jb	SHORT $L25169
	mov	edx, DWORD PTR [edi+4]
	jmp	SHORT $L25170

; 599  : 		else if (_Grow(_Num))

$L25155:
	test	ebp, ebp
	jne	SHORT $L25204
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [ebx+20], ebp
	jb	SHORT $L25152
	mov	eax, DWORD PTR [ebx+4]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax], 0
	pop	ebp

; 603  : 			}
; 604  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 605  : 		}

	ret	12					; 0000000cH

; 599  : 		else if (_Grow(_Num))

$L25152:
	pop	edi
	lea	eax, DWORD PTR [ebx+4]
	pop	esi
	mov	BYTE PTR [eax], 0
	pop	ebp

; 603  : 			}
; 604  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 605  : 		}

	ret	12					; 0000000cH

; 600  : 			{	// make room and assign new stuff
; 601  : 			_Traits::copy(_Myptr(), _Right._Myptr() + _Roff, _Num);

$L25169:
	lea	edx, DWORD PTR [edi+4]
$L25170:
	cmp	DWORD PTR [ebx+24], eax
	lea	eax, DWORD PTR [ebx+4]
	jb	SHORT $L25175
	mov	edi, DWORD PTR [eax]
	jmp	SHORT $L25176
$L25175:
	mov	edi, eax
$L25176:
	add	esi, edx
	mov	ecx, ebp
	mov	edx, ecx
	shr	ecx, 2
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 602  : 			_Eos(_Num);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	mov	DWORD PTR [ebx+20], ebp
	jb	SHORT $L25199
	mov	eax, DWORD PTR [eax]
$L25199:
	mov	BYTE PTR [eax+ebp], 0
$L25203:
	pop	edi
	pop	esi
	pop	ebp

; 603  : 			}
; 604  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 605  : 		}

	ret	12					; 0000000cH
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx
; __Right$ = eax

; 585  : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 586  : 		}

	ret	0
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = esi
; __Count$ = eax

; 543  : 		if (npos - _Mysize <= _Count)

	mov	edx, DWORD PTR [esi+20]
	push	edi
	mov	edi, eax
	or	eax, -1
	sub	eax, edx
	cmp	eax, edi
	ja	SHORT $L13782

; 544  : 			_String_base::_Xlen();	// result too long

	mov	ecx, esi
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L13782:

; 545  : 
; 546  : 		size_type _Num;
; 547  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	edi, edi
	jbe	$L25389
	push	ebp
	mov	ebp, DWORD PTR [esi+20]
	add	ebp, edi
	cmp	ebp, -2					; fffffffeH
	jbe	SHORT $L25308
	mov	ecx, esi
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L25308:
	mov	eax, DWORD PTR [esi+24]
	cmp	eax, ebp
	jae	SHORT $L25309
	mov	ecx, DWORD PTR [esi+20]
	push	ecx
	push	ebp
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	ebp, ebp
$L25391:
	jbe	SHORT $L25388

; 548  : 			{	// make room and append new stuff using assign
; 549  : 			_Traits::assign(_Myptr() + _Mysize, _Count, _Ch);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	jb	SHORT $L25360
	mov	edx, DWORD PTR [esi+4]
	jmp	SHORT $L25361

; 545  : 
; 546  : 		size_type _Num;
; 547  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$L25309:
	test	ebp, ebp
	jne	SHORT $L25391
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [esi+20], ebp
	jb	SHORT $L25351
	mov	eax, DWORD PTR [esi+4]
	pop	ebp
	mov	BYTE PTR [eax], 0

; 551  : 			}
; 552  : 		return (*this);

	mov	eax, esi
	pop	edi

; 553  : 		}

	ret	4

; 545  : 
; 546  : 		size_type _Num;
; 547  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$L25351:
	lea	eax, DWORD PTR [esi+4]
	pop	ebp
	mov	BYTE PTR [eax], 0

; 551  : 			}
; 552  : 		return (*this);

	mov	eax, esi
	pop	edi

; 553  : 		}

	ret	4

; 548  : 			{	// make room and append new stuff using assign
; 549  : 			_Traits::assign(_Myptr() + _Mysize, _Count, _Ch);

$L25360:
	lea	edx, DWORD PTR [esi+4]
$L25361:
	movsx	eax, BYTE PTR __Ch$[esp+4]
	push	ebx
	mov	bl, al
	mov	bh, bl
	mov	ecx, edi
	mov	edi, DWORD PTR [esi+20]
	add	edi, edx
	mov	edx, ecx
	shr	ecx, 2
	mov	eax, ebx
	shl	eax, 16					; 00000010H
	mov	ax, bx
	pop	ebx
	rep stosd
	mov	ecx, edx
	and	ecx, 3
	rep stosb

; 550  : 			_Eos(_Num);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], ebp
	jb	SHORT $L25383
	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+ebp], 0
	pop	ebp

; 551  : 			}
; 552  : 		return (*this);

	mov	eax, esi
	pop	edi

; 553  : 		}

	ret	4

; 550  : 			_Eos(_Num);

$L25383:
	lea	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+ebp], 0
$L25388:
	pop	ebp
$L25389:

; 551  : 			}
; 552  : 		return (*this);

	mov	eax, esi
	pop	edi

; 553  : 		}

	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
_TEXT	ENDS
;	COMDAT ?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear, COMDAT
; _this$ = edi

; 799  : 		_Tidy();

	jmp	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = edi

; 414  : 		_Tidy();

	jmp	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx
; __Newcap$ = eax

; 1137 : 		{	// determine new minimum length of allocated storage

	push	esi
	mov	esi, ecx
	push	edi

; 1138 : 		if (_Mysize <= _Newcap && _Myres != _Newcap)

	mov	edi, DWORD PTR [esi+20]
	cmp	edi, eax
	ja	SHORT $L25420
	cmp	DWORD PTR [esi+24], eax
	je	SHORT $L25420

; 1139 : 			{	// change reservation
; 1140 : 			size_type _Size = _Mysize;
; 1141 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	mov	ecx, esi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $L25420

; 1142 : 				_Eos(_Size);

	cmp	DWORD PTR [esi+24], 16			; 00000010H
	mov	DWORD PTR [esi+20], edi
	jb	SHORT $L25417
	mov	esi, DWORD PTR [esi+4]
	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi

; 1143 : 			}
; 1144 : 		}

	ret	0

; 1142 : 				_Eos(_Size);

$L25417:
	add	esi, 4
	mov	BYTE PTR [esi+edi], 0
$L25420:
	pop	edi
	pop	esi

; 1143 : 			}
; 1144 : 		}

	ret	0
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = esi
; __Ch$ = eax

; 492  : 		return (append((size_type)1, _Ch));

	push	eax
	mov	eax, 1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 493  : 		}

	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx
; __Right$ = eax

; 467  : 		return (assign(_Right));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 468  : 		}

	ret	0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 323  : 		{	// construct by copying _Right

	push	esi

; 324  : 		_Tidy();

	xor	eax, eax
	mov	esi, ecx

; 325  : 		assign(_Right, 0, npos);

	push	-1
	mov	DWORD PTR [esi+20], eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [esi+4], al
	mov	eax, DWORD PTR __Right$[esp+8]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 326  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	??0Reader@Json@@QAE@XZ				; Json::Reader::Reader
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
;	COMDAT ??0Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??0Reader@Json@@QAE@XZ PROC NEAR			; Json::Reader::Reader, COMDAT
; _this$ = eax

; 41   : {

	xor	ecx, ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	mov	DWORD PTR [eax+16], ecx
	mov	DWORD PTR [eax+24], ecx
	mov	DWORD PTR [eax+28], ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], ecx
	mov	edx, 15					; 0000000fH
	mov	DWORD PTR [eax+64], edx
	mov	DWORD PTR [eax+60], ecx
	mov	BYTE PTR [eax+44], cl
	mov	DWORD PTR [eax+112], edx
	mov	DWORD PTR [eax+108], ecx
	mov	BYTE PTR [eax+92], cl

; 42   : }

	ret	0
??0Reader@Json@@QAE@XZ ENDP				; Json::Reader::Reader
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
??1length_error@std@@UAE@XZ PROC NEAR			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 99   : 		{}	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
	cmp	DWORD PTR [esi+36], 16			; 00000010H
	jb	SHORT $L25901
	mov	eax, DWORD PTR [esi+16]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L25901:
	xor	eax, eax
	mov	DWORD PTR [esi+36], 15			; 0000000fH
	mov	DWORD PTR [esi+32], eax
	mov	BYTE PTR [esi+16], al
	mov	ecx, esi
	pop	esi
	jmp	??1exception@@UAE@XZ			; exception::~exception
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC NEAR		; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L25921
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L25921:
	mov	eax, esi
	pop	esi
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T26024	DD	0ffffffffH
	DD	FLAT:$L25925
$T26022	DD	019930520H
	DD	01H
	DD	FLAT:$T26024
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 19   : 		{	// construct from message string

	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	call	??0exception@@QAE@XZ			; exception::exception
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+28], eax
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
	push	-1
	mov	DWORD PTR [ecx+20], eax
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	push	eax
	mov	BYTE PTR [ecx+4], al
	mov	eax, DWORD PTR __Message$[esp+24]
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 20   : 		}

	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L25925:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	eax, OFFSET FLAT:$T26022
	jmp	___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z PROC NEAR	; Json::Reader::ErrorInfo::operator=, COMDAT
; _this$ = esi
; ___that$ = edi
	mov	eax, edi
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	push	-1
	mov	DWORD PTR [ecx+8], eax
	push	0
	lea	ecx, DWORD PTR [edi+12]
	push	ecx
	lea	ecx, DWORD PTR [esi+12]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	edx, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], edx
	mov	eax, esi
	ret	0
??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z ENDP	; Json::Reader::ErrorInfo::operator=
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
_TEXT	ENDS
;	COMDAT ??$fill@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@VErrorInfo@Reader@Json@@@std@@YAXViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0ABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$fill@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@VErrorInfo@Reader@Json@@@std@@YAXViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0ABVErrorInfo@Reader@Json@@@Z PROC NEAR ; std::fill<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,Json::Reader::ErrorInfo>, COMDAT
; __Val$ = ebx

; 1134 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, DWORD PTR __First$[esp]
	push	esi
	push	edi
	mov	edi, DWORD PTR __First$[esp+12]
	npad	5

; 1135 : 	for (; _First != _Last; ++_First)

$L28398:
	cmp	ebp, DWORD PTR __Last$[esp+8]
	jne	SHORT $L28410
	cmp	edi, DWORD PTR __Last$[esp+12]
	je	SHORT $L28445
$L28410:

; 1136 : 		*_First = _Val;

	mov	ecx, DWORD PTR [ebp+8]
	cmp	ecx, edi
	mov	eax, edi
	ja	SHORT $L28425
	sub	eax, ecx
$L28425:
	mov	ecx, DWORD PTR [ebp+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	mov	edx, ebx
	mov	ecx, DWORD PTR [edx]
	mov	eax, esi
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	push	-1
	mov	DWORD PTR [eax+8], edx
	push	0
	lea	eax, DWORD PTR [ebx+12]
	push	eax
	lea	ecx, DWORD PTR [esi+12]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ecx, DWORD PTR [ebx+40]
	mov	DWORD PTR [esi+40], ecx
	inc	edi
	jmp	SHORT $L28398
$L28445:
	pop	edi
	pop	esi
	pop	ebp

; 1137 : 	}

	ret	0
??$fill@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@VErrorInfo@Reader@Json@@@std@@YAXViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0ABVErrorInfo@Reader@Json@@@Z ENDP ; std::fill<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,Json::Reader::ErrorInfo>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T28548	DD	0ffffffffH
	DD	FLAT:$L28449
$T28546	DD	019930520H
	DD	01H
	DD	FLAT:$T28548
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC NEAR		; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[esp+20]
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+28], esi
	call	??0exception@@QAE@ABV0@@Z		; exception::exception
	xor	eax, eax
	mov	DWORD PTR __$EHRec$[esp+32], eax
	push	-1
	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7logic_error@std@@6B@
	push	eax
	add	edi, 12					; 0000000cH
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], eax
	push	edi
	mov	BYTE PTR [ecx+4], al
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	mov	eax, esi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L28449:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	eax, OFFSET FLAT:$T28546
	jmp	___CxxFrameHandler
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
; Function compile flags: /Ogtpy
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC NEAR		; std::length_error::length_error, COMDAT
; _this$ = ecx
	mov	eax, DWORD PTR ___that$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@
	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z PROC NEAR	; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = esi
; ___that$ = edi
	mov	eax, edi
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	xor	eax, eax
	push	-1
	lea	ecx, DWORD PTR [esi+12]
	push	eax
	lea	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], eax
	push	edx
	mov	BYTE PTR [ecx+4], al
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], eax
	mov	eax, esi
	ret	0
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z ENDP		; Json::Reader::ErrorInfo::ErrorInfo
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Roff$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ebx
; __Right$ = ecx
; __Count$ = eax

; 502  : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp

; 503  : 		if (_Right.size() < _Roff)

	mov	ebp, DWORD PTR __Roff$[esp]
	push	esi
	push	edi
	mov	esi, ecx
	mov	edi, eax
	cmp	DWORD PTR [esi+20], ebp
	jae	SHORT $L14270

; 504  : 			_String_base::_Xran();	// _Roff off end

	mov	ecx, ebx
	call	?_Xran@_String_base@std@@QBEXXZ		; std::_String_base::_Xran
$L14270:

; 505  : 		size_type _Num = _Right.size() - _Roff;

	mov	eax, DWORD PTR [esi+20]
	sub	eax, ebp

; 506  : 		if (_Num < _Count)

	cmp	eax, edi
	jae	SHORT $L14272

; 507  : 			_Count = _Num;	// trim _Count to size

	mov	edi, eax
$L14272:

; 508  : 		if (npos - _Mysize <= _Count)

	mov	edx, DWORD PTR [ebx+20]
	or	eax, -1
	sub	eax, edx
	cmp	eax, edi
	ja	SHORT $L14273

; 509  : 			_String_base::_Xlen();	// result too long

	mov	ecx, ebx
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L14273:

; 510  : 
; 511  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	edi, edi
	jbe	$L28849
	mov	ebp, DWORD PTR [ebx+20]
	add	ebp, edi
	cmp	ebp, -2					; fffffffeH
	jbe	SHORT $L28800
	mov	ecx, ebx
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L28800:
	mov	eax, DWORD PTR [ebx+24]
	cmp	eax, ebp
	jae	SHORT $L28801
	mov	ecx, DWORD PTR [ebx+20]
	push	ecx
	push	ebp
	mov	ecx, ebx
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	ebp, ebp
$L28850:
	jbe	SHORT $L28849

; 512  : 			{	// make room and append new stuff
; 513  : 			_Traits::copy(_Myptr() + _Mysize,
; 514  : 				_Right._Myptr() + _Roff, _Count);

	mov	ecx, DWORD PTR [esi+24]
	mov	eax, 16					; 00000010H
	cmp	ecx, eax
	jb	SHORT $L28813
	mov	esi, DWORD PTR [esi+4]
	jmp	SHORT $L28814

; 510  : 
; 511  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$L28801:
	test	ebp, ebp
	jne	SHORT $L28850
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [ebx+20], ebp
	jb	SHORT $L28793
	mov	eax, DWORD PTR [ebx+4]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax], 0

; 516  : 			}
; 517  : 		return (*this);

	mov	eax, ebx
	pop	ebp

; 518  : 		}

	ret	4

; 510  : 
; 511  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$L28793:
	pop	edi
	lea	eax, DWORD PTR [ebx+4]
	pop	esi
	mov	BYTE PTR [eax], 0

; 516  : 			}
; 517  : 		return (*this);

	mov	eax, ebx
	pop	ebp

; 518  : 		}

	ret	4

; 512  : 			{	// make room and append new stuff
; 513  : 			_Traits::copy(_Myptr() + _Mysize,
; 514  : 				_Right._Myptr() + _Roff, _Count);

$L28813:
	add	esi, 4
$L28814:
	cmp	DWORD PTR [ebx+24], eax
	lea	edx, DWORD PTR [ebx+4]
	jb	SHORT $L28820
	mov	eax, DWORD PTR [edx]
	jmp	SHORT $L28821
$L28820:
	mov	eax, edx
$L28821:
	mov	ecx, edi
	mov	edi, DWORD PTR __Roff$[esp+8]
	add	esi, edi
	mov	edi, DWORD PTR [ebx+20]
	add	edi, eax
	mov	eax, ecx
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb

; 515  : 			_Eos(_Num);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	mov	DWORD PTR [ebx+20], ebp
	jb	SHORT $L28843
	mov	edx, DWORD PTR [edx]
$L28843:
	mov	BYTE PTR [edx+ebp], 0
$L28849:
	pop	edi
	pop	esi

; 516  : 			}
; 517  : 		return (*this);

	mov	eax, ebx
	pop	ebp

; 518  : 		}

	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Num$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 608  : 		{	// assign [_Ptr, _Ptr + _Num)

	push	ebx
	mov	ebx, ecx

; 609  : 		if (_Inside(_Ptr))

	mov	edx, DWORD PTR [ebx+24]
	cmp	edx, 16					; 00000010H
	push	esi
	push	edi
	jb	SHORT $L28871
	mov	eax, DWORD PTR [ebx+4]
	jmp	SHORT $L28872
$L28871:
	lea	eax, DWORD PTR [ebx+4]
$L28872:
	mov	esi, DWORD PTR __Ptr$[esp+8]
	cmp	esi, eax
	jb	SHORT $L13835
	cmp	edx, 16					; 00000010H
	lea	eax, DWORD PTR [ebx+4]
	jb	SHORT $L28875
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $L28876
$L28875:
	mov	ecx, eax
$L28876:
	mov	edi, DWORD PTR [ebx+20]
	add	edi, ecx
	cmp	edi, esi
	jbe	SHORT $L13835

; 610  : 			return (assign(*this, _Ptr - _Myptr(), _Num));	// substring

	cmp	edx, 16					; 00000010H
	jb	SHORT $L28888
	mov	eax, DWORD PTR [eax]
$L28888:
	mov	ecx, DWORD PTR __Num$[esp+8]
	push	ecx
	sub	esi, eax
	push	esi
	push	ebx
	mov	ecx, ebx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi
	pop	ebx

; 618  : 		}

	ret	8
$L13835:
	push	ebp

; 611  : 
; 612  : 		if (_Grow(_Num))

	mov	ebp, DWORD PTR __Num$[esp+12]
	cmp	ebp, -2					; fffffffeH
	jbe	SHORT $L29029
	mov	ecx, ebx
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L29029:
	mov	eax, DWORD PTR [ebx+24]
	cmp	eax, ebp
	jae	SHORT $L29030
	mov	edx, DWORD PTR [ebx+20]
	push	edx
	push	ebp
	mov	ecx, ebx
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	ebp, ebp
$L29068:
	jbe	SHORT $L29064

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	jb	SHORT $L29039
	mov	edi, DWORD PTR [ebx+4]
	jmp	SHORT $L29040

; 611  : 
; 612  : 		if (_Grow(_Num))

$L29030:
	test	ebp, ebp
	jne	SHORT $L29068
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [ebx+20], ebp
	jb	SHORT $L29022
	mov	eax, DWORD PTR [ebx+4]
	pop	ebp
	pop	edi
	mov	BYTE PTR [eax], 0
	pop	esi

; 616  : 			}
; 617  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 618  : 		}

	ret	8

; 611  : 
; 612  : 		if (_Grow(_Num))

$L29022:
	pop	ebp
	lea	eax, DWORD PTR [ebx+4]
	pop	edi
	mov	BYTE PTR [eax], 0
	pop	esi

; 616  : 			}
; 617  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 618  : 		}

	ret	8

; 613  : 			{	// make room and assign new stuff
; 614  : 			_Traits::copy(_Myptr(), _Ptr, _Num);

$L29039:
	lea	edi, DWORD PTR [ebx+4]
$L29040:
	mov	ecx, ebp
	mov	eax, ecx
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb

; 615  : 			_Eos(_Num);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	mov	DWORD PTR [ebx+20], ebp
	jb	SHORT $L29061
	mov	eax, DWORD PTR [ebx+4]
	mov	BYTE PTR [eax+ebp], 0
	pop	ebp
	pop	edi
	pop	esi

; 616  : 			}
; 617  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 618  : 		}

	ret	8

; 615  : 			_Eos(_Num);

$L29061:
	lea	eax, DWORD PTR [ebx+4]
	mov	BYTE PTR [eax+ebp], 0
$L29064:
	pop	ebp
	pop	edi
	pop	esi

; 616  : 			}
; 617  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 618  : 		}

	ret	8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ebx
; __Right$ = ecx

; 497  : 		return (append(_Right, 0, npos));

	push	0
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 498  : 		}

	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ebx
; __Right$ = ecx

; 482  : 		return (append(_Right));

	push	0
	or	eax, -1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 483  : 		}

	ret	0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = esi
; __First$ = ecx
; __Last$ = eax

; 442  : 		_Tidy();

	xor	edx, edx

; 443  : 		if (_First != _Last)

	cmp	ecx, eax
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], edx
	mov	BYTE PTR [esi+4], dl
	je	SHORT $L29144

; 444  : 			assign(&*_First, _Last - _First);

	sub	eax, ecx
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L29144:

; 445  : 		}

	mov	eax, esi
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC NEAR		; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L29148
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L29148:
	mov	eax, esi
	pop	esi
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stdexcept
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC NEAR ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 95   : 		{	// construct from message string

	mov	eax, DWORD PTR __Message$[esp-4]
	push	esi
	push	eax
	mov	esi, ecx
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	DWORD PTR [esi], OFFSET FLAT:??_7length_error@std@@6B@

; 96   : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xutility
;	COMDAT ??$_Copy_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
??$_Copy_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>, COMDAT

; 1020 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebx
	mov	ebx, DWORD PTR __First$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR __Dest$[esp+8]
	push	esi
	push	edi
	npad	4

; 1021 : 	for (; _First != _Last; ++_Dest, ++_First)

$L30709:
	mov	esi, DWORD PTR __First$[esp+12]
	cmp	esi, DWORD PTR __Last$[esp+12]
	jne	SHORT $L30723
	cmp	ebx, DWORD PTR __Last$[esp+16]
	je	SHORT $L30772
$L30723:

; 1022 : 		*_Dest = *_First;

	mov	eax, DWORD PTR [esi+8]
	cmp	eax, ebx
	mov	ecx, ebx
	ja	SHORT $L30737
	sub	ecx, eax
$L30737:
	mov	edi, DWORD PTR __Dest$[esp+12]
	mov	edx, DWORD PTR [edi+8]
	cmp	edx, ebp
	mov	eax, ebp
	ja	SHORT $L30751
	sub	eax, edx
$L30751:
	mov	edx, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	edx, esi
	mov	ecx, DWORD PTR [edx]
	mov	eax, edi
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	push	-1
	mov	DWORD PTR [eax+8], edx
	push	0
	lea	eax, DWORD PTR [esi+12]
	push	eax
	lea	ecx, DWORD PTR [edi+12]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ecx, DWORD PTR [esi+40]
	inc	ebp
	mov	DWORD PTR [edi+40], ecx
	inc	ebx
	jmp	SHORT $L30709
$L30772:

; 1023 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	edx, DWORD PTR __Dest$[esp+12]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax+4], ebp
	pop	ebp
	mov	DWORD PTR [eax], edx
	pop	ebx

; 1024 : 	}

	ret	0
??$_Copy_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
??$_Copy_backward_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z PROC NEAR ; std::_Copy_backward_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>, COMDAT

; 1048 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebx
	mov	ebx, DWORD PTR __Last$[esp+4]
	push	ebp
	mov	ebp, DWORD PTR __Last$[esp+4]
	push	esi
	push	edi
	npad	4
$L15265:

; 1049 : 	while (_First != _Last)

	cmp	DWORD PTR __First$[esp+12], ebp
	jne	SHORT $L30786
	cmp	DWORD PTR __First$[esp+16], ebx
	je	SHORT $L30843
$L30786:

; 1050 : 		*--_Dest = *--_Last;

	mov	eax, DWORD PTR [ebp+8]
	dec	ebx
	cmp	eax, ebx
	mov	ecx, ebx
	ja	SHORT $L30805
	sub	ecx, eax
$L30805:
	mov	eax, DWORD PTR __Dest$[esp+16]
	mov	edi, DWORD PTR __Dest$[esp+12]
	mov	edx, DWORD PTR [edi+8]
	dec	eax
	cmp	edx, eax
	mov	DWORD PTR __Dest$[esp+16], eax
	ja	SHORT $L30822
	sub	eax, edx
$L30822:
	mov	edx, DWORD PTR [ebp+4]
	mov	esi, DWORD PTR [edx+ecx*4]
	mov	ecx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	edx, esi
	mov	ecx, DWORD PTR [edx]
	mov	eax, edi
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [edx+8]
	push	-1
	mov	DWORD PTR [eax+8], edx
	push	0
	lea	eax, DWORD PTR [esi+12]
	push	eax
	lea	ecx, DWORD PTR [edi+12]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ecx, DWORD PTR [esi+40]
	mov	DWORD PTR [edi+40], ecx
	jmp	SHORT $L15265
$L30843:

; 1051 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[esp+12]
	mov	edx, DWORD PTR __Dest$[esp+12]
	mov	ecx, DWORD PTR __Dest$[esp+16]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebx

; 1052 : 	}

	ret	0
??$_Copy_backward_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$copy@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00@Z
_TEXT	SEGMENT
__Cat$30851 = -4					; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
??$copy@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00@Z PROC NEAR ; std::copy<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>, COMDAT
; ___$ReturnUdt$ = esi

; 1039 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ecx

; 1040 : 	return (_Copy_opt(_First, _Last, _Dest, _Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$30851[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First$[esp+16]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
	mov	eax, esi

; 1041 : 	}

	add	esp, 36					; 00000024H
	ret	0
??$copy@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00@Z ENDP ; std::copy<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??$copy_backward@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00@Z
_TEXT	SEGMENT
__Cat$30859 = -4					; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
??$copy_backward@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00@Z PROC NEAR ; std::copy_backward<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>, COMDAT
; ___$ReturnUdt$ = esi

; 1067 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ecx

; 1068 : 	return (_Copy_backward_opt(_First, _Last, _Dest,
; 1069 : 		_Ptr_cat(_First, _Dest)));

	mov	eax, DWORD PTR __Cat$30859[esp+4]
	mov	ecx, DWORD PTR __Dest$[esp+4]
	mov	edx, DWORD PTR __Dest$[esp]
	push	eax
	mov	eax, DWORD PTR __Last$[esp+8]
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+8]
	push	edx
	mov	edx, DWORD PTR __First$[esp+16]
	push	eax
	mov	eax, DWORD PTR __First$[esp+16]
	push	ecx
	push	edx
	push	eax
	push	esi
	call	??$_Copy_backward_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
	mov	eax, esi

; 1070 : 	}

	add	esp, 36					; 00000024H
	ret	0
??$copy_backward@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00@Z ENDP ; std::copy_backward<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T31001	DD	0ffffffffH
	DD	FLAT:$L30867
$T30999	DD	019930520H
	DD	01H
	DD	FLAT:$T31001
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
xdata$x	ENDS
;	COMDAT ??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z PROC NEAR ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>, COMDAT
; __Ptr$ = esi
; __Val$ = edi

; 41   : 	{	// construct object at _Ptr with value _Val

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ebx

; 42   : 	new ((void _FARQ *)_Ptr) _T1(_Val);

	xor	eax, eax
	cmp	esi, eax
	mov	DWORD PTR __$EHRec$[esp+24], eax
	je	SHORT $L30865
	mov	ecx, edi
	mov	ebx, DWORD PTR [ecx]
	mov	edx, esi
	mov	DWORD PTR [edx], ebx
	mov	ebx, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], ebx
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], ecx
	push	-1
	lea	ecx, DWORD PTR [esi+12]
	push	eax
	lea	edx, DWORD PTR [edi+12]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], eax
	push	edx
	mov	BYTE PTR [ecx+4], al
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [edi+40]
	mov	DWORD PTR [esi+40], eax
$L30865:

; 43   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+16]
	mov	DWORD PTR fs:__except_list, ecx
	pop	ebx
	add	esp, 12					; 0000000cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L30867:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z:
	mov	eax, OFFSET FLAT:$T30999
	jmp	___CxxFrameHandler
text$x	ENDS
??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ENDP ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
;	COMDAT ?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@V312@0@Z
_TEXT	SEGMENT
$T31040 = -16						; size = 8
__Off$ = -16						; size = 4
$T31089 = -8						; size = 8
$T31056 = -8						; size = 8
__Cat$31120 = 8						; size = 1
___$ReturnUdt$ = 8					; size = 4
$T31012 = 12						; size = 8
$T31010 = 12						; size = 8
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@V312@0@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase, COMDAT
; _this$ = eax

; 778  : 		{	// erase [_First, _Last)

	sub	esp, 16					; 00000010H

; 779  : 		size_type _Off = _First - begin();

	mov	edx, DWORD PTR __First$[esp+16]

; 780  : 		size_type _Count = _Last - _First;

	mov	ecx, DWORD PTR __Last$[esp+12]
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, eax
	mov	eax, DWORD PTR __First$[esp+28]
	mov	esi, DWORD PTR [edi+12]
	mov	DWORD PTR $T31040[esp+32], eax
	mov	eax, edx
	sub	eax, esi
	mov	DWORD PTR __Off$[esp+32], eax
	mov	DWORD PTR $T31056[esp+32], ecx
	mov	ecx, DWORD PTR __Last$[esp+32]
	mov	eax, ecx
	sub	eax, edx
	mov	ebx, eax

; 781  : 
; 782  : 		if (_Off < (size_type)(end() - _Last))

	mov	eax, DWORD PTR [edi+16]
	lea	ebp, DWORD PTR [eax+esi]
	mov	eax, ebp
	sub	eax, ecx
	cmp	DWORD PTR __Off$[esp+32], eax

; 783  : 			{	// closer to front
; 784  : 			copy_backward(begin(), _First, _Last);	// copy over hole

	mov	eax, DWORD PTR __Cat$31120[esp+28]
	mov	DWORD PTR $T31089[esp+32], edi
	push	eax
	jae	SHORT $L14432
	push	ecx
	mov	ecx, DWORD PTR __Last$[esp+36]
	push	ecx
	push	edx
	mov	edx, DWORD PTR __First$[esp+44]
	push	edx
	push	esi
	lea	eax, DWORD PTR $T31010[esp+52]
	push	edi
	push	eax
	call	??$_Copy_backward_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>

; 785  : 			for (; 0 < _Count; --_Count)

	xor	ebp, ebp
	add	esp, 32					; 00000020H
	cmp	ebx, ebp
	jbe	$L14457
$L14442:

; 786  : 				pop_front();	// pop copied elements

	cmp	DWORD PTR [edi+16], ebp
	je	SHORT $L14443
	mov	ecx, DWORD PTR [edi+12]
	mov	edx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [edx+ecx*4]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	mov	edx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+8]
	inc	edx
	mov	eax, edx
	cmp	ecx, eax
	mov	DWORD PTR [edi+12], edx
	ja	SHORT $L31151
	mov	DWORD PTR [edi+12], ebp
$L31151:
	dec	DWORD PTR [edi+16]
	jne	SHORT $L14443
	mov	DWORD PTR [edi+12], ebp
$L14443:

; 785  : 			for (; 0 < _Count; --_Count)

	dec	ebx
	jne	SHORT $L14442

; 787  : 			}
; 788  : 		else

	jmp	SHORT $L14457
$L14432:

; 789  : 			{	// closer to back
; 790  : 			copy(_Last, end(), _First);	// copy over hole

	mov	eax, DWORD PTR __Last$[esp+32]
	push	edx
	mov	edx, DWORD PTR __First$[esp+36]
	push	edx
	push	ebp
	push	edi
	push	ecx
	push	eax
	lea	ecx, DWORD PTR $T31012[esp+56]
	push	ecx
	call	??$_Copy_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>

; 791  : 			for (; 0 < _Count; --_Count)

	xor	ebp, ebp
	add	esp, 32					; 00000020H
	cmp	ebx, ebp
	jbe	SHORT $L14457
$L14455:

; 792  : 				pop_back();	// pop copied elements

	mov	eax, DWORD PTR [edi+16]
	cmp	eax, ebp
	je	SHORT $L14456
	mov	edx, DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [edi+8]
	lea	eax, DWORD PTR [eax+edx-1]
	cmp	ecx, eax
	ja	SHORT $L31221
	sub	eax, ecx
$L31221:
	mov	ecx, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [ecx+eax*4]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	dec	DWORD PTR [edi+16]
	jne	SHORT $L14456
	mov	DWORD PTR [edi+12], ebp
$L14456:

; 791  : 			for (; 0 < _Count; --_Count)

	dec	ebx
	jne	SHORT $L14455
$L14457:

; 793  : 			}
; 794  : 		return (begin() + _Off);

	mov	eax, DWORD PTR [edi+12]
	add	eax, DWORD PTR __Off$[esp+32]
	mov	ecx, DWORD PTR ___$ReturnUdt$[esp+28]
	mov	DWORD PTR [ecx], edi
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx
	pop	ebx

; 795  : 		}

	add	esp, 16					; 00000010H
	ret	20					; 00000014H
?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@V312@0@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = edx
; __Ptr$ = ecx
; __Count$ = eax

; 521  : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebx
	push	ebp
	mov	ebx, edx

; 522  : 		if (_Inside(_Ptr))

	mov	edx, DWORD PTR [ebx+24]
	cmp	edx, 16					; 00000010H
	push	esi
	push	edi
	mov	edi, eax
	mov	esi, ecx
	jb	SHORT $L31282
	mov	eax, DWORD PTR [ebx+4]
	jmp	SHORT $L31283
$L31282:
	lea	eax, DWORD PTR [ebx+4]
$L31283:
	cmp	esi, eax
	jb	SHORT $L14277
	cmp	edx, 16					; 00000010H
	lea	eax, DWORD PTR [ebx+4]
	jb	SHORT $L31286
	mov	ecx, DWORD PTR [eax]
	jmp	SHORT $L31287
$L31286:
	mov	ecx, eax
$L31287:
	mov	ebp, DWORD PTR [ebx+20]
	add	ebp, ecx
	cmp	ebp, esi
	jbe	SHORT $L14277

; 523  : 			return (append(*this, _Ptr - _Myptr(), _Count));	// substring

	cmp	edx, 16					; 00000010H
	jb	SHORT $L31299
	mov	eax, DWORD PTR [eax]
$L31299:
	sub	esi, eax
	push	esi
	mov	eax, edi
	mov	ecx, ebx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 534  : 		}

	ret	0
$L14277:

; 524  : 		if (npos - _Mysize <= _Count)

	mov	edx, DWORD PTR [ebx+20]
	or	eax, -1
	sub	eax, edx
	cmp	eax, edi
	ja	SHORT $L14278

; 525  : 			_String_base::_Xlen();	// result too long

	mov	ecx, ebx
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L14278:

; 526  : 
; 527  : 		size_type _Num;
; 528  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

	test	edi, edi
	jbe	$L31476
	mov	ebp, DWORD PTR [ebx+20]
	add	ebp, edi
	cmp	ebp, -2					; fffffffeH
	jbe	SHORT $L31398
	mov	ecx, ebx
	call	?_Xlen@_String_base@std@@QBEXXZ		; std::_String_base::_Xlen
$L31398:
	mov	eax, DWORD PTR [ebx+24]
	cmp	eax, ebp
	jae	SHORT $L31399
	mov	ecx, DWORD PTR [ebx+20]
	push	ecx
	push	ebp
	mov	ecx, ebx
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	ebp, ebp
$L31479:
	jbe	SHORT $L31476

; 529  : 			{	// make room and append new stuff
; 530  : 			_Traits::copy(_Myptr() + _Mysize, _Ptr, _Count);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	jb	SHORT $L31450
	mov	eax, DWORD PTR [ebx+4]
	jmp	SHORT $L31451

; 526  : 
; 527  : 		size_type _Num;
; 528  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$L31399:
	test	ebp, ebp
	jne	SHORT $L31479
	cmp	eax, 16					; 00000010H
	mov	DWORD PTR [ebx+20], ebp
	jb	SHORT $L31441
	mov	eax, DWORD PTR [ebx+4]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax], 0
	pop	ebp

; 532  : 			}
; 533  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 534  : 		}

	ret	0

; 526  : 
; 527  : 		size_type _Num;
; 528  : 		if (0 < _Count && _Grow(_Num = _Mysize + _Count))

$L31441:
	pop	edi
	lea	eax, DWORD PTR [ebx+4]
	pop	esi
	mov	BYTE PTR [eax], 0
	pop	ebp

; 532  : 			}
; 533  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 534  : 		}

	ret	0

; 529  : 			{	// make room and append new stuff
; 530  : 			_Traits::copy(_Myptr() + _Mysize, _Ptr, _Count);

$L31450:
	lea	eax, DWORD PTR [ebx+4]
$L31451:
	mov	ecx, edi
	mov	edi, DWORD PTR [ebx+20]
	mov	edx, ecx
	shr	ecx, 2
	add	edi, eax
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 531  : 			_Eos(_Num);

	cmp	DWORD PTR [ebx+24], 16			; 00000010H
	mov	DWORD PTR [ebx+20], ebp
	jb	SHORT $L31473
	mov	eax, DWORD PTR [ebx+4]
	pop	edi
	pop	esi
	mov	BYTE PTR [eax+ebp], 0
	pop	ebp

; 532  : 			}
; 533  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 534  : 		}

	ret	0

; 531  : 			_Eos(_Num);

$L31473:
	lea	eax, DWORD PTR [ebx+4]
	mov	BYTE PTR [eax+ebp], 0
$L31476:
	pop	edi
	pop	esi
	pop	ebp

; 532  : 			}
; 533  : 		return (*this);

	mov	eax, ebx
	pop	ebx

; 534  : 		}

	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z
_TEXT	SEGMENT
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z PROC NEAR ; std::allocator<Json::Reader::ErrorInfo>::construct, COMDAT
; __Ptr$ = esi
; __Val$ = edi

; 147  : 		_Construct(_Ptr, _Val);

	jmp	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
_TEXT	ENDS
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 621  : 		{	// assign [_Ptr, <null>)

	push	esi

; 622  : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	esi, DWORD PTR __Ptr$[esp]
	mov	eax, esi
	push	edi
	lea	edi, DWORD PTR [eax+1]
	npad	5
$L31489:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $L31489
	sub	eax, edi
	push	eax
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
	pop	esi

; 623  : 		}

	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; __Ptr$ = ecx

; 538  : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	eax, ecx
	push	esi
	lea	esi, DWORD PTR [eax+1]
$L31496:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $L31496
	mov	edx, DWORD PTR _this$[esp]
	sub	eax, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 539  : 		}

	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; __Ptr$ = ecx

; 487  : 		return (append(_Ptr));

	mov	eax, ecx
	push	esi
	lea	esi, DWORD PTR [eax+1]
$L31508:
	mov	dl, BYTE PTR [eax]
	inc	eax
	test	dl, dl
	jne	SHORT $L31508
	mov	edx, DWORD PTR _this$[esp]
	sub	eax, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 488  : 		}

	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; __Ptr$ = edx

; 472  : 		return (assign(_Ptr));

	mov	eax, edx
	push	esi
	lea	esi, DWORD PTR [eax+1]
$L31520:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $L31520
	mov	ecx, DWORD PTR _this$[esp]
	sub	eax, esi
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 473  : 		}

	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC NEAR ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 361  : 		_Tidy();
; 362  : 		assign(_Ptr);

	mov	edx, DWORD PTR __Ptr$[esp-4]
	push	esi
	mov	esi, ecx
	mov	eax, edx
	push	edi
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], 0
	mov	BYTE PTR [esi+4], 0
	lea	edi, DWORD PTR [eax+1]
	npad	1
$L31595:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $L31595
	sub	eax, edi
	push	eax
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi

; 363  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT
$T31601 = -60						; size = 4
_line$ = -60						; size = 4
_buffer$ = -56						; size = 51
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_column$ = 8						; size = 4
_location$ = 8						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC NEAR ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = edx
; ___$ReturnUdt$ = esi

; 688  : {

	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[esp+60], eax
	push	ebx

; 689  :    int line, column;
; 690  :    getLocationLineAndColumn( location, line, column );

	lea	eax, DWORD PTR _column$[esp+60]
	mov	DWORD PTR $T31601[esp+64], 0
	push	eax
	mov	eax, DWORD PTR _location$[esp+64]
	lea	ecx, DWORD PTR _line$[esp+68]
	mov	ebx, edx
	call	?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn

; 691  :    char buffer[18+16+16+1];
; 692  :    sprintf( buffer, "Line %d, Column %d", line, column );

	mov	ecx, DWORD PTR _column$[esp+60]
	mov	edx, DWORD PTR _line$[esp+64]
	push	ecx
	push	edx
	lea	eax, DWORD PTR _buffer$[esp+72]
	push	OFFSET FLAT:??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
	push	eax
	call	_sprintf
	add	esp, 16					; 00000010H

; 693  :    return buffer;

	xor	ebx, ebx
	lea	eax, DWORD PTR _buffer$[esp+64]
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	BYTE PTR [esi+4], bl
	lea	edx, DWORD PTR [eax+1]
	npad	5
$L31708:
	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, bl
	jne	SHORT $L31708
	sub	eax, edx
	push	eax
	lea	ecx, DWORD PTR _buffer$[esp+68]
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 694  : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+64]
	mov	eax, esi
	pop	ebx
	call	@__security_check_cookie@4
	add	esp, 60					; 0000003cH
	ret	4
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
PUBLIC	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T32107	DD	0ffffffffH
	DD	FLAT:$L31715
	DD	0ffffffffH
	DD	FLAT:$L31716
$T32104	DD	019930520H
	DD	02H
	DD	FLAT:$T32107
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
_TEXT	SEGMENT
$T31713 = -68						; size = 28
$T31714 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z PROC NEAR ; Json::Reader::addComment, COMDAT
; _begin$ = edi
; _end$ = edx
; _placement$ = ecx

; 289  : {

	push	-1
	mov	eax, DWORD PTR fs:__except_list
	push	__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+72]

; 290  :    assert( collectComments_ );
; 291  :    if ( placement == commentAfterOnSameLine )

	mov	eax, 1

; 292  :    {
; 293  :       assert( lastValue_ != 0 );
; 294  :       lastValue_->setComment( std::string( begin, end ), placement );

	xor	ebx, ebx
	cmp	ecx, eax
	push	esi
	mov	esi, edx
	jne	SHORT $L12852
	cmp	edi, esi
	mov	DWORD PTR $T31713[esp+104], 15		; 0000000fH
	mov	DWORD PTR $T31713[esp+100], ebx
	mov	BYTE PTR $T31713[esp+84], bl
	je	SHORT $L31802
	sub	esi, edi
	push	esi
	push	edi
	lea	ecx, DWORD PTR $T31713[esp+88]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L31802:
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	mov	eax, DWORD PTR $T31713[esp+104]
	mov	ecx, DWORD PTR [ebp+84]
	mov	esi, 16					; 00000010H
	cmp	eax, esi
	mov	eax, DWORD PTR $T31713[esp+84]
	jae	SHORT $L31831
	lea	eax, DWORD PTR $T31713[esp+84]
$L31831:
	push	1
	push	eax
	call	?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ; Json::Value::setComment
	cmp	DWORD PTR $T31713[esp+104], esi
	jb	SHORT $L32087
	mov	eax, DWORD PTR $T31713[esp+84]
	push	eax

; 295  :    }
; 296  :    else

	jmp	SHORT $L32106
$L12852:

; 297  :    {
; 298  :       if ( !commentsBefore_.empty() )

	cmp	DWORD PTR [ebp+108], ebx
	je	SHORT $L31921

; 299  :          commentsBefore_ += "\n";

	lea	edx, DWORD PTR [ebp+88]
	mov	ecx, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$L31921:

; 300  :       commentsBefore_ += std::string( begin, end );

	cmp	edi, esi
	mov	DWORD PTR $T31714[esp+104], 15		; 0000000fH
	mov	DWORD PTR $T31714[esp+100], ebx
	mov	BYTE PTR $T31714[esp+84], bl
	je	SHORT $L31992
	sub	esi, edi
	push	esi
	push	edi
	lea	ecx, DWORD PTR $T31714[esp+88]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L31992:
	push	ebx
	lea	ebx, DWORD PTR [ebp+88]
	or	eax, -1
	lea	ecx, DWORD PTR $T31714[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], 1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	cmp	DWORD PTR $T31714[esp+104], 16		; 00000010H
	jb	SHORT $L32087
	mov	ecx, DWORD PTR $T31714[esp+84]
	push	ecx
$L32106:
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L32087:

; 301  :    }
; 302  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 68					; 00000044H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L31715:
	lea	ecx, DWORD PTR $T31713[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L31716:
	lea	ecx, DWORD PTR $T31714[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z:
	mov	eax, OFFSET FLAT:$T32104
	jmp	___CxxFrameHandler
text$x	ENDS
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ENDP ; Json::Reader::addComment
PUBLIC	?readComment@Reader@Json@@AAE_NXZ		; Json::Reader::readComment
; Function compile flags: /Ogtpy
;	COMDAT ?readComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readComment@Reader@Json@@AAE_NXZ PROC NEAR		; Json::Reader::readComment, COMDAT
; _this$ = esi

; 260  :    Location commentBegin = current_ - 1;

	mov	eax, DWORD PTR [esi+76]

; 261  :    Char c = getNextChar();

	cmp	eax, DWORD PTR [esi+72]
	push	ebx
	push	edi
	lea	edi, DWORD PTR [eax-1]
	je	SHORT $L32130
	mov	bl, BYTE PTR [eax]
	inc	eax

; 262  :    bool successful = false;
; 263  :    if ( c == '*' )

	cmp	bl, 42					; 0000002aH
	mov	DWORD PTR [esi+76], eax
	jne	SHORT $L12836

; 264  :       successful = readCStyleComment();

	mov	ecx, esi
	call	?readCStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCStyleComment

; 265  :    else if ( c == '/' )

	jmp	SHORT $L12838
$L12836:
	cmp	bl, 47					; 0000002fH
	jne	SHORT $L32130

; 266  :       successful = readCppStyleComment();

	mov	edx, esi
	call	?readCppStyleComment@Reader@Json@@AAE_NXZ ; Json::Reader::readCppStyleComment
$L12838:

; 267  :    if ( !successful )

	test	al, al
	jne	SHORT $L12839
$L32130:
	pop	edi

; 268  :       return false;

	xor	al, al
	pop	ebx

; 282  : }

	ret	0
$L12839:

; 269  : 
; 270  :    if ( collectComments_ )

	mov	al, BYTE PTR [esi+116]
	test	al, al
	je	SHORT $L12840

; 271  :    {
; 272  :       CommentPlacement placement = commentBefore;
; 273  :       if ( lastValueEnd_  &&  !containsNewLine( lastValueEnd_, commentBegin ) )

	mov	eax, DWORD PTR [esi+80]
	push	ebp
	xor	ebp, ebp
	test	eax, eax
	je	SHORT $L12843
	cmp	eax, edi
	jae	SHORT $L32122
	npad	5
$L32120:
	mov	cl, BYTE PTR [eax]
	cmp	cl, 10					; 0000000aH
	je	SHORT $L12843
	cmp	cl, 13					; 0000000dH
	je	SHORT $L12843
	inc	eax
	cmp	eax, edi
	jb	SHORT $L32120
$L32122:

; 274  :       {
; 275  :          if ( c != '*'  ||  !containsNewLine( commentBegin, current_ ) )

	cmp	bl, 42					; 0000002aH
	jne	SHORT $L12844
	mov	edx, DWORD PTR [esi+76]
	mov	ecx, edi
	call	?containsNewLine@Json@@YA_NPBD0@Z	; Json::containsNewLine
	test	al, al
	jne	SHORT $L12843
$L12844:

; 276  :             placement = commentAfterOnSameLine;

	mov	ebp, 1
$L12843:

; 277  :       }
; 278  : 
; 279  :       addComment( commentBegin, current_, placement );

	mov	edx, DWORD PTR [esi+76]
	push	esi
	mov	ecx, ebp
	call	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
	pop	ebp
$L12840:
	pop	edi

; 280  :    }
; 281  :    return true;

	mov	al, 1
	pop	ebx

; 282  : }

	ret	0
?readComment@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readComment
_TEXT	ENDS
PUBLIC	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readToken
; Function compile flags: /Ogtpy
;	COMDAT ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z PROC NEAR	; Json::Reader::readToken, COMDAT
; _this$ = eax
; _token$ = edi

; 155  : {

	push	ebx
	push	esi
	mov	esi, eax

; 156  :    skipSpaces();

	mov	eax, DWORD PTR [esi+76]
	cmp	eax, DWORD PTR [esi+72]
	je	SHORT $L32141
	npad	4
$L32138:
	mov	ecx, DWORD PTR [esi+76]
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $L32142
	cmp	al, 9
	je	SHORT $L32142
	cmp	al, 13					; 0000000dH
	je	SHORT $L32142
	cmp	al, 10					; 0000000aH
	jne	SHORT $L32141
$L32142:
	inc	ecx
	mov	DWORD PTR [esi+76], ecx
	cmp	ecx, DWORD PTR [esi+72]
	jne	SHORT $L32138
$L32141:

; 157  :    token.start_ = current_;

	mov	edx, DWORD PTR [esi+76]
	mov	DWORD PTR [edi+4], edx

; 158  :    Char c = getNextChar();

	mov	eax, DWORD PTR [esi+76]
	cmp	eax, DWORD PTR [esi+72]
	jne	SHORT $L32147
	xor	cl, cl
	jmp	SHORT $L32146
$L32147:
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+76], eax
$L32146:

; 159  :    bool ok = true;
; 160  :    switch ( c )

	movsx	eax, cl
	cmp	eax, 125				; 0000007dH
	ja	SHORT $L32182
	movzx	eax, BYTE PTR $L32183[eax]
	jmp	DWORD PTR $L32184[eax*4]
$L12791:

; 161  :    {
; 162  :    case '{':
; 163  :       token.type_ = tokenObjectBegin;

	mov	DWORD PTR [edi], 1

; 223  :    token.end_ = current_;

	mov	eax, DWORD PTR [esi+76]
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12792:

; 164  :       break;
; 165  :    case '}':
; 166  :       token.type_ = tokenObjectEnd;

	mov	DWORD PTR [edi], 2

; 223  :    token.end_ = current_;

	mov	eax, DWORD PTR [esi+76]
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12793:

; 167  :       break;
; 168  :    case '[':
; 169  :       token.type_ = tokenArrayBegin;

	mov	DWORD PTR [edi], 3

; 223  :    token.end_ = current_;

	mov	eax, DWORD PTR [esi+76]
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12794:

; 170  :       break;
; 171  :    case ']':
; 172  :       token.type_ = tokenArrayEnd;

	mov	DWORD PTR [edi], 4

; 223  :    token.end_ = current_;

	mov	eax, DWORD PTR [esi+76]
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12795:

; 173  :       break;
; 174  :    case '"':
; 175  :       token.type_ = tokenString;
; 176  :       ok = readString();

	mov	edx, esi
	mov	DWORD PTR [edi], 5
	call	?readString@Reader@Json@@AAE_NXZ	; Json::Reader::readString
$L12788:

; 216  :       break;
; 217  :    default:
; 218  :       ok = false;
; 219  :       break;
; 220  :    }
; 221  :    if ( !ok )

	test	al, al
	jne	SHORT $L12808
$L32182:

; 222  :       token.type_ = tokenError;

	mov	DWORD PTR [edi], 13			; 0000000dH
$L12808:

; 223  :    token.end_ = current_;

	mov	eax, DWORD PTR [esi+76]
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12796:

; 177  :       break;
; 178  :    case '/':
; 179  :       token.type_ = tokenComment;

	mov	DWORD PTR [edi], 12			; 0000000cH

; 180  :       ok = readComment();

	call	?readComment@Reader@Json@@AAE_NXZ	; Json::Reader::readComment

; 181  :       break;

	jmp	SHORT $L12788
$L12797:

; 182  :    case '0':
; 183  :    case '1':
; 184  :    case '2':
; 185  :    case '3':
; 186  :    case '4':
; 187  :    case '5':
; 188  :    case '6':
; 189  :    case '7':
; 190  :    case '8':
; 191  :    case '9':
; 192  :    case '-':
; 193  :       token.type_ = tokenNumber;
; 194  :       readNumber();

	mov	edx, esi
	mov	DWORD PTR [edi], 6
	call	?readNumber@Reader@Json@@AAEXXZ		; Json::Reader::readNumber

; 223  :    token.end_ = current_;

	mov	eax, DWORD PTR [esi+76]
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12798:

; 195  :       break;
; 196  :    case 't':
; 197  :       token.type_ = tokenTrue;

	mov	DWORD PTR [edi], 7

; 198  :       ok = match( "rue", 3 );

	mov	ecx, DWORD PTR [esi+76]
	mov	edx, DWORD PTR [esi+72]
	sub	edx, ecx
	cmp	edx, 3
	jl	SHORT $L32182
	mov	eax, 3
	npad	1
$L32153:
	mov	dl, BYTE PTR [ecx+eax-1]
	mov	bl, BYTE PTR ??_C@_03FFDNHNKN@rue?$AA@[eax-1]
	dec	eax
	cmp	dl, bl
	jne	SHORT $L32182
	test	eax, eax
	jne	SHORT $L32153
	add	ecx, 3
	mov	DWORD PTR [esi+76], ecx

; 223  :    token.end_ = current_;

	mov	eax, ecx
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12800:

; 199  :       break;
; 200  :    case 'f':
; 201  :       token.type_ = tokenFalse;

	mov	DWORD PTR [edi], 8

; 202  :       ok = match( "alse", 4 );

	mov	ecx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR [esi+72]
	sub	eax, ecx
	cmp	eax, 4
	jl	$L32182
	mov	eax, 4
	npad	1
$L32161:
	mov	dl, BYTE PTR [ecx+eax-1]
	mov	bl, BYTE PTR ??_C@_04KCECFHEP@alse?$AA@[eax-1]
	dec	eax
	cmp	dl, bl
	jne	$L32182
	test	eax, eax
	jne	SHORT $L32161
	add	ecx, 4
	mov	DWORD PTR [esi+76], ecx

; 223  :    token.end_ = current_;

	mov	eax, ecx
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12802:

; 203  :       break;
; 204  :    case 'n':
; 205  :       token.type_ = tokenNull;

	mov	DWORD PTR [edi], 9

; 206  :       ok = match( "ull", 3 );

	mov	ecx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR [esi+72]
	sub	eax, ecx
	cmp	eax, 3
	jl	$L32182
	mov	eax, 3
$L32169:
	mov	dl, BYTE PTR [ecx+eax-1]
	mov	bl, BYTE PTR ??_C@_03KNPGGKC@ull?$AA@[eax-1]
	dec	eax
	cmp	dl, bl
	jne	$L32182
	test	eax, eax
	jne	SHORT $L32169
	add	ecx, 3
	mov	DWORD PTR [esi+76], ecx

; 223  :    token.end_ = current_;

	mov	eax, ecx
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12804:

; 207  :       break;
; 208  :    case ',':
; 209  :       token.type_ = tokenArraySeparator;

	mov	DWORD PTR [edi], 10			; 0000000aH

; 223  :    token.end_ = current_;

	mov	eax, DWORD PTR [esi+76]
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12805:

; 210  :       break;
; 211  :    case ':':
; 212  :       token.type_ = tokenMemberSeparator;

	mov	DWORD PTR [edi], 11			; 0000000bH

; 223  :    token.end_ = current_;

	mov	eax, DWORD PTR [esi+76]
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
$L12806:

; 213  :       break;
; 214  :    case 0:
; 215  :       token.type_ = tokenEndOfStream;

	mov	DWORD PTR [edi], 0

; 223  :    token.end_ = current_;

	mov	eax, DWORD PTR [esi+76]
	pop	esi
	mov	DWORD PTR [edi+8], eax

; 224  :    return true;

	mov	al, 1
	pop	ebx

; 225  : }

	ret	0
	npad	3
$L32184:
	DD	$L12806
	DD	$L12795
	DD	$L12804
	DD	$L12797
	DD	$L12796
	DD	$L12805
	DD	$L12793
	DD	$L12794
	DD	$L12800
	DD	$L12802
	DD	$L12798
	DD	$L12791
	DD	$L12792
	DD	$L32182
$L32183:
	DB	0
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	1
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	2
	DB	3
	DB	13					; 0000000dH
	DB	4
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	6
	DB	13					; 0000000dH
	DB	7
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	8
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	9
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	10					; 0000000aH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	11					; 0000000bH
	DB	13					; 0000000dH
	DB	12					; 0000000cH
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readToken
_TEXT	ENDS
PUBLIC	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens
; Function compile flags: /Ogtpy
;	COMDAT ?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z
_TEXT	SEGMENT
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z PROC NEAR ; Json::Reader::skipCommentTokens, COMDAT
; _this$ = esi
; _token$ = eax

; 134  : {

	push	edi
	mov	edi, eax
$L12769:

; 135  :    do
; 136  :    {
; 137  :       readToken( token );

	mov	eax, esi
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 138  :    }
; 139  :    while ( token.type_ == tokenComment );

	cmp	DWORD PTR [edi], 12			; 0000000cH
	je	SHORT $L12769
	pop	edi

; 140  : }

	ret	0
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ENDP	; Json::Reader::skipCommentTokens
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T38223	DD	0ffffffffH
	DD	FLAT:$L37938
$T38219	DD	019930520H
	DD	01H
	DD	FLAT:$T38223
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
_TEXT	SEGMENT
$T37940 = -44						; size = 4
$T37937 = -40						; size = 28
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = esi
; __Right$ = edi

; 51   : 	{	// return string + NTCS

	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 32					; 00000020H

; 52   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

	mov	eax, DWORD PTR __Left$[esp+40]
	push	ebx
	push	ebp
	xor	ebx, ebx
	push	-1
	push	ebx
	push	eax
	lea	ecx, DWORD PTR $T37937[esp+64]
	mov	DWORD PTR $T37940[esp+64], ebx
	mov	DWORD PTR $T37937[esp+88], 15		; 0000000fH
	mov	DWORD PTR $T37937[esp+84], ebx
	mov	BYTE PTR $T37937[esp+68], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, edi
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	lea	ebp, DWORD PTR [eax+1]
	npad	6
$L38220:
	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, bl
	jne	SHORT $L38220
	sub	eax, ebp
	mov	ecx, edi
	lea	edx, DWORD PTR $T37937[esp+52]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	push	-1
	push	ebx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	push	eax
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR $T37937[esp+76], 16		; 00000010H
	pop	ebp
	pop	ebx
	jb	SHORT $L38221
	mov	ecx, DWORD PTR $T37937[esp+48]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L38221:

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	eax, esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L37938:
	lea	ecx, DWORD PTR $T37937[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:
	mov	eax, OFFSET FLAT:$T38219
	jmp	___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T38520	DD	0ffffffffH
	DD	FLAT:$L38230
$T38516	DD	019930520H
	DD	01H
	DD	FLAT:$T38520
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\string
xdata$x	ENDS
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
$T38232 = -44						; size = 4
$T38229 = -40						; size = 28
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC NEAR ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = esi
; __Left$ = ecx

; 31   : 	{	// return NTCS + string

	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 32					; 00000020H
	push	ebx

; 32   : 	return (basic_string<_Elem, _Traits, _Alloc>(_Left) += _Right);

	xor	ebx, ebx
	mov	eax, ecx
	push	edi
	mov	DWORD PTR $T38232[esp+52], ebx
	mov	DWORD PTR $T38229[esp+76], 15		; 0000000fH
	mov	DWORD PTR $T38229[esp+72], ebx
	mov	BYTE PTR $T38229[esp+56], bl
	lea	edi, DWORD PTR [eax+1]
$L38517:
	mov	dl, BYTE PTR [eax]
	inc	eax
	cmp	dl, bl
	jne	SHORT $L38517
	sub	eax, edi
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T38229[esp+60]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ecx, DWORD PTR __Right$[esp+48]
	mov	DWORD PTR __$EHRec$[esp+60], ebx
	push	ebx
	or	eax, -1
	lea	ebx, DWORD PTR $T38229[esp+56]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	xor	ecx, ecx
	push	-1
	mov	DWORD PTR [esi+20], ecx
	push	ecx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	BYTE PTR [esi+4], cl
	push	eax
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR $T38229[esp+76], 16		; 00000010H
	pop	edi
	pop	ebx
	jb	SHORT $L38518
	mov	eax, DWORD PTR $T38229[esp+48]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L38518:

; 33   : 	}

	mov	ecx, DWORD PTR __$EHRec$[esp+44]
	mov	eax, esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 44					; 0000002cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L38230:
	lea	ecx, DWORD PTR $T38229[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
	mov	eax, OFFSET FLAT:$T38516
	jmp	___CxxFrameHandler
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T38801	DD	0ffffffffH
	DD	FLAT:$L38528
	DD	00H
	DD	FLAT:$L38637
$T38798	DD	019930520H
	DD	02H
	DD	FLAT:$T38801
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
xdata$x	ENDS
;	COMDAT ?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T38527 = -80						; size = 28
$T38526 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen, COMDAT

; 897  : 		{	// report length error

	push	-1
	push	__ehhandler$?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx

; 898  : 		_THROW(length_error, "deque<T> too long");

	push	17					; 00000011H
	xor	ebx, ebx
	push	OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T38527[esp+92]
	mov	DWORD PTR $T38527[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T38527[esp+112], ebx
	mov	BYTE PTR $T38527[esp+96], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T38526[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], ebx
	call	??0exception@@QAE@XZ			; exception::exception
	push	-1
	mov	BYTE PTR __$EHRec$[esp+96], 1
	push	ebx
	lea	eax, DWORD PTR $T38527[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T38526[esp+108]
	mov	DWORD PTR $T38526[esp+96], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	DWORD PTR $T38526[esp+132], 15		; 0000000fH
	mov	DWORD PTR $T38526[esp+128], ebx
	mov	BYTE PTR $T38526[esp+112], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T38526[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], bl
	push	ecx
	mov	DWORD PTR $T38526[esp+92], OFFSET FLAT:??_7length_error@std@@6B@
	call	__CxxThrowException@8
	pop	ebx
$L38802:
$L38800:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L38528:
	lea	ecx, DWORD PTR $T38527[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L38637:
	lea	ecx, DWORD PTR $T38526[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ:
	mov	eax, OFFSET FLAT:$T38798
	jmp	___CxxFrameHandler
text$x	ENDS
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T39083	DD	0ffffffffH
	DD	FLAT:$L38810
	DD	00H
	DD	FLAT:$L38919
$T39080	DD	019930520H
	DD	02H
	DD	FLAT:$T39083
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
xdata$x	ENDS
;	COMDAT ?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
$T38809 = -80						; size = 28
$T38808 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen, COMDAT

; 897  : 		{	// report length error

	push	-1
	push	__ehhandler$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 68					; 00000044H
	push	ebx

; 898  : 		_THROW(length_error, "deque<T> too long");

	push	17					; 00000011H
	xor	ebx, ebx
	push	OFFSET FLAT:??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T38809[esp+92]
	mov	DWORD PTR $T38809[esp+116], 15		; 0000000fH
	mov	DWORD PTR $T38809[esp+112], ebx
	mov	BYTE PTR $T38809[esp+96], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	lea	ecx, DWORD PTR $T38808[esp+84]
	mov	DWORD PTR __$EHRec$[esp+92], ebx
	call	??0exception@@QAE@XZ			; exception::exception
	push	-1
	mov	BYTE PTR __$EHRec$[esp+96], 1
	push	ebx
	lea	eax, DWORD PTR $T38809[esp+92]
	push	eax
	lea	ecx, DWORD PTR $T38808[esp+108]
	mov	DWORD PTR $T38808[esp+96], OFFSET FLAT:??_7logic_error@std@@6B@
	mov	DWORD PTR $T38808[esp+132], 15		; 0000000fH
	mov	DWORD PTR $T38808[esp+128], ebx
	mov	BYTE PTR $T38808[esp+112], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	OFFSET FLAT:__TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T38808[esp+88]
	mov	BYTE PTR __$EHRec$[esp+96], bl
	push	ecx
	mov	DWORD PTR $T38808[esp+92], OFFSET FLAT:??_7length_error@std@@6B@
	call	__CxxThrowException@8
	pop	ebx
$L39084:
$L39082:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L38810:
	lea	ecx, DWORD PTR $T38809[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L38919:
	lea	ecx, DWORD PTR $T38808[ebp]
	jmp	??1exception@@UAE@XZ			; exception::~exception
__ehhandler$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ:
	mov	eax, OFFSET FLAT:$T39080
	jmp	___CxxFrameHandler
text$x	ENDS
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
; Function compile flags: /Ogtpy
;	COMDAT ?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Newmap$ = -12						; size = 4
$T39154 = -8						; size = 4
tv356 = -4						; size = 4
tv349 = -4						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap, COMDAT
; _this$ = ebx

; 908  : 		if (max_size() / _DEQUESIZ - _Mapsize < _Count)

	mov	eax, DWORD PTR [ebx+8]
	sub	esp, 12					; 0000000cH
	mov	ecx, 268435455				; 0fffffffH
	push	edi
	mov	edi, DWORD PTR __Count$[esp+12]
	sub	ecx, eax
	cmp	ecx, edi
	jae	SHORT $L14326

; 909  : 			_Xlen();	// result too long

	call	?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
$L39338:
$L14326:

; 910  : 
; 911  : 		size_type _Inc = _Mapsize / 2;	// try to grow by 50%

	mov	ecx, eax
	shr	ecx, 1

; 912  : 		if (_Inc < _DEQUEMAPSIZ)

	cmp	ecx, 8
	jae	SHORT $L14328

; 913  : 			_Inc = _DEQUEMAPSIZ;

	mov	ecx, 8
$L14328:

; 914  : 		if (_Count < _Inc && _Mapsize <= max_size() / _DEQUESIZ - _Inc)

	cmp	edi, ecx
	jae	SHORT $L14329
	mov	edx, 268435455				; 0fffffffH
	sub	edx, ecx
	cmp	eax, edx
	ja	SHORT $L14329

; 915  : 			_Count = _Inc;

	mov	DWORD PTR __Count$[esp+12], ecx
	mov	edi, ecx
$L14329:
	push	ebp

; 916  : 		size_type _Myboff = _Myoff / _DEQUESIZ;

	mov	ebp, DWORD PTR [ebx+12]

; 917  : 		_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);

	add	eax, edi
	shl	eax, 2
	push	esi
	push	eax
	shr	ebp, 2
	call	??2@YAPAXI@Z				; operator new

; 918  : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 919  : 
; 920  : 		_Myptr = _Uninitialized_copy(_Map + _Myboff,
; 921  : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, eax
	lea	esi, DWORD PTR [ebp*4]
	lea	eax, DWORD PTR [esi+ecx]
	mov	DWORD PTR $T39154[esp+28], eax
	mov	eax, DWORD PTR [ebx+8]
	shl	eax, 2
	sub	eax, DWORD PTR $T39154[esp+28]
	mov	DWORD PTR __Newmap$[esp+28], edx
	add	eax, ecx
	mov	ecx, DWORD PTR $T39154[esp+28]
	sar	eax, 2
	shl	eax, 2
	push	eax
	push	ecx
	add	edx, esi
	push	edx
	mov	DWORD PTR tv349[esp+40], eax
	call	_memmove
	mov	edx, DWORD PTR tv349[esp+40]

; 922  : 		if (_Myboff <= _Count)
; 923  : 			{	// increment greater than offset of initial block
; 924  : 			_Myptr = _Uninitialized_copy(_Map,
; 925  : 				_Map + _Myboff, _Myptr, this->_Almap);	// copy rest of old

	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 16					; 00000010H
	add	eax, edx
	cmp	ebp, edi
	ja	SHORT $L14342
	sar	esi, 2
	mov	edx, esi
	shl	edx, 2
	push	edx
	push	ecx

; 926  : 			_Uninitialized_fill_n(_Myptr, _Count - _Myboff,
; 927  : 				(_Tptr)0, this->_Almap);	// clear suffix of new

	mov	esi, edi
	push	eax
	sub	esi, ebp
	mov	DWORD PTR tv356[esp+36], edx
	call	_memmove
	mov	ecx, DWORD PTR tv356[esp+36]
	mov	edx, eax
	add	esp, 12					; 0000000cH
	add	edx, ecx
	test	esi, esi
	jbe	SHORT $L39206
	mov	ecx, esi
	xor	eax, eax
	mov	edi, edx
	rep stosd
	mov	edi, DWORD PTR __Count$[esp+20]
$L39206:

; 928  : 			_Uninitialized_fill_n(_Newmap, _Myboff,
; 929  : 				(_Tptr)0, this->_Almap);	// clear prefix of new

	test	ebp, ebp
	jbe	SHORT $L39335
	mov	edi, DWORD PTR __Newmap$[esp+24]
	mov	ecx, ebp

; 930  : 			}
; 931  : 		else

	jmp	SHORT $L39337
$L14342:

; 932  : 			{	// increment not greater than offset of initial block
; 933  : 			_Uninitialized_copy(_Map,
; 934  : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

	lea	ebp, DWORD PTR [edi*4]
	mov	edx, ebp
	sar	edx, 2
	shl	edx, 2
	push	edx
	push	ecx
	push	eax
	call	_memmove

; 935  : 			_Myptr = _Uninitialized_copy(_Map + _Count,
; 936  : 				_Map + _Myboff, _Newmap, this->_Almap);	// copy rest of old

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [eax+ebp]
	sub	esi, ecx
	add	esi, eax
	mov	eax, DWORD PTR __Newmap$[esp+36]
	sar	esi, 2
	shl	esi, 2
	push	esi
	push	ecx
	push	eax
	call	_memmove
	mov	edx, eax
	add	esp, 24					; 00000018H
	add	edx, esi

; 937  : 			_Uninitialized_fill_n(_Myptr, _Count,
; 938  : 				(_Tptr)0, this->_Almap);	// clear rest to initial block

	test	edi, edi
	jbe	SHORT $L39335
	mov	ecx, edi
	mov	edi, edx
$L39337:
	xor	eax, eax
	rep stosd
	mov	edi, DWORD PTR __Count$[esp+20]
$L39335:

; 939  : 			}
; 940  : 
; 941  : 		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);
; 942  : 		if (_Map)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	pop	esi
	pop	ebp
	je	SHORT $L39324

; 943  : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for old

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L39324:

; 944  : 
; 945  : 		_Map = _Newmap;	// point at new
; 946  : 		_Mapsize += _Count;

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR __Newmap$[esp+16]
	add	eax, edi
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx+8], eax
	pop	edi

; 947  : 		}

	add	esp, 12					; 0000000cH
	ret	4
$L39336:
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
$T39406 = -12						; size = 4
tv353 = -8						; size = 4
tv346 = -8						; size = 4
__Myboff$ = -4						; size = 4
__Newmap$ = 8						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap, COMDAT
; _this$ = ebx

; 908  : 		if (max_size() / _DEQUESIZ - _Mapsize < _Count)

	mov	eax, DWORD PTR [ebx+8]
	sub	esp, 12					; 0000000cH
	mov	ecx, 97612893				; 05d1745dH
	push	ebp
	mov	ebp, DWORD PTR __Count$[esp+12]
	sub	ecx, eax
	cmp	ecx, ebp
	jae	SHORT $L14180

; 909  : 			_Xlen();	// result too long

	call	?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
$L39590:
$L14180:

; 910  : 
; 911  : 		size_type _Inc = _Mapsize / 2;	// try to grow by 50%

	mov	ecx, eax
	shr	ecx, 1

; 912  : 		if (_Inc < _DEQUEMAPSIZ)

	cmp	ecx, 8
	jae	SHORT $L14182

; 913  : 			_Inc = _DEQUEMAPSIZ;

	mov	ecx, 8
$L14182:

; 914  : 		if (_Count < _Inc && _Mapsize <= max_size() / _DEQUESIZ - _Inc)

	cmp	ebp, ecx
	jae	SHORT $L14183
	mov	edx, 97612893				; 05d1745dH
	sub	edx, ecx
	cmp	eax, edx
	ja	SHORT $L14183

; 915  : 			_Count = _Inc;

	mov	ebp, ecx
$L14183:
	push	esi

; 916  : 		size_type _Myboff = _Myoff / _DEQUESIZ;
; 917  : 		_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);

	add	eax, ebp
	push	edi
	mov	edi, DWORD PTR [ebx+12]
	shl	eax, 2
	push	eax
	mov	DWORD PTR __Myboff$[esp+28], edi
	call	??2@YAPAXI@Z				; operator new

; 918  : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 919  : 
; 920  : 		_Myptr = _Uninitialized_copy(_Map + _Myboff,
; 921  : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	ecx, DWORD PTR [ebx+4]
	mov	edx, eax
	lea	esi, DWORD PTR [edi*4]
	lea	eax, DWORD PTR [esi+ecx]
	mov	DWORD PTR $T39406[esp+28], eax
	mov	eax, DWORD PTR [ebx+8]
	shl	eax, 2
	sub	eax, DWORD PTR $T39406[esp+28]
	mov	DWORD PTR __Newmap$[esp+24], edx
	add	eax, ecx
	mov	ecx, DWORD PTR $T39406[esp+28]
	sar	eax, 2
	shl	eax, 2
	push	eax
	push	ecx
	add	edx, esi
	push	edx
	mov	DWORD PTR tv346[esp+40], eax
	call	_memmove
	mov	edx, DWORD PTR tv346[esp+40]

; 922  : 		if (_Myboff <= _Count)
; 923  : 			{	// increment greater than offset of initial block
; 924  : 			_Myptr = _Uninitialized_copy(_Map,
; 925  : 				_Map + _Myboff, _Myptr, this->_Almap);	// copy rest of old

	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 16					; 00000010H
	add	eax, edx
	cmp	edi, ebp
	ja	SHORT $L14196
	sar	esi, 2
	mov	edx, esi
	shl	edx, 2
	push	edx
	push	ecx

; 926  : 			_Uninitialized_fill_n(_Myptr, _Count - _Myboff,
; 927  : 				(_Tptr)0, this->_Almap);	// clear suffix of new

	mov	esi, ebp
	push	eax
	sub	esi, edi
	mov	DWORD PTR tv353[esp+36], edx
	call	_memmove
	mov	ecx, DWORD PTR tv353[esp+36]
	mov	edx, eax
	add	esp, 12					; 0000000cH
	add	edx, ecx
	test	esi, esi
	jbe	SHORT $L39458
	mov	ecx, esi
	xor	eax, eax
	mov	edi, edx
	rep stosd
	mov	edi, DWORD PTR __Myboff$[esp+24]
$L39458:

; 928  : 			_Uninitialized_fill_n(_Newmap, _Myboff,
; 929  : 				(_Tptr)0, this->_Almap);	// clear prefix of new

	test	edi, edi
	jbe	SHORT $L39587
	mov	ecx, edi
	mov	edi, DWORD PTR __Newmap$[esp+20]

; 930  : 			}
; 931  : 		else

	jmp	SHORT $L39589
$L14196:

; 932  : 			{	// increment not greater than offset of initial block
; 933  : 			_Uninitialized_copy(_Map,
; 934  : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

	lea	edi, DWORD PTR [ebp*4]
	mov	edx, edi
	sar	edx, 2
	shl	edx, 2
	push	edx
	push	ecx
	push	eax
	call	_memmove

; 935  : 			_Myptr = _Uninitialized_copy(_Map + _Count,
; 936  : 				_Map + _Myboff, _Newmap, this->_Almap);	// copy rest of old

	mov	eax, DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR [edi+eax]
	sub	esi, ecx
	add	esi, eax
	mov	eax, DWORD PTR __Newmap$[esp+32]
	sar	esi, 2
	shl	esi, 2
	push	esi
	push	ecx
	push	eax
	call	_memmove
	mov	edi, eax
	add	esp, 24					; 00000018H
	add	edi, esi

; 937  : 			_Uninitialized_fill_n(_Myptr, _Count,
; 938  : 				(_Tptr)0, this->_Almap);	// clear rest to initial block

	test	ebp, ebp
	jbe	SHORT $L39587

; 932  : 			{	// increment not greater than offset of initial block
; 933  : 			_Uninitialized_copy(_Map,
; 934  : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

	mov	ecx, ebp
$L39589:
	xor	eax, eax
	rep stosd
$L39587:

; 939  : 			}
; 940  : 
; 941  : 		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);
; 942  : 		if (_Map)

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	pop	edi
	pop	esi
	je	SHORT $L39576

; 943  : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for old

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L39576:

; 944  : 
; 945  : 		_Map = _Newmap;	// point at new
; 946  : 		_Mapsize += _Count;

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR __Newmap$[esp+12]
	add	eax, ebp
	mov	DWORD PTR [ebx+4], ecx
	mov	DWORD PTR [ebx+8], eax
	pop	ebp

; 947  : 		}

	add	esp, 12					; 0000000cH
	ret	4
$L39588:
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC NEAR ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back, COMDAT
; _this$ = eax

; 583  : 		{	// insert element at end

	push	ebx
	mov	ebx, eax

; 584  : 		if ((_Myoff + _Mysize) % _DEQUESIZ == 0
; 585  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [ebx+12]
	add	ecx, eax
	test	cl, 3
	jne	SHORT $L14107
	mov	ecx, DWORD PTR [ebx+8]
	add	eax, 4
	shr	eax, 2
	cmp	ecx, eax
	ja	SHORT $L14107

; 586  : 			_Growmap(1);

	push	1
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$L14107:

; 587  : 		size_type _Newoff = _Myoff + _Mysize;
; 588  : 		size_type _Block = _Newoff / _DEQUESIZ;
; 589  : 		if (_Mapsize <= _Block)

	mov	eax, DWORD PTR [ebx+8]
	push	esi
	mov	esi, DWORD PTR [ebx+12]
	push	edi
	add	esi, DWORD PTR [ebx+16]
	mov	edi, esi
	shr	edi, 2
	cmp	eax, edi
	ja	SHORT $L14110

; 590  : 			_Block -= _Mapsize;

	sub	edi, eax
$L14110:

; 591  : 		if (_Map[_Block] == 0)

	mov	edx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [edx+edi*4], 0
	jne	SHORT $L14111

; 592  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR [ecx+edi*4], eax
$L14111:

; 593  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [edx+edi*4]
	and	esi, 3
	lea	eax, DWORD PTR [eax+esi*4]
	test	eax, eax
	pop	edi
	pop	esi
	je	SHORT $L39627
	mov	ecx, DWORD PTR __Val$[esp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
$L39627:

; 594  : 		++_Mysize;

	inc	DWORD PTR [ebx+16]
	pop	ebx

; 595  : 		}

	ret	4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back, COMDAT
; _this$ = eax
; __Val$ = edi

; 583  : 		{	// insert element at end

	push	ebx
	mov	ebx, eax

; 584  : 		if ((_Myoff + _Mysize) % _DEQUESIZ == 0
; 585  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [ebx+8]
	inc	eax
	cmp	ecx, eax
	push	esi
	ja	SHORT $L13716

; 586  : 			_Growmap(1);

	push	1
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$L13716:

; 587  : 		size_type _Newoff = _Myoff + _Mysize;

	mov	esi, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR [ebx+16]

; 588  : 		size_type _Block = _Newoff / _DEQUESIZ;
; 589  : 		if (_Mapsize <= _Block)

	mov	eax, DWORD PTR [ebx+8]
	add	esi, edx
	cmp	eax, esi
	ja	SHORT $L13719

; 590  : 			_Block -= _Mapsize;

	sub	esi, eax
$L13719:

; 591  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx+esi*4], 0
	jne	SHORT $L13720

; 592  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	mov	edx, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR [edx+esi*4], eax
$L13720:

; 593  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [eax+esi*4]
	call	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>

; 594  : 		++_Mysize;

	mov	eax, DWORD PTR [ebx+16]
	inc	eax
	pop	esi
	mov	DWORD PTR [ebx+16], eax
	pop	ebx

; 595  : 		}

	ret	0
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\stack
_TEXT	ENDS
;	COMDAT ?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC NEAR ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push, COMDAT
; __Val$ = eax

; 53   : 		c.push_back(_Val);

	push	eax
	mov	eax, DWORD PTR _this$[esp]
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back

; 54   : 		}

	ret	4
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
_TEXT	ENDS
PUBLIC	?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormatedErrorMessages
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T40592	DD	0ffffffffH
	DD	FLAT:$L39659
	DD	00H
	DD	FLAT:$L39660
	DD	01H
	DD	FLAT:$L39661
	DD	02H
	DD	FLAT:$L39662
	DD	00H
	DD	FLAT:$L39663
	DD	04H
	DD	FLAT:$L39664
	DD	00H
	DD	FLAT:$L39665
	DD	06H
	DD	FLAT:$L39666
	DD	07H
	DD	FLAT:$L39667
$T40585	DD	019930520H
	DD	09H
	DD	FLAT:$T40592
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T39669 = -276						; size = 4
_itError$13330 = -276					; size = 8
$T39651 = -268						; size = 28
$T39655 = -240						; size = 28
$T39654 = -212						; size = 28
$T39652 = -184						; size = 28
$T39658 = -156						; size = 28
$T39653 = -128						; size = 28
$T39657 = -100						; size = 28
$T39656 = -72						; size = 28
_formattedMessage$ = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC NEAR ; Json::Reader::getFormatedErrorMessages, COMDAT

; 699  : {

	push	-1
	push	__ehhandler$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	push	ebx
	push	ebp

; 700  :    std::string formattedMessage;
; 701  :    for ( Errors::const_iterator itError = errors_.begin();
; 702  :          itError != errors_.end();
; 703  :          ++itError )

	xor	ebx, ebx
	mov	DWORD PTR $T39669[esp+284], ebx
	push	esi
	mov	DWORD PTR __$ArrayPad$[esp+288], eax
	push	edi
	mov	DWORD PTR _formattedMessage$[esp+316], 15 ; 0000000fH
	mov	DWORD PTR _formattedMessage$[esp+312], ebx
	mov	BYTE PTR _formattedMessage$[esp+296], bl
	mov	edx, DWORD PTR _this$[esp+288]
	mov	DWORD PTR __$EHRec$[esp+300], ebx
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR _itError$13330[esp+296], eax
	npad	1
$L39775:
	mov	esi, DWORD PTR [edx+36]
	mov	ebp, DWORD PTR [edx+32]
	lea	ecx, DWORD PTR [edx+20]
	add	esi, ebp
	cmp	ecx, ecx
	jne	SHORT $L39798
	cmp	eax, esi
	je	$L40588
$L39798:

; 704  :    {
; 705  :       const ErrorInfo &error = *itError;

	mov	esi, DWORD PTR [ecx+8]
	cmp	esi, eax
	ja	SHORT $L39805
	sub	eax, esi
$L39805:
	mov	ecx, DWORD PTR [ecx+4]
	mov	ebp, DWORD PTR [ecx+eax*4]

; 706  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	mov	eax, DWORD PTR [ebp+4]
	push	eax
	lea	esi, DWORD PTR $T39651[esp+296]
	call	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
	push	eax
	mov	ecx, OFFSET FLAT:??_C@_02KAOAMBHJ@?$CK?5?$AA@
	lea	esi, DWORD PTR $T39652[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 1
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	eax
	mov	edi, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	lea	esi, DWORD PTR $T39653[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 2
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	mov	ecx, eax
	push	ebx
	or	eax, -1
	lea	ebx, DWORD PTR _formattedMessage$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 3
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	eax, DWORD PTR $T39653[esp+316]
	mov	esi, 16					; 00000010H
	cmp	eax, esi
	jb	SHORT $L39879
	mov	ecx, DWORD PTR $T39653[esp+296]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L39879:
	mov	eax, DWORD PTR $T39652[esp+316]
	xor	ebx, ebx
	cmp	eax, esi
	mov	edi, 15					; 0000000fH
	mov	DWORD PTR $T39653[esp+316], edi
	mov	DWORD PTR $T39653[esp+312], ebx
	mov	BYTE PTR $T39653[esp+296], bl
	jb	SHORT $L39956
	mov	edx, DWORD PTR $T39652[esp+296]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L39956:
	mov	BYTE PTR __$EHRec$[esp+300], bl
	cmp	DWORD PTR $T39651[esp+316], esi
	mov	DWORD PTR $T39652[esp+316], edi
	mov	DWORD PTR $T39652[esp+312], ebx
	mov	BYTE PTR $T39652[esp+296], bl
	jb	SHORT $L40019
	mov	eax, DWORD PTR $T39651[esp+296]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L40019:

; 707  :       formattedMessage += "  " + error.message_ + "\n";

	lea	ecx, DWORD PTR [ebp+12]
	push	ecx
	mov	ecx, OFFSET FLAT:??_C@_02KNHHEEKP@?5?5?$AA@
	lea	esi, DWORD PTR $T39654[esp+296]
	mov	DWORD PTR $T39651[esp+320], edi
	mov	DWORD PTR $T39651[esp+316], ebx
	mov	BYTE PTR $T39651[esp+300], bl
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	eax
	mov	edi, OFFSET FLAT:??_C@_01EEMJAFIK@?6?$AA@
	lea	esi, DWORD PTR $T39655[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 4
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	mov	ecx, eax
	push	ebx
	or	eax, -1
	lea	ebx, DWORD PTR _formattedMessage$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 5
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	eax, DWORD PTR $T39655[esp+316]
	mov	esi, 16					; 00000010H
	cmp	eax, esi
	jb	SHORT $L40101
	mov	edx, DWORD PTR $T39655[esp+296]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L40101:
	xor	ebx, ebx
	mov	BYTE PTR __$EHRec$[esp+300], bl
	cmp	DWORD PTR $T39654[esp+316], esi
	mov	edi, 15					; 0000000fH
	mov	DWORD PTR $T39655[esp+316], edi
	mov	DWORD PTR $T39655[esp+312], ebx
	mov	BYTE PTR $T39655[esp+296], bl
	jb	SHORT $L40174
	mov	eax, DWORD PTR $T39654[esp+296]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L40174:

; 708  :       if ( error.extra_ )

	mov	ebp, DWORD PTR [ebp+40]
	cmp	ebp, ebx
	mov	DWORD PTR $T39654[esp+316], edi
	mov	DWORD PTR $T39654[esp+312], ebx
	mov	BYTE PTR $T39654[esp+296], bl
	je	$L13334

; 709  :          formattedMessage += "See " + getLocationLineAndColumn( error.extra_ ) + " for detail.\n";

	mov	edx, DWORD PTR _this$[esp+288]
	push	ebp
	lea	esi, DWORD PTR $T39656[esp+296]
	call	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
	push	eax
	mov	ecx, OFFSET FLAT:??_C@_04JBAOJHKB@See?5?$AA@
	lea	esi, DWORD PTR $T39657[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 6
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	eax
	mov	edi, OFFSET FLAT:??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
	lea	esi, DWORD PTR $T39658[esp+300]
	mov	BYTE PTR __$EHRec$[esp+308], 7
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	mov	ecx, eax
	push	ebx
	or	eax, -1
	lea	ebx, DWORD PTR _formattedMessage$[esp+296]
	mov	BYTE PTR __$EHRec$[esp+304], 8
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	mov	eax, DWORD PTR $T39658[esp+316]
	mov	esi, 16					; 00000010H
	cmp	eax, esi
	jb	SHORT $L40256
	mov	ecx, DWORD PTR $T39658[esp+296]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L40256:
	mov	eax, DWORD PTR $T39657[esp+316]
	xor	ebx, ebx
	cmp	eax, esi
	mov	edi, 15					; 0000000fH
	mov	DWORD PTR $T39658[esp+316], edi
	mov	DWORD PTR $T39658[esp+312], ebx
	mov	BYTE PTR $T39658[esp+296], bl
	jb	SHORT $L40329
	mov	edx, DWORD PTR $T39657[esp+296]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L40329:
	mov	BYTE PTR __$EHRec$[esp+300], bl
	cmp	DWORD PTR $T39656[esp+316], esi
	mov	DWORD PTR $T39657[esp+316], edi
	mov	DWORD PTR $T39657[esp+312], ebx
	mov	BYTE PTR $T39657[esp+296], bl
	jb	SHORT $L40402
	mov	eax, DWORD PTR $T39656[esp+296]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L40402:
	mov	DWORD PTR $T39656[esp+316], edi
	mov	DWORD PTR $T39656[esp+312], ebx
	mov	BYTE PTR $T39656[esp+296], bl
$L13334:
	mov	eax, DWORD PTR _itError$13330[esp+296]
	mov	edx, DWORD PTR _this$[esp+288]
	inc	eax
	mov	DWORD PTR _itError$13330[esp+296], eax
	xor	ebx, ebx
	jmp	$L39775
$L40588:

; 710  :    }
; 711  :    return formattedMessage;

	mov	esi, DWORD PTR ___$ReturnUdt$[esp+288]
	push	-1
	push	ebx
	lea	ecx, DWORD PTR _formattedMessage$[esp+300]
	push	ecx
	mov	DWORD PTR [esi+24], 15			; 0000000fH
	mov	DWORD PTR [esi+20], ebx
	mov	ecx, esi
	mov	BYTE PTR [esi+4], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	cmp	DWORD PTR _formattedMessage$[esp+316], 16 ; 00000010H
	jb	SHORT $L40589
	mov	edx, DWORD PTR _formattedMessage$[esp+296]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L40589:

; 712  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+292]
	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+280]
	pop	ebx
	call	@__security_check_cookie@4
	add	esp, 276				; 00000114H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L39659:
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L39660:
	lea	ecx, DWORD PTR $T39651[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L39661:
	lea	ecx, DWORD PTR $T39652[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L39662:
	lea	ecx, DWORD PTR $T39653[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L39663:
	lea	ecx, DWORD PTR $T39654[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L39664:
	lea	ecx, DWORD PTR $T39655[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L39665:
	lea	ecx, DWORD PTR $T39656[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L39666:
	lea	ecx, DWORD PTR $T39657[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L39667:
	lea	ecx, DWORD PTR $T39658[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	eax, OFFSET FLAT:$T40585
	jmp	___CxxFrameHandler
text$x	ENDS
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Reader::getFormatedErrorMessages
PUBLIC	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T40866	DD	0ffffffffH
	DD	FLAT:$L40600
$T40862	DD	019930520H
	DD	01H
	DD	FLAT:$T40866
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
_TEXT	SEGMENT
_info$ = -60						; size = 44
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
_message$ = 12						; size = 4
_token$ = 16						; size = 4
_extra$ = 20						; size = 4
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z PROC NEAR ; Json::Reader::addError, COMDAT

; 603  : {

	push	-1
	push	__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	push	ebx
	push	ebp

; 604  :    ErrorInfo info;

	xor	ebx, ebx
	push	esi
	mov	DWORD PTR __$ArrayPad$[esp+72], eax
	mov	eax, DWORD PTR _token$[esp+68]
	push	edi
	mov	DWORD PTR _info$[esp+112], 15		; 0000000fH
	mov	DWORD PTR _info$[esp+108], ebx
	mov	BYTE PTR _info$[esp+92], bl
	mov	DWORD PTR __$EHRec$[esp+84], ebx

; 605  :    info.token_ = token;

	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+8]

; 606  :    info.message_ = message;

	push	-1
	mov	DWORD PTR _info$[esp+80], ecx
	mov	ecx, DWORD PTR _message$[esp+76]
	push	ebx
	push	ecx
	lea	ecx, DWORD PTR _info$[esp+100]
	mov	DWORD PTR _info$[esp+92], edx
	mov	DWORD PTR _info$[esp+96], eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 607  :    info.extra_ = extra;
; 608  :    errors_.push_back( info );

	mov	ebp, DWORD PTR _this$[esp+72]
	mov	eax, DWORD PTR [ebp+36]
	mov	ecx, DWORD PTR [ebp+28]
	mov	edx, DWORD PTR _extra$[esp+72]
	add	ebp, 20					; 00000014H
	inc	eax
	cmp	ecx, eax
	mov	DWORD PTR _info$[esp+116], edx
	ja	SHORT $L40749
	push	1
	mov	ebx, ebp
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
	xor	ebx, ebx
$L40749:
	mov	esi, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [ebp+8]
	add	esi, edx
	cmp	eax, esi
	ja	SHORT $L40752
	sub	esi, eax
$L40752:
	mov	ecx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [ecx+esi*4], ebx
	jne	SHORT $L40753
	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	mov	edx, DWORD PTR [ebp+4]
	add	esp, 4
	mov	DWORD PTR [edx+esi*4], eax
$L40753:
	mov	eax, DWORD PTR [ebp+4]
	mov	esi, DWORD PTR [eax+esi*4]
	lea	edi, DWORD PTR _info$[esp+76]
	call	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
	mov	ecx, DWORD PTR [ebp+16]

; 609  :    return false;

	mov	eax, DWORD PTR _info$[esp+112]
	pop	edi
	inc	ecx
	cmp	eax, 16					; 00000010H
	pop	esi
	mov	DWORD PTR [ebp+16], ecx
	pop	ebp
	pop	ebx
	jb	SHORT $L40863
	mov	ecx, DWORD PTR _info$[esp+76]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L40863:

; 610  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+60]
	xor	al, al
	call	@__security_check_cookie@4
	add	esp, 60					; 0000003cH
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L40600:
	lea	esi, DWORD PTR _info$[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z:
	mov	eax, OFFSET FLAT:$T40862
	jmp	___CxxFrameHandler
text$x	ENDS
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ENDP ; Json::Reader::addError
PUBLIC	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T41240	DD	0ffffffffH
	DD	FLAT:$L40876
	DD	0ffffffffH
	DD	FLAT:$L40877
$T41235	DD	019930520H
	DD	02H
	DD	FLAT:$T41240
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
$T40873 = -68						; size = 28
$T40875 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_token$ = 12						; size = 4
_end$ = 16						; size = 4
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC NEAR ; Json::Reader::decodeUnicodeEscapeSequence, COMDAT
; _current$ = esi
; _unicode$ = edx

; 578  : {

	push	-1
	mov	eax, DWORD PTR fs:__except_list
	push	__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	push	eax
	mov	eax, DWORD PTR _end$[esp+8]
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 56					; 00000038H
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _token$[esp+72]
	push	edi

; 579  :    if ( end - current < 4 )

	sub	eax, DWORD PTR [esi]

; 580  :       return addError( "Bad unicode escape sequence in string: four digits expected.", token, current );

	xor	ebx, ebx
	cmp	eax, 4
	jge	SHORT $L13164
	push	60					; 0000003cH
	push	OFFSET FLAT:??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	ecx, DWORD PTR $T40873[esp+88]
	mov	DWORD PTR $T40873[esp+112], 15		; 0000000fH
	mov	DWORD PTR $T40873[esp+108], ebx
	mov	BYTE PTR $T40873[esp+92], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	edx, DWORD PTR _this$[esp+76]
	mov	DWORD PTR __$EHRec$[esp+88], ebx
	mov	eax, DWORD PTR [esi]
	push	eax
	push	ebp
	lea	ecx, DWORD PTR $T40873[esp+88]
	push	ecx
	push	edx
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	bl, al
	cmp	DWORD PTR $T40873[esp+104], 16		; 00000010H
	jb	$L41218
	mov	eax, DWORD PTR $T40873[esp+84]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	edi
	pop	ebp
	mov	al, bl
	pop	ebx

; 596  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 68					; 00000044H
	ret	12					; 0000000cH
$L13164:

; 581  :    unicode = 0;

	mov	DWORD PTR [edx], ebx

; 582  :    for ( int index =0; index < 4; ++index )

	xor	edi, edi
$L13169:

; 583  :    {
; 584  :       Char c = *current++;

	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [esi], ecx

; 585  :       unicode *= 16;

	mov	ecx, DWORD PTR [edx]
	shl	ecx, 4

; 586  :       if ( c >= '0'  &&  c <= '9' )

	cmp	al, 48					; 00000030H
	mov	DWORD PTR [edx], ecx
	jl	SHORT $L13173
	cmp	al, 57					; 00000039H
	jg	SHORT $L13173

; 587  :          unicode += c - '0';

	movsx	eax, al
	lea	ecx, DWORD PTR [eax+ecx-48]

; 588  :       else if ( c >= 'a'  &&  c <= 'f' )

	jmp	SHORT $L41239
$L13173:
	cmp	al, 97					; 00000061H
	jl	SHORT $L13175
	cmp	al, 102					; 00000066H
	jg	SHORT $L13175

; 589  :          unicode += c - 'a' + 10;

	movsx	eax, al
	lea	ecx, DWORD PTR [eax+ecx-87]

; 590  :       else if ( c >= 'A'  &&  c <= 'F' )

	jmp	SHORT $L41239
$L13175:
	cmp	al, 65					; 00000041H
	jl	SHORT $L13177
	cmp	al, 70					; 00000046H
	jg	SHORT $L13177

; 591  :          unicode += c - 'A' + 10;

	movsx	eax, al
	lea	ecx, DWORD PTR [eax+ecx-55]
$L41239:
	inc	edi
	cmp	edi, 4
	mov	DWORD PTR [edx], ecx
	jl	SHORT $L13169
	pop	edi
	pop	ebp

; 594  :    }
; 595  :    return true;

	mov	al, 1
	pop	ebx

; 596  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+68]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 68					; 00000044H
	ret	12					; 0000000cH
$L13177:

; 592  :       else
; 593  :          return addError( "Bad unicode escape sequence in string: hexadecimal digit expected.", token, current );

	push	66					; 00000042H
	push	OFFSET FLAT:??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	ecx, DWORD PTR $T40875[esp+88]
	mov	DWORD PTR $T40875[esp+112], 15		; 0000000fH
	mov	DWORD PTR $T40875[esp+108], ebx
	mov	BYTE PTR $T40875[esp+92], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ecx, DWORD PTR _this$[esp+76]
	mov	DWORD PTR __$EHRec$[esp+88], 1
	mov	edx, DWORD PTR [esi]
	push	edx
	push	ebp
	lea	eax, DWORD PTR $T40875[esp+88]
	push	eax
	push	ecx
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	bl, al
	cmp	DWORD PTR $T40875[esp+104], 16		; 00000010H
	jb	SHORT $L41218
	mov	edx, DWORD PTR $T40875[esp+84]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L41218:

; 596  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+80]
	pop	edi
	pop	ebp
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 68					; 00000044H
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L40876:
	lea	ecx, DWORD PTR $T40873[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L40877:
	lea	ecx, DWORD PTR $T40875[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
	mov	eax, OFFSET FLAT:$T41235
	jmp	___CxxFrameHandler
text$x	ENDS
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeEscapeSequence
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\xstring
xdata$x	SEGMENT
$T41684	DD	0ffffffffH
	DD	FLAT:$L41250
	DD	0ffffffffH
	DD	FLAT:$L41251
$T41673	DD	019930520H
	DD	02H
	DD	FLAT:$T41684
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_current$ = -84						; size = 4
_end$ = -80						; size = 4
_c$13128 = -76						; size = 1
_unicode$13150 = -72					; size = 4
$T41247 = -68						; size = 28
$T41249 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC NEAR ; Json::Reader::decodeString, COMDAT
; _token$ = ecx
; _decoded$ = edi

; 528  : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	ebp
	mov	ebx, ecx

; 529  :    decoded.reserve( token.end_ - token.start_ - 2 );

	mov	eax, DWORD PTR [ebx+8]
	push	esi
	sub	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [edi+20]
	sub	eax, 2
	cmp	esi, eax
	ja	SHORT $L41679
	cmp	DWORD PTR [edi+24], eax
	je	SHORT $L41679
	push	1
	push	eax
	mov	ecx, edi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $L41679
	cmp	DWORD PTR [edi+24], 16			; 00000010H
	mov	DWORD PTR [edi+20], esi
	jb	SHORT $L41282
	mov	eax, DWORD PTR [edi+4]
	jmp	SHORT $L41283
$L41282:
	lea	eax, DWORD PTR [edi+4]
$L41283:
	mov	BYTE PTR [eax+esi], 0
$L41679:

; 530  :    Location current = token.start_ + 1; // skip '"'

	mov	ebp, DWORD PTR [ebx+4]

; 531  :    Location end = token.end_ - 1;      // do not include '"'

	mov	ecx, DWORD PTR [ebx+8]
	inc	ebp
	dec	ecx

; 532  :    while ( current != end )

	cmp	ebp, ecx
	mov	DWORD PTR _end$[esp+96], ecx
	jne	SHORT $L13126
$L13127:
	pop	esi
	pop	ebp

; 567  :       }
; 568  :    }
; 569  :    return true;

	mov	al, 1
	pop	ebx

; 570  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 84					; 00000054H
	ret	4
$L41680:

; 532  :    while ( current != end )

	mov	ecx, DWORD PTR _end$[esp+96]
	npad	1
$L13126:

; 533  :    {
; 534  :       Char c = *current++;

	mov	al, BYTE PTR [ebp]
	inc	ebp

; 535  :       if ( c == '"' )

	cmp	al, 34					; 00000022H
	mov	BYTE PTR _c$13128[esp+96], al
	je	SHORT $L13127

; 536  :          break;
; 537  :       else if ( c == '\\' )

	cmp	al, 92					; 0000005cH
	jne	SHORT $L13131

; 538  :       {
; 539  :          if ( current == end )

	cmp	ebp, ecx
	je	$L41676

; 541  :          Char escape = *current++;

	mov	al, BYTE PTR [ebp]

; 542  :          switch ( escape )

	movsx	eax, al
	inc	ebp
	add	eax, -34				; ffffffdeH
	cmp	eax, 83					; 00000053H
	mov	DWORD PTR _current$[esp+96], ebp
	ja	$L13152
	movzx	eax, BYTE PTR $L41678[eax]
	jmp	DWORD PTR $L41683[eax*4]
$L13141:

; 543  :          {
; 544  :          case '"': decoded += '"'; break;

	push	34					; 00000022H
	jmp	SHORT $L41682
$L13142:

; 545  :          case '/': decoded += '/'; break;

	push	47					; 0000002fH
	jmp	SHORT $L41682
$L13143:

; 546  :          case '\\': decoded += '\\'; break;

	push	92					; 0000005cH
	jmp	SHORT $L41682
$L13144:

; 547  :          case 'b': decoded += '\b'; break;

	push	8
	jmp	SHORT $L41682
$L13145:

; 548  :          case 'f': decoded += '\f'; break;

	push	12					; 0000000cH
	jmp	SHORT $L41682
$L13146:

; 549  :          case 'n': decoded += '\n'; break;

	push	10					; 0000000aH
	jmp	SHORT $L41682
$L13147:

; 550  :          case 'r': decoded += '\r'; break;

	push	13					; 0000000dH
	jmp	SHORT $L41682
$L13148:

; 551  :          case 't': decoded += '\t'; break;

	push	9
	jmp	SHORT $L41682
$L13149:

; 552  :          case 'u':
; 553  :             {
; 554  :                unsigned int unicode;
; 555  :                if ( !decodeUnicodeEscapeSequence( token, current, end, unicode ) )

	push	ecx
	mov	ecx, DWORD PTR _this$[esp+96]
	push	ebx
	push	ecx
	lea	edx, DWORD PTR _unicode$13150[esp+108]
	lea	esi, DWORD PTR _current$[esp+108]
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	test	al, al
	je	$L41677

; 562  :          }
; 563  :       }
; 564  :       else

	mov	ebp, DWORD PTR _current$[esp+96]
	jmp	SHORT $L41670
$L13131:

; 565  :       {
; 566  :          decoded += c;

	mov	edx, DWORD PTR _c$13128[esp+96]
	push	edx
$L41682:
	mov	esi, edi
	mov	eax, 1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$L41670:
	cmp	ebp, DWORD PTR _end$[esp+96]
	jne	$L41680

; 552  :          case 'u':
; 553  :             {
; 554  :                unsigned int unicode;
; 555  :                if ( !decodeUnicodeEscapeSequence( token, current, end, unicode ) )

	jmp	$L13127
$L41676:

; 540  :             return addError( "Empty escape sequence in string", token, current );

	push	31					; 0000001fH
	xor	esi, esi
	push	OFFSET FLAT:??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
	lea	ecx, DWORD PTR $T41247[esp+104]
	mov	DWORD PTR $T41247[esp+128], 15		; 0000000fH
	mov	DWORD PTR $T41247[esp+124], esi
	mov	BYTE PTR $T41247[esp+108], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ecx, DWORD PTR _this$[esp+92]
	push	ebp
	push	ebx
	lea	eax, DWORD PTR $T41247[esp+104]
	push	eax
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+120], esi
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	bl, al
	cmp	DWORD PTR $T41247[esp+120], 16		; 00000010H
	jb	$L41659
	mov	edx, DWORD PTR $T41247[esp+100]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx

; 570  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 84					; 00000054H
	ret	4
$L41677:
	pop	esi
	pop	ebp

; 556  :                   return false;

	xor	al, al
	pop	ebx

; 570  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+84]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 84					; 00000054H
	ret	4
$L13152:

; 557  :                // @todo encode unicode as utf8.
; 558  :             }
; 559  :             break;
; 560  :          default:
; 561  :             return addError( "Bad escape sequence in string", token, current );

	push	29					; 0000001dH
	push	OFFSET FLAT:??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
	lea	ecx, DWORD PTR $T41249[esp+104]
	mov	DWORD PTR $T41249[esp+128], 15		; 0000000fH
	mov	DWORD PTR $T41249[esp+124], 0
	mov	BYTE PTR $T41249[esp+108], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ecx, DWORD PTR _this$[esp+92]
	push	ebp
	push	ebx
	lea	eax, DWORD PTR $T41249[esp+104]
	push	eax
	push	ecx
	mov	DWORD PTR __$EHRec$[esp+120], 1
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	bl, al
	cmp	DWORD PTR $T41249[esp+120], 16		; 00000010H
	jb	SHORT $L41659
	mov	edx, DWORD PTR $T41249[esp+100]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L41659:

; 570  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+96]
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 84					; 00000054H
	ret	4
	npad	1
$L41683:
	DD	$L13141
	DD	$L13142
	DD	$L13143
	DD	$L13144
	DD	$L13145
	DD	$L13146
	DD	$L13147
	DD	$L13148
	DD	$L13149
	DD	$L13152
$L41678:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	7
	DB	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L41250:
	lea	ecx, DWORD PTR $T41247[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L41251:
	lea	ecx, DWORD PTR $T41249[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	eax, OFFSET FLAT:$T41673
	jmp	___CxxFrameHandler
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Reader::decodeString
PUBLIC	?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ; Json::Reader::expectToken
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T41875	DD	0ffffffffH
	DD	FLAT:$L41692
$T41872	DD	019930520H
	DD	01H
	DD	FLAT:$T41875
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
_TEXT	SEGMENT
$T41691 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
_type$ = 12						; size = 4
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z PROC NEAR ; Json::Reader::expectToken, COMDAT
; _token$ = ecx
; _message$ = esi

; 145  : {

	mov	eax, DWORD PTR fs:__except_list
	push	-1
	push	__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 28					; 0000001cH
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+40]
	push	edi
	mov	edi, ecx

; 146  :    readToken( token );

	mov	eax, ebp
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 147  :    if ( token.type_ != type )

	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR _type$[esp+44]
	je	SHORT $L12778
	push	ebx

; 148  :       return addError( message, token );

	xor	ebx, ebx
	mov	eax, esi
	mov	DWORD PTR $T41691[esp+76], 15		; 0000000fH
	mov	DWORD PTR $T41691[esp+72], ebx
	mov	BYTE PTR $T41691[esp+56], bl
	lea	edx, DWORD PTR [eax+1]
$L41873:
	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, bl
	jne	SHORT $L41873
	sub	eax, edx
	push	eax
	push	esi
	lea	ecx, DWORD PTR $T41691[esp+60]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	push	edi
	lea	ecx, DWORD PTR $T41691[esp+60]
	push	ecx
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+76], ebx
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	bl, al
	cmp	DWORD PTR $T41691[esp+76], 16		; 00000010H
	jb	SHORT $L41861
	mov	edx, DWORD PTR $T41691[esp+56]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L41861:
	mov	al, bl
	pop	ebx
	pop	edi
	pop	ebp

; 149  :    return true;
; 150  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+40]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 40					; 00000028H
	ret	8
$L12778:
	mov	ecx, DWORD PTR __$EHRec$[esp+48]
	pop	edi
	mov	al, 1
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 40					; 00000028H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L41692:
	lea	ecx, DWORD PTR $T41691[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z:
	mov	eax, OFFSET FLAT:$T41872
	jmp	___CxxFrameHandler
text$x	ENDS
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ENDP ; Json::Reader::expectToken
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
;	COMDAT ?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front, COMDAT
; _this$ = eax
; __Val$ = edi

; 555  : 		{	// insert element at beginning

	push	ebx
	mov	ebx, eax

; 556  : 		if (_Myoff % _DEQUESIZ == 0
; 557  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [ebx+8]
	inc	eax
	cmp	ecx, eax
	push	ebp
	push	esi
	ja	SHORT $L14638

; 558  : 			_Growmap(1);

	push	1
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$L14638:

; 559  : 		size_type _Newoff = _Myoff != 0 ? _Myoff
; 560  : 			: _Mapsize * _DEQUESIZ;

	mov	ebp, DWORD PTR [ebx+12]
	test	ebp, ebp
	jne	SHORT $L46911
	mov	ebp, DWORD PTR [ebx+8]
$L46911:

; 561  : 		size_type _Block = --_Newoff / _DEQUESIZ;
; 562  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ecx+ebp*4-4]
	dec	ebp
	test	eax, eax
	jne	SHORT $L14641

; 563  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	mov	edx, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR [edx+ebp*4], eax
$L14641:

; 564  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [eax+ebp*4]
	call	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>

; 565  : 		_Myoff = _Newoff;
; 566  : 		++_Mysize;

	mov	eax, DWORD PTR [ebx+16]
	pop	esi
	mov	DWORD PTR [ebx+12], ebp
	inc	eax
	pop	ebp
	mov	DWORD PTR [ebx+16], eax
	pop	ebx

; 567  : 		}

	ret	0
?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T48617	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:$L47102
	DD	00H
	DD	FLAT:$L46958
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	04H
	DD	FLAT:$L47903
	DD	04H
	DD	FLAT:$L46959
	DD	0ffffffffH
	DD	00H
$T48619	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L46955
$T48620	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:$L46957
$T48618	DD	00H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:$T48619
	DD	04H
	DD	06H
	DD	07H
	DD	01H
	DD	FLAT:$T48620
$T48595	DD	019930520H
	DD	08H
	DD	FLAT:$T48617
	DD	02H
	DD	FLAT:$T48618
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXViterator@12@IABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
$T46995 = -128						; size = 8
__Oldsize$ = -124					; size = 4
__Tmp$48470 = -120					; size = 8
$T46952 = -120						; size = 8
$T46938 = -120						; size = 8
__Newoff$47475 = -116					; size = 4
__Newoff$47017 = -116					; size = 4
$T47367 = -116						; size = 4
__Rem$ = -116						; size = 4
__Off$ = -112						; size = 4
__Tmp$14495 = -108					; size = 44
__Tmp$14525 = -64					; size = 44
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
__Where$ = 12						; size = 8
__Num$ = 16						; size = 4
__Cat$48481 = 20					; size = 1
__Cat$47668 = 20					; size = 1
__Count$ = 20						; size = 4
__Val$ = 24						; size = 4
?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXViterator@12@IABVErrorInfo@Reader@Json@@@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert_n, COMDAT

; 827  : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXViterator@12@IABVErrorInfo@Reader@Json@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 828  : 		iterator _Mid;
; 829  : 		size_type _Num;
; 830  : 		size_type _Off = _Where - begin();

	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ebx+12]
	push	esi
	mov	DWORD PTR $T46995[ebp], eax
	mov	eax, DWORD PTR __Where$[ebp+4]
	cmp	ecx, eax
	push	edi
	mov	DWORD PTR __$EHRec$[ebp], esp
	ja	SHORT $L46998
	sub	eax, ecx
	mov	esi, eax
	mov	DWORD PTR __Off$[ebp], esi
	jmp	SHORT $L46999
$L46998:
	sub	eax, ecx
	mov	DWORD PTR __Off$[ebp], eax
	mov	esi, eax
$L46999:

; 831  : 		size_type _Rem = _Mysize - _Off;

	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, ecx
	sub	eax, esi

; 832  : 		size_type _Oldsize = _Mysize;
; 833  : 
; 834  : 		if (_Off < _Rem)

	cmp	esi, eax
	mov	DWORD PTR __Rem$[ebp], eax
	mov	DWORD PTR __Oldsize$[ebp], ecx
	jae	$L14468

; 835  : 			{	// closer to front
; 836  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 837  : 			if (_Off < _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	cmp	esi, edx
	jae	$L14470

; 838  : 				{	// insert longer than prefix
; 839  : 				for (_Num = _Count - _Off; 0 < _Num; --_Num)

	mov	eax, edx
	sub	eax, esi
	mov	DWORD PTR __Num$[ebp], eax
	npad	6
$L14471:
	test	eax, eax
	jbe	SHORT $L14473

; 840  : 					push_front(_Val);	// push excess values

	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR [ebx+8]
	inc	ecx
	cmp	eax, ecx
	ja	SHORT $L47016
	push	1
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$L47016:
	mov	esi, DWORD PTR [ebx+12]
	test	esi, esi
	jne	SHORT $L47022
	mov	esi, DWORD PTR [ebx+8]
$L47022:
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [edx+esi*4-4]
	dec	esi
	test	eax, eax
	mov	DWORD PTR __Newoff$47017[ebp], esi
	jne	SHORT $L47019
	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR [ecx+esi*4], eax
$L47019:
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR __Newoff$47017[ebp]
	mov	esi, DWORD PTR [edx+eax*4]
	mov	edi, DWORD PTR __Val$[ebp]
	call	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
	mov	ecx, DWORD PTR __Newoff$47017[ebp]
	mov	eax, DWORD PTR __Num$[ebp]
	mov	esi, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [ebx+12], ecx
	mov	ecx, DWORD PTR [ebx+16]
	inc	ecx
	dec	eax
	mov	DWORD PTR [ebx+16], ecx
	mov	DWORD PTR __Num$[ebp], eax
	jmp	SHORT $L14471
$L14473:

; 841  : 				for (_Num = _Off; 0 < _Num; --_Num)

	mov	DWORD PTR __Num$[ebp], esi
	npad	1
$L14474:
	mov	eax, DWORD PTR __Num$[ebp]
	test	eax, eax

; 842  : 					push_front(begin()[_Count - 1]);	// push prefix

	mov	eax, DWORD PTR [ebx+12]
	jbe	$L14476
	lea	eax, DWORD PTR [eax+edx-1]
	mov	ecx, ebx
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, eax
	ja	SHORT $L47083
	sub	eax, edx
$L47083:
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [ebx+16]
	mov	DWORD PTR $T47367[ebp], eax
	mov	eax, DWORD PTR [ebx+8]
	inc	ecx
	cmp	eax, ecx
	ja	SHORT $L47356
	push	1
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$L47356:
	mov	edi, DWORD PTR [ebx+12]
	test	edi, edi
	jne	SHORT $L47362
	mov	edi, DWORD PTR [ebx+8]
$L47362:
	mov	edx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [edx+edi*4-4]
	dec	edi
	test	eax, eax
	jne	SHORT $L47359
	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR [ecx+edi*4], eax
$L47359:
	mov	edx, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [edx+edi*4]
	test	esi, esi
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	je	SHORT $L47351
	mov	eax, DWORD PTR $T47367[ebp]
	mov	edx, DWORD PTR [eax]
	mov	ecx, esi
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	edx, DWORD PTR $T47367[ebp]
	mov	DWORD PTR [ecx+8], eax
	push	-1
	lea	ecx, DWORD PTR [esi+12]
	push	0
	add	edx, 12					; 0000000cH
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], 0
	push	edx
	mov	BYTE PTR [ecx+4], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR $T47367[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [esi+40], ecx
$L47351:
	mov	esi, DWORD PTR __Off$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR __Num$[ebp]
	mov	edx, DWORD PTR __Count$[ebp]
	inc	ecx
	dec	eax
	mov	DWORD PTR [ebx+12], edi
	mov	DWORD PTR [ebx+16], ecx
	mov	DWORD PTR __Num$[ebp], eax
	jmp	$L14474
$L14476:

; 843  : 
; 844  : 				_Mid = begin() + _Count;

	add	eax, edx

; 845  : 				fill(_Mid, _Mid + _Off, _Val);	// fill in rest of values
; 846  : 				}
; 847  : 			else

	jmp	$L48615
$L14470:

; 848  : 				{	// insert not longer than prefix
; 849  : 				for (_Num = _Count; 0 < _Num; --_Num)

	mov	DWORD PTR __Num$[ebp], edx
	npad	7
$L14489:
	mov	eax, DWORD PTR __Num$[ebp]
	test	eax, eax
	jbe	SHORT $L14491

; 850  : 					push_front(begin()[_Count - 1]);	// push part of prefix

	mov	eax, DWORD PTR [ebx+12]
	mov	ecx, ebx
	lea	eax, DWORD PTR [eax+edx-1]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, eax
	ja	SHORT $L47455
	sub	eax, edx
$L47455:
	mov	edx, DWORD PTR [ecx+4]
	mov	edi, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [ebx+8]
	inc	eax
	cmp	ecx, eax
	ja	SHORT $L47474
	push	1
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$L47474:
	mov	esi, DWORD PTR [ebx+12]
	test	esi, esi
	jne	SHORT $L47480
	mov	esi, DWORD PTR [ebx+8]
$L47480:
	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ecx+esi*4-4]
	dec	esi
	test	eax, eax
	mov	DWORD PTR __Newoff$47475[ebp], esi
	jne	SHORT $L47477
	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	mov	edx, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR [edx+esi*4], eax
$L47477:
	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR __Newoff$47475[ebp]
	mov	esi, DWORD PTR [eax+ecx*4]
	call	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR __Num$[ebp]
	mov	edx, DWORD PTR __Newoff$47475[ebp]
	inc	ecx
	dec	eax
	mov	DWORD PTR [ebx+12], edx
	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR [ebx+16], ecx
	mov	DWORD PTR __Num$[ebp], eax
	jmp	$L14489
$L14491:

; 851  : 
; 852  : 				_Mid = begin() + _Count;

	mov	esi, DWORD PTR [ebx+12]
	add	esi, DWORD PTR __Count$[ebp]

; 853  : 				_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, eax
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$14495[ebp], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	push	-1
	push	0
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Tmp$14495[ebp+8], ecx
	push	eax
	lea	ecx, DWORD PTR __Tmp$14495[ebp+12]
	mov	DWORD PTR __Tmp$14495[ebp+4], edx
	mov	DWORD PTR __Tmp$14495[ebp+36], 15	; 0000000fH
	mov	DWORD PTR __Tmp$14495[ebp+32], 0
	mov	BYTE PTR __Tmp$14495[ebp+16], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR __Tmp$14495[ebp+40], eax

; 854  : 				copy(_Mid + _Count, _Mid + _Off, _Mid);	// copy rest of prefix

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	mov	edi, DWORD PTR __Count$[ebp]
	mov	eax, esi
	add	eax, ecx
	mov	ecx, esi
	add	ecx, edi
	mov	edi, DWORD PTR __Cat$47668[ebp]
	push	edi
	push	esi
	push	ebx
	push	eax
	mov	edx, ebx
	push	edx
	push	ecx
	mov	eax, ebx
	push	eax
	lea	ecx, DWORD PTR $T46938[ebp]
	push	ecx
	call	??$_Copy_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>

; 855  : 				fill(begin() + _Off, _Mid + _Off, _Tmp);	// fill in values

	mov	edx, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR [ebx+12]
	add	esp, 32					; 00000020H
	add	esi, edx
	mov	ecx, ebx
	push	esi
	push	ecx
	add	eax, edx
	push	eax
	push	ebx
	lea	ebx, DWORD PTR __Tmp$14495[ebp]
	call	??$fill@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@VErrorInfo@Reader@Json@@@std@@YAXViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0ABVErrorInfo@Reader@Json@@@Z ; std::fill<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,Json::Reader::ErrorInfo>

; 856  : 				}

	mov	eax, DWORD PTR __Tmp$14495[ebp+36]
	add	esp, 16					; 00000010H
	cmp	eax, 16					; 00000010H
	jb	SHORT $L14461
	mov	edx, DWORD PTR __Tmp$14495[ebp+16]
$L48616:

; 887  : 				}

	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L14461:

; 892  : 			_CATCH_END
; 893  : 			}
; 894  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	call	@__security_check_cookie@4
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$L46955:

; 857  : 			_CATCH_ALL
; 858  : 			for (; _Oldsize < _Mysize; )

	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Oldsize$[ebp]
	cmp	esi, DWORD PTR [edi+16]
	jae	SHORT $L14504
	npad	4
$L14503:

; 859  : 				pop_front();	// restore old size, at least

	call	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
	cmp	esi, DWORD PTR [edi+16]
	jb	SHORT $L14503
$L14504:

; 860  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L48621:
$L14468:

; 861  : 			_CATCH_END
; 862  : 			}
; 863  : 		else
; 864  : 			{		// closer to back
; 865  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 866  : 			if (_Rem < _Count)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	eax, DWORD PTR __Rem$[ebp]
	cmp	eax, edi
	jae	$L14507

; 867  : 				{	// insert longer than suffix
; 868  : 				for (_Num = _Count - _Rem; 0 < _Num; --_Num)

	sub	edi, eax
	mov	DWORD PTR __Num$[ebp], edi
	npad	3
$L14508:
	mov	eax, DWORD PTR __Num$[ebp]
	test	eax, eax
	jbe	SHORT $L14510

; 869  : 					push_back(_Val);	// push excess values

	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [ebx+8]
	inc	eax
	cmp	ecx, eax
	ja	SHORT $L47820
	push	1
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$L47820:
	mov	esi, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	add	esi, edx
	cmp	eax, esi
	ja	SHORT $L47823
	sub	esi, eax
$L47823:
	mov	ecx, DWORD PTR [ebx+4]
	cmp	DWORD PTR [ecx+esi*4], 0
	jne	SHORT $L47824
	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	mov	edx, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR [edx+esi*4], eax
$L47824:
	mov	eax, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [eax+esi*4]
	mov	edi, DWORD PTR __Val$[ebp]
	call	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR __Num$[ebp]
	inc	ecx
	dec	eax
	mov	DWORD PTR [ebx+16], ecx
	mov	DWORD PTR __Num$[ebp], eax
	jmp	SHORT $L14508
$L14510:

; 870  : 				for (_Num = 0; _Num < _Rem; ++_Num)

	xor	edx, edx
	mov	DWORD PTR __Num$[ebp], edx
$L14511:
	mov	esi, DWORD PTR __Rem$[ebp]
	cmp	edx, esi

; 871  : 					push_back(begin()[_Off + _Num]);	// push suffix

	mov	eax, DWORD PTR [ebx+12]
	jae	$L14513
	mov	esi, DWORD PTR __Off$[ebp]
	add	edx, esi
	mov	ecx, ebx
	add	eax, edx
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, eax
	ja	SHORT $L47886
	sub	eax, edx
$L47886:
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ebx+16]
	mov	esi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ebx+8]
	inc	edx
	cmp	eax, edx
	ja	SHORT $L48116
	push	1
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$L48116:
	mov	edi, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	add	edi, edx
	cmp	eax, edi
	ja	SHORT $L48119
	sub	edi, eax
$L48119:
	mov	eax, DWORD PTR [ebx+4]
	cmp	DWORD PTR [eax+edi*4], 0
	jne	SHORT $L48120
	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR [ecx+edi*4], eax
$L48120:
	mov	edx, DWORD PTR [ebx+4]
	mov	edi, DWORD PTR [edx+edi*4]
	test	edi, edi
	mov	BYTE PTR __$EHRec$[ebp+12], 5
	je	SHORT $L48131
	mov	eax, esi
	mov	edx, DWORD PTR [eax]
	mov	ecx, edi
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	push	-1
	lea	ecx, DWORD PTR [edi+12]
	push	0
	lea	edx, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	DWORD PTR [ecx+20], 0
	push	edx
	mov	BYTE PTR [ecx+4], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR [edi+40], eax
$L48131:
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR __Num$[ebp]
	inc	ecx
	inc	eax
	mov	DWORD PTR [ebx+16], ecx
	mov	DWORD PTR __Num$[ebp], eax
	mov	edx, eax
	jmp	$L14511
$L14513:

; 872  : 
; 873  : 				_Mid = begin() + _Off;

	add	eax, DWORD PTR __Off$[ebp]
$L48615:

; 874  : 				fill(_Mid, _Mid + _Rem, _Val);	// fill in rest of values

	mov	ecx, eax
	add	ecx, esi
	push	ecx
	mov	edx, ebx
	push	edx
	push	eax
	push	ebx
	mov	ebx, DWORD PTR __Val$[ebp]
	call	??$fill@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@VErrorInfo@Reader@Json@@@std@@YAXViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0ABVErrorInfo@Reader@Json@@@Z ; std::fill<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,Json::Reader::ErrorInfo>
	add	esp, 16					; 00000010H

; 875  : 				}
; 876  : 			else

	jmp	$L14461
$L14507:

; 877  : 				{	// insert not longer than prefix
; 878  : 				for (_Num = 0; _Num < _Count; ++_Num)

	xor	edx, edx
	mov	DWORD PTR __Num$[ebp], edx
	npad	3
$L14519:
	cmp	edx, edi
	jae	SHORT $L14521

; 879  : 					push_back(begin()[_Off + _Rem
; 880  : 						- _Count + _Num]);	// push part of prefix

	mov	esi, DWORD PTR __Off$[ebp]
	mov	eax, DWORD PTR [ebx+12]
	sub	edx, edi
	add	edx, DWORD PTR __Rem$[ebp]
	add	edx, esi
	mov	ecx, ebx
	add	eax, edx
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, eax
	ja	SHORT $L48255
	sub	eax, edx
$L48255:
	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [ebx+16]
	mov	edi, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR [ebx+8]
	inc	edx
	cmp	eax, edx
	ja	SHORT $L48279
	push	1
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$L48279:
	mov	esi, DWORD PTR [ebx+16]
	mov	edx, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [ebx+8]
	add	esi, edx
	cmp	eax, esi
	ja	SHORT $L48282
	sub	esi, eax
$L48282:
	mov	eax, DWORD PTR [ebx+4]
	cmp	DWORD PTR [eax+esi*4], 0
	jne	SHORT $L48283
	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR [ebx+4]
	add	esp, 4
	mov	DWORD PTR [ecx+esi*4], eax
$L48283:
	mov	edx, DWORD PTR [ebx+4]
	mov	esi, DWORD PTR [edx+esi*4]
	call	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
	mov	ecx, DWORD PTR [ebx+16]
	mov	eax, DWORD PTR __Num$[ebp]
	mov	edi, DWORD PTR __Count$[ebp]
	inc	ecx
	inc	eax
	mov	DWORD PTR [ebx+16], ecx
	mov	DWORD PTR __Num$[ebp], eax
	mov	edx, eax
	jmp	SHORT $L14519
$L14521:

; 881  : 
; 882  : 				_Mid = begin() + _Off;
; 883  : 				_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	mov	esi, DWORD PTR [ebx+12]
	mov	edx, DWORD PTR __Off$[ebp]
	mov	ecx, eax
	add	esi, edx
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$14525[ebp], edx
	mov	edx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+8]
	push	-1
	push	0
	add	eax, 12					; 0000000cH
	mov	DWORD PTR __Tmp$14525[ebp+8], ecx
	push	eax
	lea	ecx, DWORD PTR __Tmp$14525[ebp+12]
	mov	DWORD PTR __Tmp$14525[ebp+4], edx
	mov	DWORD PTR __Tmp$14525[ebp+36], 15	; 0000000fH
	mov	DWORD PTR __Tmp$14525[ebp+32], 0
	mov	BYTE PTR __Tmp$14525[ebp+16], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR __Tmp$14525[ebp+40], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 6

; 884  : 				copy_backward(_Mid, _Mid + _Rem - _Count,
; 885  : 					_Mid + _Rem);	// copy rest of prefix

	mov	ecx, DWORD PTR __Rem$[ebp]
	mov	edx, DWORD PTR __Rem$[ebp]
	mov	eax, esi
	add	eax, ecx
	mov	ecx, esi
	add	ecx, edx
	mov	edx, DWORD PTR __Cat$48481[ebp]
	push	edx
	push	eax
	mov	eax, ebx
	push	eax
	sub	ecx, edi
	push	ecx
	push	eax
	push	esi
	lea	ecx, DWORD PTR $T46952[ebp]
	push	ebx
	push	ecx
	mov	DWORD PTR __Tmp$48470[ebp], ebx
	call	??$_Copy_backward_opt@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V123@@std@@YA?AViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@V120@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator>
	add	esp, 32					; 00000020H

; 886  : 				fill(_Mid, _Mid + _Count, _Tmp);	// fill in values

	mov	eax, esi
	add	eax, edi
	push	eax
	mov	ecx, ebx
	push	ecx
	push	esi
	push	ebx
	lea	ebx, DWORD PTR __Tmp$14525[ebp]
	call	??$fill@Viterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@VErrorInfo@Reader@Json@@@std@@YAXViterator@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0ABVErrorInfo@Reader@Json@@@Z ; std::fill<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::iterator,Json::Reader::ErrorInfo>

; 887  : 				}

	mov	eax, DWORD PTR __Tmp$14525[ebp+36]
	add	esp, 16					; 00000010H
	cmp	eax, 16					; 00000010H
	jb	$L14461
	mov	edx, DWORD PTR __Tmp$14525[ebp+16]

; 892  : 			_CATCH_END
; 893  : 			}
; 894  : 		}

	jmp	$L48616
$L46957:

; 888  : 			_CATCH_ALL
; 889  : 			for (; _Oldsize < _Mysize; )

	mov	edi, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR __Oldsize$[ebp]
	cmp	esi, DWORD PTR [edi+16]
	jae	SHORT $L14533
	npad	4
$L14532:

; 890  : 				pop_back();	// restore old size, at least

	call	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
	cmp	esi, DWORD PTR [edi+16]
	jb	SHORT $L14532
$L14533:

; 891  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$L48622:
$L48614:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L47102:
	jmp	??3@YAXPAX0@Z				; operator delete
$L46958:
	lea	esi, DWORD PTR __Tmp$14495[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
$L47903:
	jmp	??3@YAXPAX0@Z				; operator delete
$L46959:
	lea	esi, DWORD PTR __Tmp$14525[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXViterator@12@IABVErrorInfo@Reader@Json@@@Z:
	mov	eax, OFFSET FLAT:$T48595
	jmp	___CxxFrameHandler
text$x	ENDS
?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXViterator@12@IABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert_n
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T48793	DD	0ffffffffH
	DD	FLAT:$L48632
$T48790	DD	019930520H
	DD	01H
	DD	FLAT:$T48793
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
xdata$x	ENDS
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
$T48631 = -20						; size = 8
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
__Val$ = 12						; size = 44
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize, COMDAT
; __Newsize$ = ecx

; 483  : 		{	// determine new length, padding with _Val elements as needed

	push	-1
	push	__ehhandler$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 8
	mov	eax, DWORD PTR _this$[esp+16]
	push	esi
	mov	DWORD PTR __$EHRec$[esp+32], 0

; 484  : 		if (_Mysize < _Newsize)

	mov	esi, DWORD PTR [eax+16]
	cmp	ecx, esi
	jbe	SHORT $L48792

; 485  : 			_Insert_n(end(), _Newsize - _Mysize, _Val);

	mov	edx, DWORD PTR [eax+12]
	push	edi
	lea	edi, DWORD PTR __Val$[esp+24]
	push	edi
	sub	ecx, esi
	push	ecx
	add	edx, esi
	push	edx
	push	eax
	push	eax
	call	?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXViterator@12@IABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert_n
	pop	edi

; 486  : 		else if (_Newsize < _Mysize)

	jmp	SHORT $L14173
$L48792:
	jae	SHORT $L14173

; 487  : 			erase(begin() + _Newsize, end());

	mov	edx, DWORD PTR [eax+12]
	add	esi, edx
	push	esi
	push	eax
	add	edx, ecx
	push	edx
	push	eax
	lea	ecx, DWORD PTR $T48631[esp+40]
	push	ecx
	call	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AViterator@12@V312@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
$L14173:

; 488  : 		}

	cmp	DWORD PTR __Val$[esp+56], 16		; 00000010H
	pop	esi
	jb	SHORT $L48778
	mov	edx, DWORD PTR __Val$[esp+32]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L48778:
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 20					; 00000014H
	ret	48					; 00000030H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L48632:
	lea	esi, DWORD PTR __Val$[ebp-4]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z:
	mov	eax, OFFSET FLAT:$T48790
	jmp	___CxxFrameHandler
text$x	ENDS
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
; Function compile flags: /Ogtpy
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
$T48799 = -4						; size = 4
_this$ = 8						; size = 4
__Newsize$ = 12						; size = 4
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z PROC NEAR ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize, COMDAT

; 478  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ecx

; 479  : 		resize(_Newsize, _Ty());

	sub	esp, 44					; 0000002cH
	mov	eax, esp
	xor	ecx, ecx
	mov	DWORD PTR [eax+32], ecx
	mov	DWORD PTR [eax+36], 15			; 0000000fH
	mov	BYTE PTR [eax+16], cl
	mov	eax, DWORD PTR _this$[esp+44]
	mov	ecx, DWORD PTR __Newsize$[esp+44]
	mov	DWORD PTR $T48799[esp+48], esp
	push	eax
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize

; 480  : 		}

	pop	ecx
	ret	8
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
_TEXT	ENDS
PUBLIC	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
;	COMDAT ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z
_TEXT	SEGMENT
_skip$ = -12						; size = 12
_skipUntilToken$ = 8					; size = 4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z PROC NEAR ; Json::Reader::recoverFromError, COMDAT
; _this$ = eax

; 615  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _skipUntilToken$[esp+16]
	push	esi
	mov	esi, eax

; 616  :    int errorCount = int(errors_.size());

	mov	ebx, DWORD PTR [esi+36]
	push	edi
$L13201:

; 617  :    Token skip;
; 618  :    while ( true )
; 619  :    {
; 620  :       if ( !readToken(skip) )

	lea	edi, DWORD PTR _skip$[esp+28]
	mov	eax, esi
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $L13203

; 621  :          errors_.resize( errorCount ); // discard errors caused by recovery

	push	ebx
	lea	eax, DWORD PTR [esi+20]
	push	eax
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$L13203:

; 622  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

	mov	eax, DWORD PTR _skip$[esp+28]
	cmp	eax, ebp
	je	SHORT $L48936
	test	eax, eax
	jne	SHORT $L13201
$L48936:

; 623  :          break;
; 624  :    }
; 625  :    errors_.resize( errorCount );

	push	ebx
	add	esi, 20					; 00000014H
	push	esi
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
	pop	edi
	pop	esi
	pop	ebp

; 626  :    return false;

	xor	al, al
	pop	ebx

; 627  : }

	add	esp, 12					; 0000000cH
	ret	4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ENDP ; Json::Reader::recoverFromError
PUBLIC	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
; Function compile flags: /Ogtpy
;	COMDAT ?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z
_TEXT	SEGMENT
_skipUntilToken$ = 8					; size = 4
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z PROC NEAR ; Json::Reader::addErrorAndRecover, COMDAT
; _this$ = esi
; _message$ = ecx
; _token$ = eax

; 635  :    addError( message, token );

	push	0
	push	eax
	push	ecx
	push	esi
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError

; 636  :    return recoverFromError( skipUntilToken );

	mov	eax, esi
	jmp	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ENDP ; Json::Reader::addErrorAndRecover
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeString
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T53454	DD	0ffffffffH
	DD	FLAT:$L53023
	DD	00H
	DD	FLAT:$L53024
$T53451	DD	019930520H
	DD	02H
	DD	FLAT:$T53454
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T53021 = -60						; size = 16
_decoded$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z PROC NEAR ; Json::Reader::decodeString, COMDAT
; _this$ = edx
; _token$ = ecx

; 517  : {

	push	-1
	push	__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	push	ebx
	push	esi

; 518  :    std::string decoded;

	xor	ebx, ebx
	mov	DWORD PTR __$ArrayPad$[esp+68], eax
	push	edi
	mov	esi, edx
	mov	DWORD PTR _decoded$[esp+96], 15		; 0000000fH
	mov	DWORD PTR _decoded$[esp+92], ebx
	mov	BYTE PTR _decoded$[esp+76], bl

; 519  :    if ( !decodeString( token, decoded ) )

	push	esi
	lea	edi, DWORD PTR _decoded$[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], ebx
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
	test	al, al
	jne	SHORT $L13114

; 520  :       return false;

	cmp	DWORD PTR _decoded$[esp+96], 16		; 00000010H
	jb	SHORT $L53181
	mov	eax, DWORD PTR _decoded$[esp+76]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53181:
	xor	al, al
	jmp	$L13112
$L13114:

; 521  :    currentValue() = decoded;

	mov	ecx, DWORD PTR $T53021[esp+80]
	mov	al, BYTE PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	and	ecx, -252				; ffffff04H
	or	ecx, 260				; 00000104H
	test	al, 1
	mov	DWORD PTR $T53021[esp+80], ecx
	mov	DWORD PTR $T53021[esp+84], ebx
	jne	SHORT $L53240
	mov	edx, DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA
	or	edx, 1
	push	OFFSET FLAT:_$E5
	mov	DWORD PTR ?$S4@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4IA, edx
	mov	DWORD PTR ?defaultAllocator@?1??valueAllocator@Json@@YAAAPAVValueAllocator@2@XZ@4VDefaultValueAllocator@2@A, OFFSET FLAT:??_7DefaultValueAllocator@Json@@6B@
	call	_atexit
	add	esp, 4
$L53240:
	mov	eax, DWORD PTR _decoded$[esp+96]
	mov	edi, 16					; 00000010H
	cmp	eax, edi
	mov	eax, DWORD PTR _decoded$[esp+76]
	jae	SHORT $L53237
	lea	eax, DWORD PTR _decoded$[esp+76]
$L53237:
	mov	ecx, DWORD PTR ?valueAllocator@?1??0Json@@YAAAPAVValueAllocator@1@XZ@4PAV21@A
	mov	edx, DWORD PTR [ecx]
	push	ebp
	mov	ebp, DWORD PTR _decoded$[esp+96]
	push	ebp
	push	eax
	call	DWORD PTR [edx+12]
	mov	DWORD PTR $T53021[esp+76], eax
	mov	BYTE PTR __$EHRec$[esp+84], 1
	mov	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+16]
	add	eax, ecx
	dec	eax
	mov	ecx, eax
	shr	eax, 2
	mov	edx, esi
	lea	esi, DWORD PTR [eax*4]
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	pop	ebp
	ja	SHORT $L53370
	sub	eax, esi
$L53370:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR $T53021[esp+72]
	mov	esi, ecx
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T53021[esp+72]
	mov	BYTE PTR __$EHRec$[esp+80], bl
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 522  :    return true;

	cmp	DWORD PTR _decoded$[esp+96], edi
	jb	SHORT $L53434
	mov	ecx, DWORD PTR _decoded$[esp+76]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53434:
	mov	al, 1
$L13112:

; 523  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+64]
	pop	ebx
	call	@__security_check_cookie@4
	add	esp, 60					; 0000003cH
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L53023:
	lea	ecx, DWORD PTR _decoded$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L53024:
	lea	ecx, DWORD PTR $T53021[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	eax, OFFSET FLAT:$T53451
	jmp	___CxxFrameHandler
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeString
PUBLIC	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeDouble
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
xdata$x	SEGMENT
$T54108	DD	0ffffffffH
	DD	FLAT:$L53467
	DD	00H
	DD	FLAT:$L53468
	DD	01H
	DD	FLAT:$L53469
	DD	0ffffffffH
	DD	FLAT:$L53470
$T54104	DD	019930520H
	DD	04H
	DD	FLAT:$T54108
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
_value$ = -112						; size = 8
$T53464 = -104						; size = 28
$T53465 = -76						; size = 16
$T53462 = -76						; size = 28
_buffer$13102 = -76					; size = 28
$T53463 = -48						; size = 28
_buffer$13099 = -48					; size = 32
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z PROC NEAR ; Json::Reader::decodeDouble, COMDAT
; _token$ = ecx

; 490  : {

	push	-1
	push	__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie

; 491  :    double value = 0;

	fld	QWORD PTR __real@0000000000000000
	push	ebx
	fstp	QWORD PTR _value$[esp+116]
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+116]
	mov	ebx, ecx

; 492  :    const int bufferSize = 32;
; 493  :    int count;
; 494  :    int length = int(token.end_ - token.start_);

	mov	ecx, DWORD PTR [ebx+8]
	mov	DWORD PTR __$ArrayPad$[esp+120], eax
	push	esi
	mov	esi, DWORD PTR [ebx+4]
	mov	eax, ecx
	sub	eax, esi

; 495  :    if ( length <= bufferSize )

	cmp	eax, 32					; 00000020H
	push	edi
	jg	SHORT $L13098

; 496  :    {
; 497  :       Char buffer[bufferSize];
; 498  :       memcpy( buffer, token.start_, length );

	mov	ecx, eax
	mov	edx, ecx
	shr	ecx, 2
	lea	edi, DWORD PTR _buffer$13099[esp+128]
	rep movsd
	mov	ecx, edx
	and	ecx, 3
	rep movsb

; 499  :       buffer[length] = 0;

	mov	BYTE PTR _buffer$13099[esp+eax+128], 0

; 500  :       count = sscanf( buffer, "%lf", &value );

	lea	eax, DWORD PTR _value$[esp+128]
	push	eax
	lea	ecx, DWORD PTR _buffer$13099[esp+132]
	push	OFFSET FLAT:??_C@_03DLDNIBIK@?$CFlf?$AA@
	push	ecx
	call	_sscanf
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 501  :    }
; 502  :    else

	xor	edi, edi
	jmp	SHORT $L53638
$L13098:

; 503  :    {
; 504  :       std::string buffer( token.start_, token.end_ );

	xor	edi, edi
	cmp	esi, ecx
	mov	DWORD PTR _buffer$13102[esp+152], 15	; 0000000fH
	mov	DWORD PTR _buffer$13102[esp+148], edi
	mov	BYTE PTR _buffer$13102[esp+132], 0
	je	SHORT $L54105
	sub	ecx, esi
	push	ecx
	push	esi
	lea	ecx, DWORD PTR _buffer$13102[esp+136]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 505  :       count = sscanf( buffer.c_str(), "%lf", &value );

	cmp	DWORD PTR _buffer$13102[esp+152], 16	; 00000010H
	mov	eax, DWORD PTR _buffer$13102[esp+132]
	jae	SHORT $L53579
$L54105:
	lea	eax, DWORD PTR _buffer$13102[esp+132]
$L53579:
	lea	edx, DWORD PTR _value$[esp+128]
	push	edx
	push	OFFSET FLAT:??_C@_03DLDNIBIK@?$CFlf?$AA@
	push	eax
	call	_sscanf
	mov	esi, eax

; 506  :    }

	mov	eax, DWORD PTR _buffer$13102[esp+164]
	add	esp, 12					; 0000000cH
	cmp	eax, 16					; 00000010H
	jb	SHORT $L53638
	mov	eax, DWORD PTR _buffer$13102[esp+132]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53638:

; 507  : 
; 508  :    if ( count != 1 )

	cmp	esi, 1
	je	$L13103

; 509  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	eax, DWORD PTR [ebx+8]
	mov	ecx, DWORD PTR [ebx+4]
	cmp	ecx, eax
	mov	DWORD PTR $T53462[esp+152], 15		; 0000000fH
	mov	DWORD PTR $T53462[esp+148], edi
	mov	BYTE PTR $T53462[esp+132], 0
	je	SHORT $L53719
	sub	eax, ecx
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T53462[esp+136]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L53719:
	lea	ecx, DWORD PTR $T53462[esp+128]
	push	ecx
	mov	ecx, OFFSET FLAT:??_C@_01GEODFPGF@?8?$AA@
	lea	esi, DWORD PTR $T53463[esp+132]
	mov	DWORD PTR __$EHRec$[esp+140], edi
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	eax
	mov	edi, OFFSET FLAT:??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	lea	esi, DWORD PTR $T53464[esp+136]
	mov	BYTE PTR __$EHRec$[esp+144], 1
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	xor	edi, edi
	push	edi
	push	ebx
	push	eax
	push	ebp
	mov	BYTE PTR __$EHRec$[esp+152], 2
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	bl, al
	mov	eax, DWORD PTR $T53464[esp+152]
	mov	esi, 16					; 00000010H
	cmp	eax, esi
	jb	SHORT $L53807
	mov	edx, DWORD PTR $T53464[esp+132]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53807:
	cmp	DWORD PTR $T53463[esp+152], esi
	mov	ebp, 15					; 0000000fH
	mov	DWORD PTR $T53464[esp+152], ebp
	mov	DWORD PTR $T53464[esp+148], edi
	mov	BYTE PTR $T53464[esp+132], 0
	jb	SHORT $L53886
	mov	eax, DWORD PTR $T53463[esp+132]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53886:
	cmp	DWORD PTR $T53462[esp+152], esi
	mov	DWORD PTR $T53463[esp+152], ebp
	mov	DWORD PTR $T53463[esp+148], edi
	mov	BYTE PTR $T53463[esp+132], 0
	jb	SHORT $L53959
	mov	ecx, DWORD PTR $T53462[esp+132]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L53959:
	mov	al, bl
	jmp	SHORT $L13093
$L13103:

; 510  :    currentValue() = value;

	mov	edx, DWORD PTR $T53465[esp+136]
	fld	QWORD PTR _value$[esp+128]
	and	edx, -253				; ffffff03H
	fstp	QWORD PTR $T53465[esp+128]
	or	edx, 3
	mov	DWORD PTR $T53465[esp+136], edx
	mov	DWORD PTR $T53465[esp+140], edi
	mov	DWORD PTR __$EHRec$[esp+136], 3
	mov	edx, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+16]
	add	eax, edx
	dec	eax
	mov	ecx, eax
	shr	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	edx, ebp
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L54099
	sub	eax, esi
$L54099:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR $T53465[esp+128]
	mov	esi, ecx
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T53465[esp+128]
	mov	DWORD PTR __$EHRec$[esp+136], -1
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 511  :    return true;

	mov	al, 1
$L13093:

; 512  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+128]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+116]
	pop	ebx
	call	@__security_check_cookie@4
	add	esp, 112				; 00000070H
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L53467:
	lea	ecx, DWORD PTR $T53462[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L53468:
	lea	ecx, DWORD PTR $T53463[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L53469:
	lea	ecx, DWORD PTR $T53464[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L53470:
	lea	ecx, DWORD PTR $T53465[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	eax, OFFSET FLAT:$T54104
	jmp	___CxxFrameHandler
text$x	ENDS
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeDouble
PUBLIC	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeNumber
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
xdata$x	SEGMENT
$T54868	DD	0ffffffffH
	DD	FLAT:$L54126
	DD	00H
	DD	FLAT:$L54127
	DD	01H
	DD	FLAT:$L54128
	DD	0ffffffffH
	DD	FLAT:$L54129
	DD	0ffffffffH
	DD	FLAT:$L54130
	DD	0ffffffffH
	DD	FLAT:$L54131
$T54855	DD	019930520H
	DD	06H
	DD	FLAT:$T54868
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv546 = -100						; size = 4
$T54125 = -96						; size = 16
$T54124 = -96						; size = 16
$T54123 = -96						; size = 16
$T54120 = -96						; size = 28
$T54122 = -68						; size = 28
$T54121 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_isNegative$ = 8					; size = 1
_this$ = 8						; size = 4
_token$ = 12						; size = 4
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z PROC NEAR ; Json::Reader::decodeNumber, COMDAT

; 452  : {

	push	-1
	push	__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 88					; 00000058H
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+100]
	push	esi

; 453  :    bool isDouble = false;
; 454  :    for ( Location inspect = token.start_; inspect != token.end_; ++inspect )

	mov	esi, DWORD PTR _token$[esp+104]
	mov	edx, DWORD PTR [esi+4]
	push	edi
	mov	edi, DWORD PTR [esi+8]
	mov	ecx, edx
	xor	al, al
	cmp	ecx, edi
	mov	DWORD PTR tv546[esp+112], edx
	je	SHORT $L13050
$L13047:

; 455  :    {
; 456  :       isDouble = isDouble  
; 457  :                  ||  in( *inspect, '.', 'e', 'E', '+' )  
; 458  :                  ||  ( *inspect == '-'  &&  inspect != token.start_ );

	test	al, al
	jne	SHORT $L54114
	mov	al, BYTE PTR [ecx]
	cmp	al, 46					; 0000002eH
	je	SHORT $L54114
	cmp	al, 101					; 00000065H
	je	SHORT $L54114
	cmp	al, 69					; 00000045H
	je	SHORT $L54114
	cmp	al, 43					; 0000002bH
	je	SHORT $L54114
	cmp	al, 45					; 0000002dH
	jne	SHORT $L54115
	cmp	ecx, edx
	jne	SHORT $L54114
$L54115:
	xor	al, al
	jmp	SHORT $L54116
$L54114:
	mov	al, 1
$L54116:

; 453  :    bool isDouble = false;
; 454  :    for ( Location inspect = token.start_; inspect != token.end_; ++inspect )

	inc	ecx
	cmp	ecx, edi
	jne	SHORT $L13047

; 459  :    }
; 460  :    if ( isDouble )

	test	al, al
	je	SHORT $L13050

; 461  :       return decodeDouble( token );

	push	ebp
	mov	ecx, esi
	call	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
	pop	edi
	pop	esi
	pop	ebp

; 484  :    return true;
; 485  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 100				; 00000064H
	ret	8
$L13050:

; 462  :    Location current = token.start_;

	mov	ecx, edx
	push	ebx

; 463  :    bool isNegative = *current == '-';

	cmp	BYTE PTR [ecx], 45			; 0000002dH
	sete	al

; 464  :    if ( isNegative )

	test	al, al
	mov	BYTE PTR _isNegative$[esp+112], al
	je	SHORT $L54117

; 465  :       ++current;

	inc	ecx

; 466  :    Value::UInt threshold = (isNegative ? Value::UInt(-Value::minInt) 
; 467  :                                        : Value::maxUInt) / 10;

	mov	edx, -2147483648			; 80000000H
	jmp	SHORT $L54118
$L54117:
	or	edx, -1
$L54118:
	mov	eax, -858993459				; cccccccdH
	mul	edx
	mov	esi, edx
	shr	esi, 3

; 468  :    Value::UInt value = 0;

	xor	ebx, ebx
	xor	eax, eax

; 469  :    while ( current < token.end_ )

	cmp	ecx, edi
	jae	SHORT $L13058
	npad	2
$L13057:

; 470  :    {
; 471  :       Char c = *current++;

	mov	dl, BYTE PTR [ecx]
	inc	ecx

; 472  :       if ( c < '0'  ||  c > '9' )

	cmp	dl, 48					; 00000030H
	jl	SHORT $L13061
	cmp	dl, 57					; 00000039H
	jg	SHORT $L13061

; 474  :       if ( value >= threshold )

	cmp	eax, esi
	jae	SHORT $L54859
	cmp	ecx, edi

; 476  :       value = value * 10 + Value::UInt(c - '0');

	movsx	edx, dl
	lea	eax, DWORD PTR [eax+eax*4]
	lea	eax, DWORD PTR [edx+eax*2-48]
	jb	SHORT $L13057
$L13058:

; 477  :    }
; 478  :    if ( isNegative )

	mov	cl, BYTE PTR _isNegative$[esp+112]
	test	cl, cl

; 479  :       currentValue() = -Value::Int( value );

	mov	DWORD PTR $T54123[esp+128], ebx
	je	$L13083
	mov	edx, DWORD PTR $T54123[esp+124]
	and	edx, -255				; ffffff01H
	or	edx, 1
	neg	eax
	mov	DWORD PTR $T54123[esp+124], edx
	mov	DWORD PTR $T54123[esp+116], eax
	mov	DWORD PTR __$EHRec$[esp+124], 3

; 480  :    else if ( value <= Value::UInt(Value::maxInt) )

	jmp	$L54867
$L54859:

; 475  :          return decodeDouble( token );

	mov	ecx, DWORD PTR _token$[esp+112]
	push	ebp
	call	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 484  :    return true;
; 485  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 100				; 00000064H
	ret	8
$L13061:

; 473  :          return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	eax, DWORD PTR tv546[esp+116]
	cmp	eax, edi
	mov	DWORD PTR $T54120[esp+140], 15		; 0000000fH
	mov	DWORD PTR $T54120[esp+136], ebx
	mov	BYTE PTR $T54120[esp+120], 0
	je	SHORT $L54205
	sub	edi, eax
	push	edi
	push	eax
	lea	ecx, DWORD PTR $T54120[esp+124]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L54205:
	lea	eax, DWORD PTR $T54120[esp+116]
	push	eax
	mov	ecx, OFFSET FLAT:??_C@_01GEODFPGF@?8?$AA@
	lea	esi, DWORD PTR $T54121[esp+120]
	mov	DWORD PTR __$EHRec$[esp+128], ebx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	eax
	mov	edi, OFFSET FLAT:??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	lea	esi, DWORD PTR $T54122[esp+124]
	mov	BYTE PTR __$EHRec$[esp+132], 1
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	mov	ecx, DWORD PTR _token$[esp+112]
	push	ebx
	push	ecx
	push	eax
	push	ebp
	mov	BYTE PTR __$EHRec$[esp+140], 2
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	bl, al
	mov	eax, DWORD PTR $T54122[esp+140]
	mov	esi, 16					; 00000010H
	cmp	eax, esi
	jb	SHORT $L54292
	mov	edx, DWORD PTR $T54122[esp+120]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L54292:
	mov	eax, DWORD PTR $T54121[esp+140]
	xor	edi, edi
	cmp	eax, esi
	mov	ebp, 15					; 0000000fH
	mov	DWORD PTR $T54122[esp+140], ebp
	mov	DWORD PTR $T54122[esp+136], edi
	mov	BYTE PTR $T54122[esp+120], 0
	jb	SHORT $L54366
	mov	eax, DWORD PTR $T54121[esp+120]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L54366:
	cmp	DWORD PTR $T54120[esp+140], esi
	mov	DWORD PTR $T54121[esp+140], ebp
	mov	DWORD PTR $T54121[esp+136], edi
	mov	BYTE PTR $T54121[esp+120], 0
	jb	SHORT $L54439
	mov	ecx, DWORD PTR $T54120[esp+120]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L54439:
	mov	al, bl
	pop	ebx
	pop	edi
	pop	esi
	pop	ebp

; 484  :    return true;
; 485  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+100]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 100				; 00000064H
	ret	8
$L13083:

; 480  :    else if ( value <= Value::UInt(Value::maxInt) )

	cmp	eax, 2147483647				; 7fffffffH

; 481  :       currentValue() = Value::Int( value );

	mov	ecx, DWORD PTR $T54124[esp+124]
	mov	DWORD PTR $T54124[esp+116], eax
	ja	SHORT $L13086
	and	ecx, -255				; ffffff01H
	or	ecx, 1
	mov	DWORD PTR $T54124[esp+124], ecx
	mov	DWORD PTR __$EHRec$[esp+124], 4

; 482  :    else

	jmp	SHORT $L54867
$L13086:

; 483  :       currentValue() = value;

	and	ecx, -254				; ffffff02H
	or	ecx, 2
	mov	DWORD PTR $T54125[esp+124], ecx
	mov	DWORD PTR __$EHRec$[esp+124], 5
$L54867:
	mov	edx, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+16]
	add	eax, edx
	dec	eax
	mov	ecx, eax
	shr	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	edx, ebp
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L54849
	sub	eax, esi
$L54849:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	esi, ecx
	lea	eax, DWORD PTR $T54125[esp+116]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T54125[esp+116]
	mov	DWORD PTR __$EHRec$[esp+124], -1
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 484  :    return true;
; 485  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+116]
	pop	ebx
	pop	edi
	pop	esi
	mov	al, 1
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 100				; 00000064H
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L54129:
	lea	ecx, DWORD PTR $T54123[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L54126:
	lea	ecx, DWORD PTR $T54120[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L54127:
	lea	ecx, DWORD PTR $T54121[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L54128:
	lea	ecx, DWORD PTR $T54122[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L54130:
	lea	ecx, DWORD PTR $T54124[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L54131:
	lea	ecx, DWORD PTR $T54125[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	eax, OFFSET FLAT:$T54855
	jmp	___CxxFrameHandler
text$x	ENDS
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeNumber
PUBLIC	?readValue@Reader@Json@@AAE_NXZ			; Json::Reader::readValue
PUBLIC	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readObject
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T57215	DD	0ffffffffH
	DD	FLAT:$L55609
	DD	00H
	DD	FLAT:$L55712
	DD	00H
	DD	FLAT:$L55610
	DD	00H
	DD	FLAT:$L55611
	DD	00H
	DD	FLAT:$L55612
	DD	00H
	DD	FLAT:$L55613
$T57192	DD	019930520H
	DD	06H
	DD	FLAT:$T57215
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T55715 = -128						; size = 4
$T55602 = -128						; size = 4
$T55608 = -124						; size = 28
$T55601 = -124						; size = 28
$T55605 = -96						; size = 28
_colon$12997 = -96					; size = 12
$T55597 = -96						; size = 16
_tokenName$ = -68					; size = 12
_comma$13008 = -56					; size = 12
_name$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__$ReturnAddr$ = 4					; size = 4
_this$ = 8						; size = 4
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z PROC NEAR	; Json::Reader::readObject, COMDAT

; 361  : {

	push	-1
	push	__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	push	ebx
	push	ebp
	mov	ebp, DWORD PTR _this$[esp+132]

; 362  :    Token tokenName;
; 363  :    std::string name;

	xor	ebx, ebx
	push	esi
	mov	DWORD PTR __$ArrayPad$[esp+140], eax
	push	edi
	mov	DWORD PTR _name$[esp+168], 15		; 0000000fH
	mov	DWORD PTR _name$[esp+164], ebx
	mov	BYTE PTR _name$[esp+148], bl
	mov	DWORD PTR __$EHRec$[esp+152], ebx

; 406  :    }
; 407  :    return addErrorAndRecover( "Missing '}' or object member name", 
; 408  :                               tokenName, 
; 409  :                               tokenObjectEnd );

	mov	eax, DWORD PTR $T55597[esp+152]
	and	eax, -505				; fffffe07H
	or	eax, 7
	push	12					; 0000000cH
	mov	DWORD PTR $T55597[esp+156], eax
	mov	DWORD PTR $T55597[esp+160], ebx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T55715[esp+144], eax
	cmp	eax, ebx
	mov	BYTE PTR __$EHRec$[esp+152], 1
	je	SHORT $L55716
	mov	esi, eax
	call	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
	jmp	SHORT $L55717

; 364  :    currentValue() = Value( objectValue );

$L55716:
	xor	eax, eax
$L55717:
	mov	DWORD PTR $T55597[esp+144], eax
	mov	BYTE PTR __$EHRec$[esp+152], 2
	mov	ecx, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [ebp+12]
	add	eax, ecx
	dec	eax
	mov	ecx, eax
	shr	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	edx, ebp
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L55853
	sub	eax, esi
$L55853:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR $T55597[esp+144]
	mov	esi, ecx
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T55597[esp+144]
	mov	BYTE PTR __$EHRec$[esp+152], 0
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 365  :    while ( readToken( tokenName ) )

	lea	edi, DWORD PTR _tokenName$[esp+144]
	mov	eax, ebp
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$L57210
$L12985:

; 366  :    {
; 367  :       bool initialTokenOk = true;
; 368  :       while ( tokenName.type_ == tokenComment  &&  initialTokenOk )

	mov	ecx, DWORD PTR _tokenName$[esp+144]
	cmp	ecx, 12					; 0000000cH
	mov	al, 1
	jne	SHORT $L57204
	npad	1
$L12989:
	test	al, al
	je	$L57210

; 369  :          initialTokenOk = readToken( tokenName );

	lea	edi, DWORD PTR _tokenName$[esp+144]
	mov	eax, ebp
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	ecx, DWORD PTR _tokenName$[esp+144]
	cmp	ecx, 12					; 0000000cH
	je	SHORT $L12989

; 370  :       if  ( !initialTokenOk )

	test	al, al
	je	$L57210
$L57204:

; 371  :          break;
; 372  :       if ( tokenName.type_ == tokenObjectEnd  &&  name.empty() )  // empty object

	cmp	ecx, 2
	je	$L57205

; 374  :       if ( tokenName.type_ != tokenString )

	cmp	ecx, 5
	jne	$L57210

; 375  :          break;
; 376  :       
; 377  :       name = "";

	push	ebx
	push	OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _name$[esp+152]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 378  :       if ( !decodeString( tokenName, name ) )

	push	ebp
	lea	edi, DWORD PTR _name$[esp+148]
	lea	ecx, DWORD PTR _tokenName$[esp+148]
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
	test	al, al

; 380  : 
; 381  :       Token colon;
; 382  :       if ( !readToken( colon ) ||  colon.type_ != tokenMemberSeparator )

	mov	eax, ebp
	je	$L57198
	lea	edi, DWORD PTR _colon$12997[esp+144]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$L12999
	cmp	DWORD PTR _colon$12997[esp+144], 11	; 0000000bH
	jne	$L12999

; 387  :       }
; 388  :       Value &value = currentValue()[ name ];

	mov	ecx, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [ebp+12]
	add	eax, ecx
	dec	eax
	mov	ecx, eax
	shr	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	edx, ebp
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L56382
	sub	eax, esi
$L56382:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4]
	cmp	DWORD PTR _name$[esp+168], 16		; 00000010H
	mov	ecx, DWORD PTR _name$[esp+148]
	jae	SHORT $L56430
	lea	ecx, DWORD PTR _name$[esp+148]
$L56430:
	push	ebx
	push	eax
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference

; 389  :       nodes_.push( &value );

	mov	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR $T55602[esp+144], eax
	mov	eax, DWORD PTR [ebp+16]
	add	ecx, eax
	test	cl, 3
	jne	SHORT $L56506
	mov	ecx, DWORD PTR [ebp+8]
	add	eax, 4
	shr	eax, 2
	cmp	ecx, eax
	ja	SHORT $L56506
	push	1
	mov	ebx, ebp
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
	xor	ebx, ebx
$L56506:
	mov	edi, DWORD PTR [ebp+16]
	mov	esi, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+8]
	add	esi, edi
	mov	edi, esi
	shr	edi, 2
	cmp	eax, edi
	ja	SHORT $L56509
	sub	edi, eax
$L56509:
	mov	edx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [edx+edi*4], ebx
	jne	SHORT $L56510
	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR [ebp+4]
	add	esp, 4
	mov	DWORD PTR [ecx+edi*4], eax
$L56510:
	mov	edx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [edx+edi*4]
	and	esi, 3
	lea	esi, DWORD PTR [eax+esi*4]
	cmp	esi, ebx
	je	SHORT $L56500
	mov	ecx, DWORD PTR $T55602[esp+144]
	mov	DWORD PTR [esi], ecx
$L56500:
	mov	esi, DWORD PTR [ebp+16]
	inc	esi

; 390  :       bool ok = readValue();

	mov	ecx, ebp
	mov	DWORD PTR [ebp+16], esi
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue

; 391  :       nodes_.pop();

	mov	ecx, DWORD PTR [ebp+16]
	cmp	ecx, ebx
	je	SHORT $L56535
	dec	ecx
	cmp	ecx, ebx
	mov	DWORD PTR [ebp+16], ecx
	jne	SHORT $L56535
	mov	DWORD PTR [ebp+12], ebx
$L56535:

; 392  :       if ( !ok ) // error already set

	test	al, al

; 394  : 
; 395  :       Token comma;
; 396  :       if ( !readToken( comma )
; 397  :             ||  ( comma.type_ != tokenObjectEnd  &&  
; 398  :                   comma.type_ != tokenArraySeparator ) )

	mov	eax, ebp
	je	$L57200
	lea	edi, DWORD PTR _comma$13008[esp+144]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$L57209
	mov	eax, DWORD PTR _comma$13008[esp+144]
	cmp	eax, 2
	je	$L57202
	cmp	eax, 10					; 0000000aH
	jne	$L57209
	lea	edi, DWORD PTR _tokenName$[esp+144]
	mov	eax, ebp
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	$L12985
$L57210:

; 406  :    }
; 407  :    return addErrorAndRecover( "Missing '}' or object member name", 
; 408  :                               tokenName, 
; 409  :                               tokenObjectEnd );

	push	33					; 00000021H
	push	OFFSET FLAT:??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
	lea	ecx, DWORD PTR $T55608[esp+152]
	mov	DWORD PTR $T55608[esp+176], 15		; 0000000fH
	mov	DWORD PTR $T55608[esp+172], ebx
	mov	BYTE PTR $T55608[esp+156], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	lea	edx, DWORD PTR _tokenName$[esp+148]
	push	edx
	lea	eax, DWORD PTR $T55608[esp+152]
	push	eax
	push	ebp
	mov	BYTE PTR __$EHRec$[esp+168], 5
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	push	2
	mov	eax, ebp
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	bl, al
	mov	eax, DWORD PTR $T55608[esp+168]
	mov	esi, 16					; 00000010H
	cmp	eax, esi
	jb	SHORT $L57108
	mov	ecx, DWORD PTR $T55608[esp+148]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L57108:
	cmp	DWORD PTR _name$[esp+168], esi
	mov	DWORD PTR $T55608[esp+168], 15		; 0000000fH
	mov	DWORD PTR $T55608[esp+164], 0
	mov	BYTE PTR $T55608[esp+148], 0
	jb	SHORT $L57181
	mov	edx, DWORD PTR _name$[esp+148]
	push	edx
$L57214:
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L57181:
	mov	al, bl
$L12980:

; 410  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+144]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR fs:__except_list, ecx
	mov	ecx, DWORD PTR __$ArrayPad$[esp+132]
	pop	ebx
	call	@__security_check_cookie@4
	add	esp, 128				; 00000080H
	ret	4
$L57205:

; 371  :          break;
; 372  :       if ( tokenName.type_ == tokenObjectEnd  &&  name.empty() )  // empty object

	cmp	DWORD PTR _name$[esp+164], ebx

; 374  :       if ( tokenName.type_ != tokenString )

	jne	$L57210
$L57202:

; 373  :          return true;

	cmp	DWORD PTR _name$[esp+168], 16		; 00000010H
	jb	SHORT $L56927
	mov	edx, DWORD PTR _name$[esp+148]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 403  :       }
; 404  :       if ( comma.type_ == tokenObjectEnd )
; 405  :          return true;

$L56927:

; 373  :          return true;

	mov	al, 1
	jmp	SHORT $L12980
$L57198:

; 379  :          return recoverFromError( tokenObjectEnd );

	push	2
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	bl, al
	cmp	DWORD PTR _name$[esp+168], 16		; 00000010H
	jb	SHORT $L57181
	mov	eax, DWORD PTR _name$[esp+148]
	push	eax
	jmp	SHORT $L57214
$L57200:

; 393  :          return recoverFromError( tokenObjectEnd );

	push	2
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	bl, al
	cmp	DWORD PTR _name$[esp+168], 16		; 00000010H
	jb	SHORT $L57181
	mov	ecx, DWORD PTR _name$[esp+148]
	push	ecx
	jmp	SHORT $L57214
$L57209:

; 399  :       {
; 400  :          return addErrorAndRecover( "Missing ',' or '}' in object declaration", 
; 401  :                                     comma, 
; 402  :                                     tokenObjectEnd );

	push	40					; 00000028H
	push	OFFSET FLAT:??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
	lea	ecx, DWORD PTR $T55605[esp+152]
	mov	DWORD PTR $T55605[esp+176], 15		; 0000000fH
	mov	DWORD PTR $T55605[esp+172], ebx
	mov	BYTE PTR $T55605[esp+156], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	lea	eax, DWORD PTR _comma$13008[esp+148]
	push	eax
	lea	ecx, DWORD PTR $T55605[esp+152]
	push	ecx
	push	ebp
	mov	BYTE PTR __$EHRec$[esp+168], 4
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	push	2
	mov	eax, ebp
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	bl, al
	mov	eax, DWORD PTR $T55605[esp+168]
	mov	esi, 16					; 00000010H
	cmp	eax, esi
	jb	SHORT $L56775
	mov	edx, DWORD PTR $T55605[esp+148]
	push	edx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L56775:
	cmp	DWORD PTR _name$[esp+168], esi
	mov	DWORD PTR $T55605[esp+168], 15		; 0000000fH
	mov	DWORD PTR $T55605[esp+164], 0
	mov	BYTE PTR $T55605[esp+148], 0
	jb	$L57181
	mov	eax, DWORD PTR _name$[esp+148]
	push	eax
	jmp	$L57214
$L12999:

; 383  :       {
; 384  :          return addErrorAndRecover( "Missing ':' after object member name", 
; 385  :                                     colon, 
; 386  :                                     tokenObjectEnd );

	push	36					; 00000024H
	push	OFFSET FLAT:??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
	lea	ecx, DWORD PTR $T55601[esp+152]
	mov	DWORD PTR $T55601[esp+176], 15		; 0000000fH
	mov	DWORD PTR $T55601[esp+172], ebx
	mov	BYTE PTR $T55601[esp+156], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	lea	ecx, DWORD PTR _colon$12997[esp+148]
	push	ecx
	lea	edx, DWORD PTR $T55601[esp+152]
	push	edx
	push	ebp
	mov	BYTE PTR __$EHRec$[esp+168], 3
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	push	2
	mov	eax, ebp
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	bl, al
	mov	eax, DWORD PTR $T55601[esp+168]
	mov	esi, 16					; 00000010H
	cmp	eax, esi
	jb	SHORT $L56193
	mov	eax, DWORD PTR $T55601[esp+148]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L56193:
	cmp	DWORD PTR _name$[esp+168], esi
	mov	DWORD PTR $T55601[esp+168], 15		; 0000000fH
	mov	DWORD PTR $T55601[esp+164], 0
	mov	BYTE PTR $T55601[esp+148], 0
	jb	$L57181
	mov	ecx, DWORD PTR _name$[esp+148]
	push	ecx
	jmp	$L57214
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L55609:
	lea	ecx, DWORD PTR _name$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L55712:
	mov	eax, DWORD PTR $T55715[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L55610:
	lea	ecx, DWORD PTR $T55597[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L55613:
	lea	ecx, DWORD PTR $T55608[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L55612:
	lea	ecx, DWORD PTR $T55605[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$L55611:
	lea	ecx, DWORD PTR $T55601[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	eax, OFFSET FLAT:$T57192
	jmp	___CxxFrameHandler
text$x	ENDS
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readObject
PUBLIC	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readArray
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\deque
xdata$x	SEGMENT
$T57783	DD	0ffffffffH
	DD	FLAT:$L57226
	DD	0ffffffffH
	DD	FLAT:$L57227
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:$L57228
	DD	0ffffffffH
	DD	FLAT:$L57229
$T57778	DD	019930520H
	DD	05H
	DD	FLAT:$T57783
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?readValue@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
_successful$ = -69					; size = 1
_token$ = -68						; size = 12
$T57223 = -56						; size = 16
$T57222 = -56						; size = 16
$T57221 = -56						; size = 16
$T57225 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?readValue@Reader@Json@@AAE_NXZ PROC NEAR		; Json::Reader::readValue, COMDAT
; _this$ = ecx

; 83   : {

	push	-1
	mov	eax, DWORD PTR fs:__except_list
	push	__ehhandler$?readValue@Reader@Json@@AAE_NXZ
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, ecx
	npad	2

; 84   :    Token token;
; 85   :    skipCommentTokens( token );

$L57232:
	lea	edi, DWORD PTR _token$[esp+88]
	mov	eax, ebp
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	cmp	DWORD PTR _token$[esp+88], 12		; 0000000cH
	je	SHORT $L57232

; 86   :    bool successful = true;
; 87   : 
; 88   :    if ( collectComments_  &&  !commentsBefore_.empty() )

	mov	al, BYTE PTR [ebp+116]
	xor	ebx, ebx
	cmp	al, bl
	mov	BYTE PTR _successful$[esp+88], 1
	mov	edi, 16					; 00000010H
	je	SHORT $L57407
	cmp	DWORD PTR [ebp+108], ebx
	je	SHORT $L57407

; 89   :    {
; 90   :       currentValue().setComment( commentsBefore_, commentBefore );

	mov	edx, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+16]
	add	eax, edx
	dec	eax
	mov	ecx, eax
	shr	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	edx, ebp
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L57366
	sub	eax, esi
$L57366:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [ebp+112]
	cmp	eax, edi
	lea	esi, DWORD PTR [ebp+88]
	jb	SHORT $L57387
	mov	eax, DWORD PTR [esi+4]
	jmp	SHORT $L57388
$L57387:
	lea	eax, DWORD PTR [esi+4]
$L57388:
	push	ebx
	push	eax
	call	?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ; Json::Value::setComment

; 91   :       commentsBefore_ = "";

	push	ebx
	push	OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$L57407:

; 92   :    }
; 93   : 
; 94   : 
; 95   :    switch ( token.type_ )

	mov	eax, DWORD PTR _token$[esp+88]
	dec	eax
	cmp	eax, 8
	ja	$L12760
	jmp	DWORD PTR $L57782[eax*4]
$L12750:

; 96   :    {
; 97   :    case tokenObjectBegin:
; 98   :       successful = readObject( token );

	push	ebp
	call	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readObject
	mov	BYTE PTR _successful$[esp+88], al

; 99   :       break;

	jmp	$L12747
$L12751:

; 100  :    case tokenArrayBegin:
; 101  :       successful = readArray( token );

	lea	ecx, DWORD PTR _token$[esp+88]
	push	ecx
	mov	ecx, ebp
	call	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readArray
	mov	BYTE PTR _successful$[esp+88], al

; 102  :       break;

	jmp	$L12747
$L12752:

; 103  :    case tokenNumber:
; 104  :       successful = decodeNumber( token );

	lea	edx, DWORD PTR _token$[esp+88]
	push	edx
	push	ebp
	call	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeNumber
	mov	BYTE PTR _successful$[esp+88], al

; 105  :       break;

	jmp	$L12747
$L12753:

; 106  :    case tokenString:
; 107  :       successful = decodeString( token );

	lea	ecx, DWORD PTR _token$[esp+88]
	mov	edx, ebp
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeString
	mov	BYTE PTR _successful$[esp+88], al

; 108  :       break;

	jmp	SHORT $L12747
$L12754:

; 109  :    case tokenTrue:
; 110  :       currentValue() = true;

	mov	eax, DWORD PTR $T57221[esp+96]
	and	eax, -251				; ffffff05H
	or	eax, 5
	mov	DWORD PTR $T57221[esp+96], eax
	mov	DWORD PTR $T57221[esp+100], ebx
	mov	BYTE PTR $T57221[esp+88], 1
	mov	DWORD PTR __$EHRec$[esp+96], ebx

; 111  :       break;

	jmp	SHORT $L57781
$L12756:

; 112  :    case tokenFalse:
; 113  :       currentValue() = false;

	mov	ecx, DWORD PTR $T57222[esp+96]
	and	ecx, -251				; ffffff05H
	or	ecx, 5
	mov	DWORD PTR $T57222[esp+96], ecx
	mov	DWORD PTR $T57222[esp+100], ebx
	mov	BYTE PTR $T57222[esp+88], bl
	mov	DWORD PTR __$EHRec$[esp+96], 1

; 114  :       break;

	jmp	SHORT $L57781
$L12758:

; 115  :    case tokenNull:
; 116  :       currentValue() = Value();

	and	DWORD PTR $T57223[esp+96], -512		; fffffe00H
	mov	DWORD PTR $T57223[esp+100], ebx
	mov	DWORD PTR __$EHRec$[esp+96], 3
$L57781:
	mov	ecx, ebp
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	esi, eax
	lea	eax, DWORD PTR $T57223[esp+88]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T57223[esp+88]
	mov	DWORD PTR __$EHRec$[esp+96], -1
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L12747:

; 120  :    }
; 121  : 
; 122  :    if ( collectComments_ )

	cmp	BYTE PTR [ebp+116], bl
	je	SHORT $L12764

; 123  :    {
; 124  :       lastValueEnd_ = current_;
; 125  :       lastValue_ = &currentValue();

	mov	eax, DWORD PTR [ebp+16]
	mov	ebx, DWORD PTR [ebp+12]
	mov	edx, DWORD PTR [ebp+76]
	add	eax, ebx
	dec	eax
	mov	ecx, eax
	shr	eax, 2
	mov	DWORD PTR [ebp+80], edx
	lea	esi, DWORD PTR [eax*4]
	mov	edx, ebp
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L57772
	sub	eax, esi
$L57772:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebp+84], ecx
$L12764:

; 126  :    }
; 127  : 
; 128  :    return successful;

	mov	al, BYTE PTR _successful$[esp+88]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 129  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+72]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 72					; 00000048H
	ret	0
$L12760:

; 117  :       break;
; 118  :    default:
; 119  :       return addError( "Syntax error: value, object or array expected.", token );

	push	46					; 0000002eH
	push	OFFSET FLAT:??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
	lea	ecx, DWORD PTR $T57225[esp+96]
	mov	DWORD PTR $T57225[esp+120], 15		; 0000000fH
	mov	DWORD PTR $T57225[esp+116], ebx
	mov	BYTE PTR $T57225[esp+100], bl
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	ebx
	lea	edx, DWORD PTR _token$[esp+92]
	push	edx
	lea	eax, DWORD PTR $T57225[esp+96]
	push	eax
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+112], 4
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	bl, al
	cmp	DWORD PTR $T57225[esp+112], edi
	jb	SHORT $L57631
	mov	ecx, DWORD PTR $T57225[esp+92]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L57631:

; 129  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+88]
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 72					; 00000048H
	ret	0
	npad	3
$L57782:
	DD	$L12750
	DD	$L12760
	DD	$L12751
	DD	$L12760
	DD	$L12753
	DD	$L12752
	DD	$L12754
	DD	$L12756
	DD	$L12758
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L57226:
	lea	ecx, DWORD PTR $T57221[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L57227:
	lea	ecx, DWORD PTR $T57222[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L57228:
	lea	ecx, DWORD PTR $T57223[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L57229:
	lea	ecx, DWORD PTR $T57225[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readValue@Reader@Json@@AAE_NXZ:
	mov	eax, OFFSET FLAT:$T57778
	jmp	___CxxFrameHandler
text$x	ENDS
?readValue@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readValue
PUBLIC	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z	; Json::Reader::parse
; Function compile flags: /Ogtpy
;	COMDAT ?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
_TEXT	SEGMENT
_successful$ = -17					; size = 1
$T57789 = -16						; size = 4
_token$ = -12						; size = 12
_root$ = 8						; size = 4
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z PROC NEAR	; Json::Reader::parse, COMDAT
; _this$ = esi
; _beginDoc$ = eax
; _endDoc$ = ecx
; _collectComments$ = edx

; 59   : {

	sub	esp, 20					; 00000014H
	push	ebx
	push	ebp
	push	edi

; 60   :    begin_ = beginDoc;
; 61   :    end_ = endDoc;
; 62   :    collectComments_ = collectComments;
; 63   :    current_ = begin_;
; 64   :    lastValueEnd_ = 0;

	xor	ebx, ebx

; 65   :    lastValue_ = 0;
; 66   :    commentsBefore_ = "";

	push	ebx
	mov	DWORD PTR [esi+72], ecx
	lea	ebp, DWORD PTR [esi+88]
	push	OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
	mov	ecx, ebp
	mov	DWORD PTR [esi+68], eax
	mov	BYTE PTR [esi+116], dl
	mov	DWORD PTR [esi+76], eax
	mov	DWORD PTR [esi+80], ebx
	mov	DWORD PTR [esi+84], ebx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 67   :    errors_.clear();

	lea	edi, DWORD PTR [esi+20]
	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 68   :    while ( !nodes_.empty() )

	cmp	DWORD PTR [esi+16], ebx
	je	SHORT $L12735
$L12734:

; 69   :       nodes_.pop();

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, ebx
	je	SHORT $L57840
	dec	eax
	cmp	eax, ebx
	mov	DWORD PTR [esi+16], eax
	jne	SHORT $L57840
	mov	DWORD PTR [esi+12], ebx
$L57840:
	cmp	DWORD PTR [esi+16], ebx
	jne	SHORT $L12734
$L12735:

; 70   :    nodes_.push( &root );

	mov	eax, DWORD PTR _root$[esp+28]
	lea	ecx, DWORD PTR $T57789[esp+32]
	mov	DWORD PTR $T57789[esp+32], eax
	push	ecx
	mov	eax, esi
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back

; 71   :    
; 72   :    bool successful = readValue();

	mov	ecx, esi
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
	mov	BYTE PTR _successful$[esp+32], al
	npad	3

; 73   :    Token token;
; 74   :    skipCommentTokens( token );

$L57846:
	lea	edi, DWORD PTR _token$[esp+32]
	mov	eax, esi
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	cmp	DWORD PTR _token$[esp+32], 12		; 0000000cH
	je	SHORT $L57846

; 75   :    if ( collectComments_  &&  !commentsBefore_.empty() )

	cmp	BYTE PTR [esi+116], bl
	je	SHORT $L57880
	cmp	DWORD PTR [esi+108], ebx
	je	SHORT $L57880

; 76   :       root.setComment( commentsBefore_, commentAfter );

	cmp	DWORD PTR [ebp+24], 16			; 00000010H
	jb	SHORT $L57873
	mov	eax, DWORD PTR [ebp+4]
	jmp	SHORT $L57874
$L57873:
	lea	eax, DWORD PTR [ebp+4]
$L57874:
	mov	ecx, DWORD PTR _root$[esp+28]
	push	2
	push	eax
	call	?setComment@Value@Json@@QAEXPBDW4CommentPlacement@2@@Z ; Json::Value::setComment
$L57880:

; 77   :    return successful;

	mov	al, BYTE PTR _successful$[esp+32]
	pop	edi
	pop	ebp
	pop	ebx

; 78   : }

	add	esp, 20					; 00000014H
	ret	4
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ENDP	; Json::Reader::parse
_TEXT	ENDS
PUBLIC	?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
; Function compile flags: /Ogtpy
;	COMDAT ?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
_root$ = 8						; size = 4
_collectComments$ = 12					; size = 1
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z PROC NEAR ; Json::Reader::parse, COMDAT
; _this$ = ecx
; _document$ = eax

; 48   : {

	push	esi
	push	edi
	mov	esi, ecx

; 49   :    document_ = document;

	push	-1
	push	0
	lea	edi, DWORD PTR [esi+40]
	push	eax
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 50   :    const char *begin = document_.c_str();

	cmp	DWORD PTR [edi+24], 16			; 00000010H
	jb	SHORT $L57904
	mov	eax, DWORD PTR [edi+4]
	jmp	SHORT $L57905
$L57904:
	lea	eax, DWORD PTR [edi+4]
$L57905:

; 51   :    const char *end = begin + document_.length();
; 52   :    return parse( begin, end, root, collectComments );

	mov	edx, DWORD PTR _root$[esp+4]
	mov	ecx, DWORD PTR [esi+60]
	push	edx
	mov	dl, BYTE PTR _collectComments$[esp+8]
	add	ecx, eax
	call	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ; Json::Reader::parse
	pop	edi
	pop	esi

; 53   : }

	ret	8
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
;	COMDAT xdata$x
; File c:\program files\microsoft visual studio .net 2003\vc7\include\iosfwd
xdata$x	SEGMENT
$T58587	DD	0ffffffffH
	DD	FLAT:$L58007
	DD	0ffffffffH
	DD	FLAT:$L58000
	DD	0ffffffffH
	DD	FLAT:$L58001
$T58576	DD	019930520H
	DD	03H
	DD	FLAT:$T58587
	DD	2 DUP(00H)
	DD	2 DUP(00H)
; Function compile flags: /Ogtpy
; File f:\libs\jsoncpp\trunk\src\lib_json\json_reader.cpp
xdata$x	ENDS
;	COMDAT ?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T58010 = -60						; size = 4
_index$ = -60						; size = 4
_token$13034 = -56					; size = 12
_endArray$13025 = -56					; size = 12
$T57996 = -56						; size = 16
$T57999 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_tokenStart$ = 8					; size = 4
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z PROC NEAR	; Json::Reader::readArray, COMDAT
; _this$ = ecx

; 415  : {

	push	-1
	push	__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	sub	esp, 48					; 00000030H

; 438  :       {
; 439  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 
; 440  :                                     token, 
; 441  :                                     tokenArrayEnd );

	mov	eax, DWORD PTR $T57996[esp+68]
	push	ebx
	push	ebp
	push	esi
	and	eax, -506				; fffffe06H
	push	edi
	or	eax, 6
	xor	ebx, ebx
	push	12					; 0000000cH
	mov	ebp, ecx
	mov	DWORD PTR $T57996[esp+88], eax
	mov	DWORD PTR $T57996[esp+92], ebx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T58010[esp+76], eax
	cmp	eax, ebx
	mov	DWORD PTR __$EHRec$[esp+84], ebx
	je	SHORT $L58011
	mov	esi, eax
	call	??0?$map@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@@std@@QAE@XZ ; std::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >::map<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> > >
	jmp	SHORT $L58012

; 416  :    currentValue() = Value( arrayValue );

$L58011:
	xor	eax, eax
$L58012:
	mov	DWORD PTR $T57996[esp+76], eax
	mov	DWORD PTR __$EHRec$[esp+84], 1
	mov	ecx, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [ebp+12]
	add	eax, ecx
	dec	eax
	mov	ecx, eax
	shr	eax, 2
	lea	esi, DWORD PTR [eax*4]
	mov	edx, ebp
	sub	ecx, esi
	mov	esi, DWORD PTR [edx+8]
	cmp	esi, eax
	ja	SHORT $L58149
	sub	eax, esi
$L58149:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	ecx, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR $T57996[esp+76]
	mov	esi, ecx
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T57996[esp+76]
	mov	DWORD PTR __$EHRec$[esp+84], -1
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 417  :    skipSpaces();

	mov	ecx, DWORD PTR [ebp+76]
	cmp	ecx, DWORD PTR [ebp+72]
	je	SHORT $L58583
$L58155:
	mov	ecx, DWORD PTR [ebp+76]
	mov	al, BYTE PTR [ecx]
	cmp	al, 32					; 00000020H
	je	SHORT $L58159
	cmp	al, 9
	je	SHORT $L58159
	cmp	al, 13					; 0000000dH
	je	SHORT $L58159
	cmp	al, 10					; 0000000aH
	jne	SHORT $L58583
$L58159:
	inc	ecx
	mov	DWORD PTR [ebp+76], ecx
	mov	eax, DWORD PTR [ebp+72]
	mov	edx, ecx
	cmp	edx, eax
	jne	SHORT $L58155
$L58583:

; 418  :    if ( *current_ == ']' ) // empty array

	mov	eax, DWORD PTR [ebp+76]
	cmp	BYTE PTR [eax], 93			; 0000005dH
	jne	SHORT $L13028

; 419  :    {
; 420  :       Token endArray;
; 421  :       readToken( endArray );

	lea	edi, DWORD PTR _endArray$13025[esp+76]
	mov	eax, ebp
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
$L58581:
	pop	edi
	pop	esi
	pop	ebp

; 422  :       return true;

	mov	al, 1
	pop	ebx

; 442  :       }
; 443  :       if ( token.type_ == tokenArrayEnd )
; 444  :          break;
; 445  :    }
; 446  :    return true;
; 447  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 60					; 0000003cH
	ret	4
$L58584:

; 423  :    }
; 424  :    int index = 0;
; 425  :    while ( true )
; 426  :    {
; 427  :       Value &value = currentValue()[ index++ ];

	mov	ebx, DWORD PTR _index$[esp+76]
$L13028:
	mov	ecx, DWORD PTR [ebp+16]
	mov	eax, DWORD PTR [ebp+12]
	add	eax, ecx
	dec	eax
	mov	ecx, eax
	shr	eax, 2
	mov	edx, ebp
	mov	edi, DWORD PTR [edx+8]
	lea	esi, DWORD PTR [eax*4]
	sub	ecx, esi
	cmp	edi, eax
	ja	SHORT $L58288
	sub	eax, edi
$L58288:
	mov	edx, DWORD PTR [edx+4]
	mov	eax, DWORD PTR [edx+eax*4]
	mov	eax, DWORD PTR [eax+ecx*4]
	push	ebx
	push	eax
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]

; 428  :       nodes_.push( &value );

	mov	ecx, DWORD PTR [ebp+12]
	mov	esi, eax
	mov	eax, DWORD PTR [ebp+16]
	inc	ebx
	add	ecx, eax
	test	cl, 3
	mov	DWORD PTR _index$[esp+76], ebx
	jne	SHORT $L58350
	mov	ecx, DWORD PTR [ebp+8]
	add	eax, 4
	shr	eax, 2
	cmp	ecx, eax
	ja	SHORT $L58350
	push	1
	mov	ebx, ebp
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$L58350:
	mov	edi, DWORD PTR [ebp+16]
	mov	ebx, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR [ebp+8]
	add	ebx, edi
	mov	edi, ebx
	shr	edi, 2
	cmp	eax, edi
	ja	SHORT $L58353
	sub	edi, eax
$L58353:
	mov	edx, DWORD PTR [ebp+4]
	cmp	DWORD PTR [edx+edi*4], 0
	jne	SHORT $L58354
	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, DWORD PTR [ebp+4]
	add	esp, 4
	mov	DWORD PTR [ecx+edi*4], eax
$L58354:
	mov	edx, DWORD PTR [ebp+4]
	mov	eax, DWORD PTR [edx+edi*4]
	and	ebx, 3
	lea	ebx, DWORD PTR [eax+ebx*4]
	test	ebx, ebx
	je	SHORT $L58365
	mov	DWORD PTR [ebx], esi
$L58365:
	mov	esi, DWORD PTR [ebp+16]
	inc	esi

; 429  :       bool ok = readValue();

	mov	ecx, ebp
	mov	DWORD PTR [ebp+16], esi
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue

; 430  :       nodes_.pop();

	mov	ecx, DWORD PTR [ebp+16]
	test	ecx, ecx
	je	SHORT $L58392
	dec	ecx
	mov	DWORD PTR [ebp+16], ecx
	jne	SHORT $L58392
	mov	DWORD PTR [ebp+12], 0
$L58392:

; 431  :       if ( !ok ) // error already set

	test	al, al

; 433  : 
; 434  :       Token token;
; 435  :       if ( !readToken( token ) 
; 436  :            ||  ( token.type_ != tokenArraySeparator  &&  
; 437  :                  token.type_ != tokenArrayEnd ) )

	mov	eax, ebp
	je	$L58579
	lea	edi, DWORD PTR _token$13034[esp+76]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	SHORT $L58585
	mov	eax, DWORD PTR _token$13034[esp+76]
	cmp	eax, 10					; 0000000aH
	je	$L58584
	cmp	eax, 4
	je	$L58581
$L58585:

; 438  :       {
; 439  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 
; 440  :                                     token, 
; 441  :                                     tokenArrayEnd );

	push	39					; 00000027H
	push	OFFSET FLAT:??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
	lea	ecx, DWORD PTR $T57999[esp+84]
	mov	DWORD PTR $T57999[esp+108], 15		; 0000000fH
	mov	DWORD PTR $T57999[esp+104], 0
	mov	BYTE PTR $T57999[esp+88], 0
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	0
	lea	ecx, DWORD PTR _token$13034[esp+80]
	push	ecx
	lea	edx, DWORD PTR $T57999[esp+84]
	push	edx
	push	ebp
	mov	DWORD PTR __$EHRec$[esp+100], 2
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	push	4
	mov	eax, ebp
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	bl, al
	cmp	DWORD PTR $T57999[esp+100], 16		; 00000010H
	jb	SHORT $L58559
	mov	eax, DWORD PTR $T57999[esp+80]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L58559:
	pop	edi
	pop	esi
	pop	ebp
	mov	al, bl
	pop	ebx

; 442  :       }
; 443  :       if ( token.type_ == tokenArrayEnd )
; 444  :          break;
; 445  :    }
; 446  :    return true;
; 447  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+60]
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 60					; 0000003cH
	ret	4
$L58579:

; 432  :          return recoverFromError( tokenArrayEnd );

	push	4
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError

; 442  :       }
; 443  :       if ( token.type_ == tokenArrayEnd )
; 444  :          break;
; 445  :    }
; 446  :    return true;
; 447  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+76]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 60					; 0000003cH
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L58007:
	mov	eax, DWORD PTR $T58010[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L58000:
	lea	ecx, DWORD PTR $T57996[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$L58001:
	lea	ecx, DWORD PTR $T57999[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	eax, OFFSET FLAT:$T58576
	jmp	___CxxFrameHandler
text$x	ENDS
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readArray
END
